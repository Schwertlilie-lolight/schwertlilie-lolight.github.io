---
title: 再谈单例模式
date: '2017-05-25 11:58'
tags:
  - DesignPattern
categories:
  - DesignPattern
---

之前提到枚举实现是单例的最佳实现，这毋庸置疑；

不过，对比枚举和静态内部类，好像它们的区别就在于防止了反射攻击；

那么，都『攻击』了，为啥偏偏没事去改你的单例呢？直接获取更有意思的信息不是更好吗？

<!-- more -->

## 1. 『反射攻击』不是攻击

这里所提到的『反射攻击』的概念，实际上并不是信息安全领域的 『攻击』 的概念；

而是， **通过反射的合理利用，可以令单例失效**；

那么在日常开发中，最常遇到的反射攻击就是 **对象的序列化**。

当单例需要实现序列化的时候，反序列化过程实际上就是使用 **反射** 来生成了新的实例。

那么在序列化和反序列化的过程中，单例模式就被破坏掉了。

这时，有人提出可以利用 `readResolve()` 方法来防止这种事情的发生；

而实际上， **单纯利用** `readResolve()` 也并不能防止单例被破坏；

《Effective Java 第二版》在 77 条提出：

> **如果依赖 `readResolve()` 方法来进行实例控制，带有对象引用类型的所有实例域都必须声明为 `transient` 的。**
>
> 否则，那种破釜沉舟式的攻击者，就有可能在 `readResolve()` 方法运行之前，保护指向反序列化对象的引用。

此时，枚举类型就派上用场了，枚举为了防止这种事情的发生，单独实现了一套序列化和反序列化的机制；

大体就是利用 `valueOf()` 来进行反序列化，而不是使用普通的序列化机制；

同时，也禁止声明 `readResolve()` 和 `readObject()` 这类方法。

## 2. Kotlin 单例是饿汉式的

我原以为，Kotlin 身为 Better Java，会有一个语义化的，完美的单例实现方式，很可惜，它并不是。

虽然 Kotlin 提供了 `object` 关键字用来构造单例；

不过，它的单例实现却是 **饿汉式** 的。

一个单例经过反编译生成的 Java 代码如下：

```java
public final class Test {
   public static final Test INSTANCE;

   private Test() {
      INSTANCE = (Test)this;
   }

   static {
      new Test();
   }
}
```

很清楚的看到，这个单例的实现，是简单的饿汉式；

并不是 Java 单例的最佳实践。
