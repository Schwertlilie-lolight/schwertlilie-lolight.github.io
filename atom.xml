<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wafer&#39;s Note</title>
  
  <subtitle>Kancolle is life!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wafer.li/"/>
  <updated>2018-01-11T14:36:34.000Z</updated>
  <id>https://wafer.li/</id>
  
  <author>
    <name>Wafer Li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hexo 集成 Travis CI 自动部署博文</title>
    <link href="https://wafer.li/Hexo/Hexo%20%E9%9B%86%E6%88%90%20Travis%20CI%20%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%8D%9A%E6%96%87/"/>
    <id>https://wafer.li/Hexo/Hexo 集成 Travis CI 自动部署博文/</id>
    <published>2018-01-11T12:37:00.000Z</published>
    <updated>2018-01-11T14:36:34.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>这个想法是我在折腾 Hexo Next 6.0 的时候发现的，有位仁兄在 Next 的新 repo 问如何处理 CI 问题，受到他的启发，我就开始折腾使用 Travis CI 进行博客的自动部署了。</p><a id="more"></a><h2 id="1-为什么要用-CI-来部署博客"><a href="#1-为什么要用-CI-来部署博客" class="headerlink" title="1. 为什么要用 CI 来部署博客"></a>1. 为什么要用 CI 来部署博客</h2><p>遇到一项新技术，一个好习惯就是问一下自己 <strong>为什么要用这个新技术</strong>，它带来了什么好处，解决了什么问题？否则就会陷入为了使用新技术而使用新技术的陷阱之中。</p><p>那么为什么要用 CI 来部署呢？好处是显而易见的：</p><p>在未采用 CI 的时候，编写完博客总需要自己手动 <code>hexo g -d</code>，这种工作是重复性的、枯燥的，那么就应当尽量寻找让重复性的工作进行自动化的方法；</p><p>在使用 CI 之后，我只需要执行 <code>git push</code>，将博客的 markdown source 推到远端仓库，剩下的静态页面构建过程就由 CI 接手进行，而不需要我手动打字，而且还占用我的 CPU。</p><p>这虽然方便，但是不禁会有人担心：如果每 push 一次就会自己构建，博客会不会因为 push 上去了一些不好的东西而搞炸了？</p><p>其实这种担心是多余的，只需要在进行了大面积更改的时候先在本地查看一下，如果没有问题就再 push 就行了，这时候虽然需要本地生成，但是你不可能整天重构你的博客，所以 CI 的效率提升还是存在的。</p><h2 id="2-Travis-CI-的配置流程"><a href="#2-Travis-CI-的配置流程" class="headerlink" title="2. Travis CI 的配置流程"></a>2. Travis CI 的配置流程</h2><p>本博客采用 Travis CI 作为持续集成工具，下面就介绍一下基本的配置流程。</p><p>由于 Travis CI 比较流行，注册和关联 repo 这种操作就不介绍了。</p><h3 id="2-1-获取-Access-Token"><a href="#2-1-获取-Access-Token" class="headerlink" title="2.1 获取 Access Token"></a>2.1 获取 Access Token</h3><p>在做任何配置之前，我们首先要获取一个 Access Token，否则 Travis CI 即使生成了 HTML 也无法 push 到 master 分支进行部署。</p><p>GitHub 获取 Access Token 的步骤如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Settings -&gt; Developer settings -&gt; Personal access token</div><div class="line">-&gt; Generate new token</div></pre></td></tr></table></figure><p>接着就进入创建 Access Token 的页面了，对于一个博客的 CI 来说，我们需要的权限比较少，我尝试了一下只需要 <code>public_repo</code> 的权限即可；</p><p>为了尽量保证我们 GitHub 帐号的安全，能少给权限就少给。</p><p>然后我们选择生成，此时会返回到 <code>Personal access token</code> 的页面，并显示我们刚才生成的 access token。</p><blockquote><p>需要注意的是，这个 access token <strong>只会在这一个页面显示一次</strong>，切记要复制下来，否则就只能 <strong>重新生成</strong>。</p></blockquote><p>然后我们到博客 repo 的 Travis CI 设置页面中新建一个环境变量，将这个 Access Token 粘贴到环境变量的 value 中。</p><blockquote><p>这里要注意一定要关掉 <code>Display in log</code> 的选项，否则你的 Access Token 就泄漏了。</p></blockquote><h3 id="2-2-只构建含有-travis-yml-文件的分支"><a href="#2-2-只构建含有-travis-yml-文件的分支" class="headerlink" title="2.2 只构建含有 .travis.yml 文件的分支"></a>2.2 只构建含有 <code>.travis.yml</code> 文件的分支</h3><p>对于本博客而言，我采用单 repo 双分支管理，即一个 <code>source</code> 分支保存原始的 markdown 文件，另一个 <code>master</code> 分支保存用于部署的 HTML。</p><p>对于这种情况，我们就 <strong>必须要</strong> 在 Travis CI 的 <strong>repo 设置页面</strong> 中勾选 <strong>只构建含有 <code>.travis.yml</code> 文件的分支</strong>；</p><p>由于 Travis CI 会侦听 commit 事件进行自动构建，而对于 master 上的 commit，是不含有 <code>.travis.yml</code> 文件也不需要构建的。</p><p>为了防止 Travis CI 构建 master 分支，我们就必须要勾选这个选项。</p><p>有些教程提到使用</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attr">branches:</span></div><div class="line"><span class="attr">    only:</span></div><div class="line"><span class="bullet">        -</span> <span class="string">source</span></div></pre></td></tr></table></figure><p>也可以起到只构建 <code>source</code> 的功能；<br>不过在我这里这种方法行不通，最后还是使用了只构建含有 <code>.travis,yml</code> 文件的方法。</p><h3 id="2-3-travis-yml-文件的基本配置"><a href="#2-3-travis-yml-文件的基本配置" class="headerlink" title="2.3 .travis.yml 文件的基本配置"></a>2.3 <code>.travis.yml</code> 文件的基本配置</h3><p>本博客使用的 Hexo 框架是采用 Node.js 技术编写的，所以可以直接套用 Node.js 的 Travis CI 流程。</p><p>下面是一些基本的 Node.js <code>.travis.yml</code> 的配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 环境变量，注意一个 item 就会构建一次</span></div><div class="line"><span class="comment"># 所以一次构建中需要多个环境变量的，也要写到一行里</span></div><div class="line"><span class="attr">env:</span></div><div class="line"><span class="bullet">    -</span> <span class="string">ENV_1=xxxxxx</span> <span class="string">ENV_2=yyyyyy</span></div><div class="line"></div><div class="line"><span class="attr">language:</span> <span class="string">node_js</span>   <span class="comment"># 构建的编程语言</span></div><div class="line"><span class="attr">node_js:</span> <span class="string">node</span>       <span class="comment"># Node.js 的版本，node 表示最新版</span></div><div class="line"></div><div class="line"><span class="comment"># 缓存的目录</span></div><div class="line"><span class="comment"># Node.js 项目一般缓存 node_modules</span></div><div class="line"><span class="comment"># 用于加快构建速度</span></div><div class="line"><span class="attr">cache:</span></div><div class="line"><span class="attr">  directories:</span></div><div class="line"><span class="bullet">    -</span> <span class="string">"node_modules"</span></div><div class="line"></div><div class="line"><span class="comment"># 在 install 阶段之前执行的命令</span></div><div class="line"><span class="attr">before_install:</span></div><div class="line"></div><div class="line"><span class="comment"># Install 阶段，在这里是 npm install</span></div><div class="line"><span class="attr">install:</span> <span class="string">npm</span> <span class="string">install</span></div><div class="line"></div><div class="line"><span class="comment"># 在 script 之前执行的命令</span></div><div class="line"><span class="attr">before_script:</span></div><div class="line"></div><div class="line"><span class="comment"># Script 阶段，执行 hexo 相关命令</span></div><div class="line"><span class="attr">script:</span></div><div class="line"><span class="bullet">    -</span> <span class="string">hexo</span> <span class="string">clean</span></div><div class="line"><span class="bullet">    -</span> <span class="string">hexo</span> <span class="string">g</span> <span class="bullet">-d</span> <span class="bullet">--config</span> <span class="string">source/_data/next.yml</span></div></pre></td></tr></table></figure><p>在拥有 <code>.travis.yml</code> 文件后，每次 commit 之后 Travis CI 就会读取这个文件用来进行自动化构建工作</p><h2 id="3-相关的坑"><a href="#3-相关的坑" class="headerlink" title="3. 相关的坑"></a>3. 相关的坑</h2><p>当然，Travis CI 的配置不可能这么一帆风顺，还存在着非常多的坑。</p><p>下面就来介绍一下我所遇到的坑，希望给大家以前车之鉴。</p><h3 id="3-1-Git-Submodule-的坑"><a href="#3-1-Git-Submodule-的坑" class="headerlink" title="3.1 Git Submodule 的坑"></a>3.1 Git Submodule 的坑</h3><p>如果你的 GitHub 使用了两步验证，那么你平时肯定是使用 ssh 的地址进行 git 的相关操作；</p><p>但是对于 Travis CI 的虚拟机来说，它不具备你的 SSH key，当然也就不能使用 ssh 地址进行 clone 和 push。</p><p>特别是对于 git submodule，由于 Travis CI 自己可以处理 https 地址的 submodule，但是如果采用 ssh 方式，它根本就无法 clone 下来。</p><p>此时，我们就需要自己手动管理 git submodule，在 <code>.travis.yml</code> 中增加如下选项：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="attr">git:</span></div><div class="line"><span class="attr">    submodules:</span> <span class="literal">false</span></div><div class="line"></div><div class="line"><span class="attr">before_install:</span></div><div class="line"><span class="bullet">    -</span> <span class="string">sed</span> <span class="bullet">-i</span> <span class="string">'s/git@github.com:/https:\/\/github.com\//'</span> <span class="string">.gitmodules</span></div></pre></td></tr></table></figure><p>上面的 <code>sed</code> 命令就是将 ssh 地址替换成 https 地址的。</p><p>不过，对于后面的部署阶段，由于要 push 到自己的仓库，所以 deploy 的地址需要修改为 <code>https://&lt;username&gt;:&lt;ACCESS_TOKEN&gt;@github.com/&lt;username&gt;/repo.git</code></p><p>所以，如果使用 <code>hexo-deploy</code> 插件的话，还需要以下的命令：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attr">before_script:</span></div><div class="line"><span class="bullet">    -</span> <span class="string">sed</span> <span class="string">i</span> <span class="string">"s/git@github.com:/https:\/\/yourusername:$&#123;ACCESS_TOKEN&#125;@github.com\//"</span> <span class="string">you_config_file.yml</span></div></pre></td></tr></table></figure><p>把上面的 <code>yourusername</code> 和 <code>your_config_file.yml</code> 作出相应修改即可。</p><h3 id="3-2-安装某些额外程序包"><a href="#3-2-安装某些额外程序包" class="headerlink" title="3.2 安装某些额外程序包"></a>3.2 安装某些额外程序包</h3><p>如果你使用 <code>hexo-all-minifier</code> 来进行 HTML 的相关文件压缩，那么你就需要额外安装一个系统程序包 <code>nasm</code>。</p><p>Travis CI 对此推出了 <code>addons</code> 选项来方便你配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attr">addons:</span></div><div class="line"><span class="attr">  apt:</span></div><div class="line"><span class="attr">    packages:</span></div><div class="line"><span class="bullet">        -</span> <span class="string">nasm</span></div></pre></td></tr></table></figure><p>这个问题比较难暴露，我查看了很久的 log，最后在 <code>npm install</code> 的 log 里面发现了某个依赖没办法安装；</p><p>最后才发现是缺了一个系统的程序包。</p><h3 id="3-3-Patch-某些-Hexo-插件"><a href="#3-3-Patch-某些-Hexo-插件" class="headerlink" title="3.3 Patch 某些 Hexo 插件"></a>3.3 Patch 某些 Hexo 插件</h3><p>有时候你使用的 Hexo 插件有些问题，虽然有人提出了 PR，但是久久没有合并；</p><p>在本地生成的时代，你需要自己手动 patch 这个插件，然而我们现在使用 CI，当然不可能由你进去复制粘贴。</p><p>这时候，我们可以使用 <code>curl</code> 把 patch 文件下载下来，并覆写相关文件。</p><p>通过下面的命令可以进行覆写操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl &#123;raw-path-file-url&#125; &gt;| &#123;problem_file&#125;</div></pre></td></tr></table></figure><p>其中 <code>&gt;|</code> 符号可以使后面的文件清空，类似于文件操作的 <code>w</code> 选项。</p><h3 id="3-4-安装-Hexo-Next-主题的插件"><a href="#3-4-安装-Hexo-Next-主题的插件" class="headerlink" title="3.4 安装 Hexo Next 主题的插件"></a>3.4 安装 Hexo Next 主题的插件</h3><p>Hexo Next 在 6.0 之后，把一些原本在 <code>source/lib</code> 中的 js 文件移到了新的 repo 中，以减少 next 本身 repo 的复杂度。</p><p>但是由于 Next 把 <code>source/lib</code> 这个路径 ignore 了，所以我们要手动将插件 clone 到 <code>source/lib</code> 里面。</p><p>在使用 CI 时，我们需要在 <code>hexo g -d</code> 之前将插件装好：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="attr">before_script:</span></div><div class="line">  <span class="comment">## Theme Dependencies</span></div><div class="line"><span class="bullet">  -</span> <span class="string">cd</span> <span class="string">themes/next-reloaded</span></div><div class="line">  <span class="comment"># canvas-nest</span></div><div class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">clone</span> <span class="attr">https://github.com/theme-next/theme-next-canvas-nest</span> <span class="string">source/lib/canvas-nest</span></div><div class="line">  <span class="comment"># fancybox3</span></div><div class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">clone</span> <span class="attr">https://github.com/theme-next/theme-next-fancybox3</span> <span class="string">source/lib/fancybox</span></div><div class="line">  <span class="comment"># reading_progress</span></div><div class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">clone</span> <span class="attr">https://github.com/theme-next/theme-next-reading-progress</span> <span class="string">source/lib/reading_progress</span></div><div class="line"><span class="bullet">  -</span> <span class="string">cd</span> <span class="string">../..</span></div></pre></td></tr></table></figure><p>这里需要注意一下当前工作路径的问题，记得切换回原目录。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>经过一段时间的奋战，Travis CI 的集成终于做好了；<br>虽然花费了点时间，不过在折腾的过程中还接触了一下 Travis CI 的配置流程，想必还是有些收获的；</p><p>要不人们总说折腾博客比写博客有趣呢？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个想法是我在折腾 Hexo Next 6.0 的时候发现的，有位仁兄在 Next 的新 repo 问如何处理 CI 问题，受到他的启发，我就开始折腾使用 Travis CI 进行博客的自动部署了。&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="https://wafer.li/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://wafer.li/tags/Hexo/"/>
    
      <category term="Trivas CI" scheme="https://wafer.li/tags/Trivas-CI/"/>
    
  </entry>
  
  <entry>
    <title>Solidity 基础知识和概述</title>
    <link href="https://wafer.li/Solidity/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%92%8C%E6%A6%82%E8%BF%B0/"/>
    <id>https://wafer.li/Solidity/基础知识和概述/</id>
    <published>2018-01-09T06:09:00.000Z</published>
    <updated>2018-01-10T05:41:08.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Solidity 是运行于以太坊(Ethereum) 区块链上的智能合约语言，它是图灵完备的，意味着可以用它写一些任意复杂度的程序并运行于区块链中。</p><a id="more"></a><h2 id="1-区块链基础知识"><a href="#1-区块链基础知识" class="headerlink" title="1. 区块链基础知识"></a>1. 区块链基础知识</h2><p>区块链加密货币的技术基础，本文属于 Solidity，对此不过多介绍，可能在以后会在其他文章进行介绍。</p><h3 id="1-1-交易"><a href="#1-1-交易" class="headerlink" title="1.1 交易"></a>1.1 交易</h3><p>区块链形象的来说就是一个全球共享的交易数据库，这意味着每个人都可以访问这个数据库并发起更改，这个更改就是 <strong>交易</strong>。</p><p>区块链对交易有单一性保证，也就是当你的交易正在提交到数据库的时候，其他的交易不能影响你的交易。</p><p>同时，区块链对交易有完成保证，意思就是一个交易，要不就 <strong>全部完成</strong>，要不就 <strong>都不完成</strong>。不会出现一方余额变动，而另一方却不变的情况。</p><p>其次，一个交易总是由发起方进行密码学方面的签名(signed)，这也就保证交易的来源方的可信赖性。只有拥有对应的密钥键值对，才能从账户中转钱。</p><h3 id="1-2-区块"><a href="#1-2-区块" class="headerlink" title="1.2 区块"></a>1.2 区块</h3><p>交易数据库都有一个需要处理的基本问题：如果两个交易都想清空一个账户的余额怎么办？这在比特币的术语中叫做 <strong>“doble-spend attack”</strong>，也就是交易之间出现了冲突。</p><p>区块链对此作出的回答是， <strong>你不需要担心这种问题</strong>。<br>区块链会对交易的顺序作出选择，此时，这些交易会被捆绑进一个 <strong>区块</strong> 中，当两个交易出现冲突的时候，排在后面的交易就会被抛弃而不会进入区块中。</p><p>这些区块在时间上呈现出一种线性的形状，因而我们将这些区块所构成的系统，也就是上面的交易数据库称为 <strong>区块链</strong></p><p>而区块链中所应用的交易选择机制，也就是交易的公证机制，我们称其为 <strong>挖矿</strong></p><p>之所以称其为挖矿，原因在于新的包含 <strong>你所承认的交易</strong> 的区块是通过一系列的计算得到的，这个新区块的生成很类似从一堆数据中把金子挖出来的过程。</p><p>区块计算成功后，区块链系统会给予挖矿者奖励，在比特币系统中是赠与比特币，以太币系统则是奖励以太币。</p><p>当然，一个区块也有可能会被退回(reverted)，不过是仅当这个区块位于区块链的头部的时候；当越来越多的区块被加到区块链的头部之后，你所计算出的区块被退回的可能性就会越来越低。</p><h2 id="2-以太坊虚拟机-EVM"><a href="#2-以太坊虚拟机-EVM" class="headerlink" title="2. 以太坊虚拟机(EVM)"></a>2. 以太坊虚拟机(EVM)</h2><p>以太坊虚拟机(Ethereum Virtual Machine) 是以太坊合约(contract)的运行环境，也即 Solidity 的运行环境。</p><p>和普通的虚拟机不同的是，EVM 不是一个沙盒系统，而是 <strong>完全独立的</strong></p><p>运行在 EVM 中的合约不能访问互联网、文件系统或者其他的进程，只能和运行于 EVM 的其他合约进行交互。</p><p>EVM 中有如下概念：</p><h3 id="2-1-账户-Accounts"><a href="#2-1-账户-Accounts" class="headerlink" title="2.1 账户(Accounts)"></a>2.1 账户(Accounts)</h3><p>EVM 中有着两种账户：<br>一种称为外来账户(External owned Accounts)，是使用公私有的键值对控制访问的，也就是真实人类控制的帐号。</p><p>另一种称为合约账户(Contract Accounts)，是含有代码的合约控制的帐号，代码被存储在合约中。</p><p>账户通过地址来进行标识；<br>外部账户的地址通过其 public key 来确定；<br>合约账户的地址是在其被创建的时候确定的，通过它的创建者(即交易的发送者)的地址和从创建者地址发送的交易数量来确定。</p><p>EVM 对于这两种账户都是平等对待的，不管它存不存储着代码。</p><p>每个账户都有着一个持久化的 key-value <code>mapping</code>(类似 <code>HashMap</code>)。<code>key</code> 和 <code>value</code> 分别是 256bit words 和 256bit words。这个 <code>mapping</code> 被称为 <code>storage</code></p><p>同时，每个账户都具有 <strong>以太币</strong> 的余额(balance)，可以通过发送以太币的交易来修改。</p><p>两种账户的对比</p><ul><li>外部账户(External Accounts)<ul><li>具有以太币余额</li><li>可以发送交易(可以发送或者触发合约代码)</li><li>使用键值对来控制</li><li>不储存有代码</li></ul></li></ul><hr><ul><li>合约账户(Contract Accounts)<ul><li>具有以太币余额</li><li>储存有代码</li><li>其代码的执行通过交易或者其他合约发送的信息来触发</li><li>当其代码执行时，可以：<ul><li>执行任意复杂度的操作(图灵完备)</li><li>修改其自身的持久性存储(storage)</li><li>调用其他合约</li></ul></li></ul></li></ul><h3 id="2-2-交易-Transactions"><a href="#2-2-交易-Transactions" class="headerlink" title="2.2 交易(Transactions)"></a>2.2 交易(Transactions)</h3><p>交易是一个账户发给另一个帐号的消息，交易可以包含二进制的数据(称为它的负载)，和以太币</p><p>如果目标账户具有代码，那么这个代码就会被执行，并且交易会提供其负载充当代码的输入数据。</p><p>如果目标账户是 <strong>零账户(zero-account)</strong>(它的账户的地址是 0)，那么，该交易就会创建一个 <strong>新的合约</strong>。上面已经说过，合约的地址是通过发送者的地址来确定的。</p><p>此时，交易的负载就会充当合约的构建参数，此时，EVM 开始执行构造函数，进行合约的构建，其结果即合约的代码，被存入合约账户中。</p><p>也就是说，不需要传入合约本身的代码即可完成合约的构建</p><h3 id="2-3-汽油-Gas"><a href="#2-3-汽油-Gas" class="headerlink" title="2.3 汽油(Gas)"></a>2.3 汽油(Gas)</h3><p>汽油是以太坊用于衡量执行交易的工作量的单位。</p><p>由于发起交易有可能导致合约的执行，代码执行就需要 CS 领域中的时间与空间，即需要矿工的算力来作为支撑。</p><p>为了保证网络中的算力不被大规模消耗和锁死，以太坊中的每一个交易都需要消耗汽油来完成，即交易的 <strong>手续费</strong>。</p><p>之所以称之为 <strong>汽油</strong>，是因为这个“手续费”是需要事先从交易发起者的账户中扣除掉，与该交易绑定，很类似一个汽车加油的过程。</p><p>唯一不同的是，<strong>交易的发起者可以自定义汽油的价格</strong></p><p>也就是说，交易发起者通过事先从账户中扣除一定量的 <strong>以太</strong>，作为充入的汽油；<br>$充入的以太费用 = 汽油量 * 自定义的汽油价格$，汽油量实际上是通过充入的以太费用倒推得到的。</p><p>这也就类似于一个加油的过程。</p><p>然后，矿工开始处理交易，并按照一定的规则 <strong>不断消耗汽油</strong></p><p>当计算完成时，区块被生成，并加入区块链中，矿工得到所消耗的汽油的以太费用作为交易的手续费；<br>同时， <strong>多余的汽油会被退还回交易发起者的账户</strong>。</p><p>但是，如果汽油耗尽，交易还未处理完成的话，那么矿工就会 <strong>回退所有修改</strong>，并将该交易作为 <strong>失败的交易</strong> 加入到区块链中，同时， <strong>收取所有的汽油费用，不退换给发起者。</strong></p><h3 id="2-4-存储-内存和栈"><a href="#2-4-存储-内存和栈" class="headerlink" title="2.4 存储, 内存和栈"></a>2.4 存储, 内存和栈</h3><h4 id="2-4-1-存储-Storage"><a href="#2-4-1-存储-Storage" class="headerlink" title="2.4.1 存储(Storage)"></a>2.4.1 存储(Storage)</h4><p>每一个帐号都会具有一个 256bit -&gt; 256 bit 的键值对，这个键值对被称作 <code>storage</code><br>在合约中进行 <code>storage</code> 的遍历和枚举是不可能的，而且在 <code>storage</code>的读写操作都是相对昂贵的。</p><blockquote><p>即通常用于存储一些持久化的数据，所以称作 <code>storage</code></p></blockquote><p>事实上 <code>storage</code> 的读写是十分昂贵的，它需要 20000 gas 进行一次初始化，需要 5000 gas 来进行数据的修改，同时还需要 200 gas 进行一个 word 的读取。</p><p>为什么需要这么贵呢？是因为存储在 <code>storage</code> 的数据是永久保存在区块链中的，需要真实的存储开销。</p><h4 id="2-4-2-内存-Memory"><a href="#2-4-2-内存-Memory" class="headerlink" title="2.4.2 内存(Memory)"></a>2.4.2 内存(Memory)</h4><p>第二个存储类型是 <code>memory</code>，就像内存一样，<code>memory</code> 仅在合约运行中有效，当合约运行完成时，内存就会被清空重置。</p><p>内存是线性的并被字节编码；<br>对于读取操作来说，只能一次性读取 256bit 的数据，即一个 word;<br>而对于写入操作来说，可以写入 8bit 或者 256bit。</p><p>当你读写超过了一个 word 的时候，内存以 word(256bit) 的级别扩大；<br>当然，随着内存的扩大，就要相应收取 gas 作为费用。<br>需要注意的是，内存每扩大一个数量级，都是平方级别的，所以不要过多使用内存，否则会消耗很多 gas。</p><p>相比 <code>storage</code> 来说，<code>memory</code> 的处理开销就便宜很多。<br>它只需要 3 gas 来读写数据，如果内存扩大了那么就收取一些扩容费用的 gas。</p><p>一般来说，内存就是通常的工作用地，基本的，不需要永久存储的东西都可以放到内存中。</p><h4 id="2-4-3-栈-Stack"><a href="#2-4-3-栈-Stack" class="headerlink" title="2.4.3 栈(Stack)"></a>2.4.3 栈(Stack)</h4><p>EVM 不像传统的计算机是一个以寄存器为主的机器，而是以栈为主的机器，所有的计算都在一个被称作 <code>stack</code> 的空间中进行。</p><p>这个栈具有 1024 个元素的容量，而且包含着一些 word。</p><p>对于栈的访问仅限于前 16 个元素；<br>在前 16 个元素中，你可以将任意一个复制到顶部，或者将任意一个元素和顶部的元素做交换。</p><p>其他的操作则是提取顶部元素(可以不止提取一个)进行计算并将结果压入栈中。</p><p>当然，你也可以将栈中的元素移到内存和存储中，不过对于比前 16 个更深一点的元素就不能访问到了，除非你将前 16 个元素移除。</p><p>通常，这个栈中的元素不会使用到，就像函数栈一样由编译器或者解释器来操作。</p><h3 id="2-5-指令集"><a href="#2-5-指令集" class="headerlink" title="2.5 指令集"></a>2.5 指令集</h3><p>EVM 的指令集比较简短，所有的指令都是对基本数据类型和 256bit 的字的操作，包含了一般的算术运算、位运算、逻辑运算和比较运算等，同时还可以进行条件跳转和非条件跳转。</p><p>同时，合约还可以访问它所在区块的一些信息比如说区块的编号和区块的时间戳。</p><h3 id="2-6-信息调用-Message-Calls"><a href="#2-6-信息调用-Message-Calls" class="headerlink" title="2.6 信息调用(Message Calls)"></a>2.6 信息调用(Message Calls)</h3><p>合约可以通过 <strong>信息调用</strong> 来调用其他的合约或者给一个非合约账户发送以太币。</p><p>信息调用和交易类似，都具备一个发送者，目标者，数据负载，以太币，汽油和返回的数据。</p><p>事实上，每一个交易都是由 top-level 的信息调用组成的，top-level 的信息调用可以创建其他信息调用。</p><p>合约可以决定通过信息调用所传递的 gas 数量，如果一个 out-of-gas exception 发生的话，调用栈中就会压入一个 error value 来标识异常的发生。</p><p>此时，只有通过该调用传送的 gas 会被消耗掉。同时，发起信息调用的合约会手动引起一个异常，以保证异常栈的呈现。</p><p>上面也说过，被调用的合约会收到一个新鲜的 <code>memory</code> 实例，并可以访问随调用传来的数据负载；</p><p>此时，系统会提供一个额外的空间用于存储这种数据负载，叫做 <code>calldata</code></p><p>当合约代码执行完毕后，它可以将数据返回，而返回的数据会存储在调用者的内存中。</p><p>调用的深度被限制在 <strong>1024</strong>，所以对于一些比较复杂的操作，使用循环会比使用递归要好。</p><h3 id="2-7-委托调用-Delegatecall-调用代码-Callcode-和库"><a href="#2-7-委托调用-Delegatecall-调用代码-Callcode-和库" class="headerlink" title="2.7 委托调用(Delegatecall)/调用代码(Callcode)和库"></a>2.7 委托调用(Delegatecall)/调用代码(Callcode)和库</h3><p>委托调用是一种特别的信息调用，它可以将调用者的上下文暴露给被调用者。</p><p>下面举一个简单的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">contract D &#123;</div><div class="line">    unit public n;</div><div class="line">    address public sender;</div><div class="line"></div><div class="line">    function delegatecallSetN(address _e, unit _n) &#123;</div><div class="line">        _e.delegatecall(byte4(sha3(&quot;setN(unit256)&quot;)), _n)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">contract E &#123;</div><div class="line">    unit public n;</div><div class="line">    address public sender;</div><div class="line">    funciton setN(unit _n) &#123;</div><div class="line">        n = _n;</div><div class="line">        sender = msg.sender;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当一个合约 <code>C</code> 调用 <code>D</code> 的方法时，是 <code>D</code> 的 <code>sender</code> 被设置成了 <code>C</code> ，而不是 <code>E</code> 的方法被设置。</p><p>这就是 delegatecall 和普通调用的区别，它相当于将其他合约的函数引入到了当前合约的作用域中。</p><p>引入这种调用之后，我们就可以在合约中动态调用函数，这也为我们实现 Solidity 的函数库提供了途径。</p><p>不过需要提醒的是，这个 <code>delegatecall</code> 方法是相当低级的方法， <strong>如果不做深入开发可以不管它</strong></p><h3 id="2-8-日志"><a href="#2-8-日志" class="headerlink" title="2.8 日志"></a>2.8 日志</h3><p>EVM 也提供从底层直至区块层级的日志功能，用这些功能来实现 <strong>事件系统</strong></p><p>但是，合约在它被创建之后就不能访问日志数据，不过日志数据可以从区块链的外部被访问。</p><p>一些日志数据被存储在布隆过滤器(bloom filter)中，所以一些轻量级的客户端也可以访问部分的区块链日志。</p><h3 id="2-9-合约创建"><a href="#2-9-合约创建" class="headerlink" title="2.9 合约创建"></a>2.9 合约创建</h3><p>合约除了通过信息调用来创建以外，还可以通过一个特别的指令来创建。</p><p>指令创建和普通的信息调用创建的区别在于，在指令创建完毕之后，创建者可以获取到新合约的地址。</p><h3 id="2-10-自毁"><a href="#2-10-自毁" class="headerlink" title="2.10 自毁"></a>2.10 自毁</h3><p>想要去除区块链中的代码的唯一途径就是通过合约的自毁。</p><p>当合约调用析构指令(<code>selfdestruct</code>) 时，合约账户中剩余的以太币会被发往制定的目标，然后，合约的 <code>storage</code> 和代码就会从区块链中删除。</p><blockquote><p>即使合约代码中不包含 <code>selfdestruct</code> 指令，它也可以通过调用 <code>delegatecall</code> 或者 <code>callcode</code> 指令来执行</p><p>以太坊客户端似乎还未实现旧合约和旧代码的删除功能。存储节点可以自行选择是否删除合约。</p><p>当期，外部账户是无法被删除的。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Solidity 是运行于以太坊(Ethereum) 区块链上的智能合约语言，它是图灵完备的，意味着可以用它写一些任意复杂度的程序并运行于区块链中。&lt;/p&gt;
    
    </summary>
    
      <category term="Solidity" scheme="https://wafer.li/categories/Solidity/"/>
    
    
      <category term="Solidity" scheme="https://wafer.li/tags/Solidity/"/>
    
      <category term="Ethereum" scheme="https://wafer.li/tags/Ethereum/"/>
    
  </entry>
  
  <entry>
    <title>近月少女的礼仪 2.1 感想</title>
    <link href="https://wafer.li/Talk/%E8%BF%91%E6%9C%88%E5%B0%91%E5%A5%B3%E7%9A%84%E7%A4%BC%E4%BB%AA%202.1%20%E6%84%9F%E6%83%B3/"/>
    <id>https://wafer.li/Talk/近月少女的礼仪 2.1 感想/</id>
    <published>2017-06-03T17:22:00.000Z</published>
    <updated>2017-06-03T18:30:11.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>最近这部 FD 发售之后就忍不住玩了一下；</p><p>会结合本篇《近月少女的礼仪 2》(月に寄りそう乙女の作法２)　来谈一谈感想；</p><p>内有剧透，慎点</p><a id="more"></a><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>此次发售的 FD 主要包含两条线路：艾斯特线和春心线，不过春心线是打酱油的，就没玩。</p><p>同时收录了前传《近月少女的礼仪0》，讲述大藏衣远学生时代的故事。</p><h2 id="2-内容和感想"><a href="#2-内容和感想" class="headerlink" title="2. 内容和感想"></a>2. 内容和感想</h2><p>艾斯特是本篇的女主角，在此 FD 中是着重描写的对象；</p><p>在取得菲丽展最优秀奖之后，两人回老家拜访父母（这基本属于固定流程了），随后回到学院展开第二年的学习生活的事。</p><p>对于本篇的评价中，多有『矛盾冲突不足』的批评；</p><p>相比前作《近月少女的礼仪 1》中暗流涌动的家族纷争，《近月 2》因为主角生长在优渥的环境中，因而在设定背景中缺失了磨炼的土壤，虽有才能，但是远远不及其父母闪耀。</p><p>在 FD 中此问题进一步暴露，由于取得了最优秀奖，班上的设计天才贾斯子开始认真对待设计的作业和考试，因而我们的主角小两口接连落败。</p><p>于是他们终于发现（实际上在本篇结尾也有体现），自己的才能只不过是人家的一个小指头；</p><p>于是一个问题就出现了， <strong>自己无论如何努力，都比不过天才</strong>；</p><p>小两口对此询问了很多的人，包括在公寓的邻居们，还直接向自己的父母求助；</p><p>不过露娜的回复真的比较令人伤心：</p><blockquote><p>「自己从来没有在才能上碰过壁，请随便努力一下吧」</p></blockquote><p>说实话，玩到这里的时候我是比较揪心的，明明自己也拥有耀眼的才能，但是，却只能这样任由其被更耀眼的光芒掩盖吗？</p><p>不过，幸好我们现在是主角小两口，经过和现任校长商量之后（顺便把校长洗白了），决定组成设计师组合『eS』一同向天才挑战！</p><p>不过，既然组成了设计师组合，那么提交设计的时候，就必须放弃一人，另外一人要尽力对设计图做出点检和修正。</p><p>于是很顺理成章的就过渡到是否要放弃自己的恋人身份，以女仆的身份来面对自己的主人兼恋人。</p><p>这个选项可以说是整个近月系列中最为重要和必有的选项</p><blockquote><p>为什么是『必有』？因为这是个伪娘游戏啊！</p></blockquote><p>但是，这个选项第一次承担了 END 分支的作用，而不只是单纯的 CG 回收。</p><p>如果选择了恋人，那么最后，就因为小两口要决出胜负，而双双输给天才贾斯子；</p><blockquote><p>不过即使输给了天才，小两口还是双双获得了二等奖，还是没有决出胜负（笑）</p></blockquote><p>如果选择了女仆，那么因为艾斯特的设计得到了完善，那么就能够战胜贾斯子。</p><p>这里是最让我惊艳的，<strong>如果你不选择被 gang，那么就达不成完美结局。</strong>（看起来官方也很懂玩家的心嘛）</p><p>也许在经过这一次的经历后，我们的才华大少爷才理解并践行了父亲一直以来对他的忠告：「能为谁派上用场是很了不起的事」</p><p>原本由于露娜的原因，我第一次选的时候仍然想让他去和自己的恋人竞争；</p><p>毕竟是樱小路露娜的儿子啊，怎么会输给他人，肯定是心性还不够成熟。</p><p>不过玩到最后，果然我们的主角还是「朝日的女儿」啊（笑）。</p><h2 id="3-亮点"><a href="#3-亮点" class="headerlink" title="3. 亮点"></a>3. 亮点</h2><ol><li><p>贾斯子和梅宫的百合剧</p><blockquote><p>《梅宫理论及其周边》（笑）</p></blockquote></li><li><p>才华的泳装</p><blockquote><p>我们的才华大小姐越来越漂亮了</p></blockquote></li><li><p>才华走 T 台的衣服</p><blockquote><p>真的好像他妈，差点认错了</p></blockquote></li><li><p>艾斯特的姐姐</p><blockquote><p>走 T 台和妹妹抢就算了，还要和妹妹抢男朋友……</p></blockquote></li></ol><h2 id="4-缺憾"><a href="#4-缺憾" class="headerlink" title="4. 缺憾"></a>4. 缺憾</h2><p>最大的缺憾当然还是前作主要人物露娜和游星 <strong>没有登场</strong></p><p>估计官方还想再捞一笔，毕竟有很多人都期待这两个前作的最主要人物登场；</p><p>毕竟父亲（朝日娘）看到自己儿子女装侍奉另一个主人，想起来就十分有趣！</p><h2 id="5-和一代的比较"><a href="#5-和一代的比较" class="headerlink" title="5. 和一代的比较"></a>5. 和一代的比较</h2><p>当然，整体剧情的矛盾和跌宕比不上一代是公认的；</p><p>不过，《近月 2》仍不失为一部十分优秀的作品，其中，我们的大少爷（小姐）的复杂性格和追求成功的方式可能更为现实，而不像露娜一样过于虚幻。</p><p>虽说如此，如果要做 《近月 3》的话，剧情安排上势必要起波澜（比如说大藏前家主身亡，衣远独力难支，家族重新陷入动荡和纷争），否则 3 只能是当做炒冷饭作品而已，这样只会砸烂近月的金字招牌。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近这部 FD 发售之后就忍不住玩了一下；&lt;/p&gt;&lt;p&gt;会结合本篇《近月少女的礼仪 2》(月に寄りそう乙女の作法２)　来谈一谈感想；&lt;/p&gt;&lt;p&gt;内有剧透，慎点&lt;/p&gt;
    
    </summary>
    
      <category term="杂谈" scheme="https://wafer.li/categories/Talk/"/>
    
    
      <category term="杂谈" scheme="https://wafer.li/tags/Talk/"/>
    
      <category term="Galgame" scheme="https://wafer.li/tags/Galgame/"/>
    
      <category term="月に寄りそう乙女の作法" scheme="https://wafer.li/tags/%E6%9C%88%E3%81%AB%E5%AF%84%E3%82%8A%E3%81%9D%E3%81%86%E4%B9%99%E5%A5%B3%E3%81%AE%E4%BD%9C%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>再谈单例模式</title>
    <link href="https://wafer.li/DesignPattern/%E5%86%8D%E8%B0%88%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://wafer.li/DesignPattern/再谈单例模式/</id>
    <published>2017-05-25T02:58:00.000Z</published>
    <updated>2017-05-26T17:55:32.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>之前提到枚举实现是单例的最佳实现，这毋庸置疑；</p><p>不过，对比枚举和静态内部类，好像它们的区别就在于防止了反射攻击；</p><p>那么，都『攻击』了，为啥偏偏没事去改你的单例呢？直接获取更有意思的信息不是更好吗？</p><a id="more"></a><h2 id="1-『反射攻击』不是攻击"><a href="#1-『反射攻击』不是攻击" class="headerlink" title="1. 『反射攻击』不是攻击"></a>1. 『反射攻击』不是攻击</h2><p>这里所提到的『反射攻击』的概念，实际上并不是信息安全领域的 『攻击』 的概念；</p><p>而是， <strong>通过反射的合理利用，可以令单例失效</strong>；</p><p>那么在日常开发中，最常遇到的反射攻击就是 <strong>对象的序列化</strong>。</p><p>当单例需要实现序列化的时候，反序列化过程实际上就是使用 <strong>反射</strong> 来生成了新的实例。</p><p>那么在序列化和反序列化的过程中，单例模式就被破坏掉了。</p><p>这时，有人提出可以利用 <code>readResolve()</code> 方法来防止这种事情的发生；</p><p>而实际上， <strong>单纯利用</strong> <code>readResolve()</code> 也并不能防止单例被破坏；</p><p>《Effective Java 第二版》在 77 条提出：</p><blockquote><p><strong>如果依赖 <code>readResolve()</code> 方法来进行实例控制，带有对象引用类型的所有实例域都必须声明为 <code>transient</code> 的。</strong></p><p>否则，那种破釜沉舟式的攻击者，就有可能在 <code>readResolve()</code> 方法运行之前，保护指向反序列化对象的引用。</p></blockquote><p>此时，枚举类型就派上用场了，枚举为了防止这种事情的发生，单独实现了一套序列化和反序列化的机制；</p><p>大体就是利用 <code>valueOf()</code> 来进行反序列化，而不是使用普通的序列化机制；</p><p>同时，也禁止声明 <code>readResolve()</code> 和 <code>readObject()</code> 这类方法。</p><h2 id="2-Kotlin-单例是懒加载的"><a href="#2-Kotlin-单例是懒加载的" class="headerlink" title="2. Kotlin 单例是懒加载的"></a>2. Kotlin 单例是懒加载的</h2><p>下面是 Kotlin 单例的反编译 Java 代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Test INSTANCE;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</div><div class="line">      INSTANCE = (Test)<span class="keyword">this</span>;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="keyword">static</span> &#123;</div><div class="line">      <span class="keyword">new</span> Test();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>虽然它和所谓的饿汉式 Java 单例很类似，但是在实际使用中，它是 <strong>懒加载</strong> 的。</p><p>为什么呢？</p><p>原因就在于 JVM 类的加载时机；</p><p>JVM Specification 中在 <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html#jvms-5.4.2" target="_blank" rel="noopener">准备阶段</a> 中提出：</p><blockquote><p>explicit initializers for static fields are executed as part of initialization (§5.5), not preparation.</p></blockquote><p>所以，上面的 <code>INSTANCE</code> 的实例化，即 <code>static</code> 块是在类加载的 <strong>初始化阶段</strong> 进行的；</p><p>而对于初始化阶段，JVM Specification 强制规定了有且仅有 <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html#jvms-5.5" target="_blank" rel="noopener">5 种情况</a> 可以触发初始化阶段；</p><p>而这 5 种情况，都是你真正使用到类的实例的时候才会出现的；</p><p>根据这 5 种情况，再结合 Kotlin <code>object</code> 的单例语法和使用，可以得出有且仅有 2 种情况会导致 <code>object</code> 单例提前进行初始化：</p><ol><li>反射</li><li>调用类中其他的静态变量</li></ol><p>对于反射，一个很典型的应用场景就是使用 classpath scanner 进行注解扫描；</p><p>不过，JB 的工程师提出，classpath scanner 并不需要反射来实现注解扫描<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="https://discuss.kotlinlang.org/t/kotlin-singleton-implementation/2853/6?u=omysho">[1]</span></a></sup>；</p><p>于是我随便找了一个 classpath scanner: <a href="https://github.com/lukehutch/fast-classpath-scanner" target="_blank" rel="noopener">fast-classpath-scanner</a>；</p><p>经过使用之后，发现即使打印出了单例的信息，但是 JVM 只加载了 <code>main</code> 方法的类，而并没有加载单例。</p><p>相关的结果在 <a href="https://gist.github.com/wafer-li/1931170fd79c0ec1567f5737454f61ab" target="_blank" rel="noopener">这个 gist</a> 中。</p><blockquote><p>单例的名字叫 <code>Test</code>，而 <code>main()</code> 方法类的名字叫 <code>SingletonTest</code></p></blockquote><p>对于第二种情况，在 Kotlin 中是不存在的。为什么呢？</p><p>因为对于 Kotlin <code>object</code> 中，声明值的方法只有 <code>var</code> <code>val</code> 和 <code>const val</code> 三种；</p><p>对于前两种，虽然反编译出来的代码指明这样的确定义了两个静态的值；</p><p><code>var</code> 的情况：</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1ffzakmwghkj30rc0uotax.jpg" alt=""></p><p><code>val</code> 的情况：</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1ffzalhmszqj30rs0ty40u.jpg" alt=""></p><p>但是，当你使用的时候，却是通过 <code>INSTANCE</code> 来引用的。</p><p>这样无论如何都会导致单例的实例化。</p><p>而使用 <code>const val</code> 的确得到了一个 <code>public static</code> 的值；</p><p>但是，当你使用的时候，编译器会自动替换为 <strong>字面量</strong>，不会导致单例加载；</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1ffzamh0h4pj30tc0q276e.jpg" alt=""></p><p>所以，综上所述，Kotlin 中 <code>object</code> 单例是懒加载的。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none;padding-left:0;margin-left:40px"><li id="fn:1"><span style="display:inline-block;vertical-align:top;padding-right:10px;margin-left:-40px">1.</span><span style="display:inline-block;vertical-align:top;margin-left:10px">https://discuss.kotlinlang.org/t/kotlin-singleton-implementation/2853/6?u=omysho<a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前提到枚举实现是单例的最佳实现，这毋庸置疑；&lt;/p&gt;&lt;p&gt;不过，对比枚举和静态内部类，好像它们的区别就在于防止了反射攻击；&lt;/p&gt;&lt;p&gt;那么，都『攻击』了，为啥偏偏没事去改你的单例呢？直接获取更有意思的信息不是更好吗？&lt;/p&gt;
    
    </summary>
    
      <category term="DesignPattern" scheme="https://wafer.li/categories/DesignPattern/"/>
    
    
      <category term="DesignPattern" scheme="https://wafer.li/tags/DesignPattern/"/>
    
  </entry>
  
  <entry>
    <title>Retrofit2 + Rxjava2</title>
    <link href="https://wafer.li/Android/Retrofit/Retrofit2%20+%20Rxjava2/"/>
    <id>https://wafer.li/Android/Retrofit/Retrofit2 + Rxjava2/</id>
    <published>2017-05-01T20:49:00.000Z</published>
    <updated>2017-05-01T23:25:44.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Retrofit 和 Rxjava 结合应该算得上是 Rxjava 在 Android 应用得最广泛的一个方面了。</p><p>这里就来讲讲关于这两个库具体组合的用法。</p><a id="more"></a><h2 id="1-添加依赖"><a href="#1-添加依赖" class="headerlink" title="1. 添加依赖"></a>1. 添加依赖</h2><p>具体需要添加的依赖库有： <code>Retrofit2</code>、<code>Rxjava2</code>、<code>RxAndroid2</code>、<code>Gson</code> 、<code>Rtrofit2</code> 到 <code>Rxjava2</code> 的转换器、<code>Retrofit2</code> 到 <code>Gson</code> 的转换器</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Retrofit</span></div><div class="line">compile <span class="string">'com.squareup.retrofit2:retrofit:2.2.0'</span></div><div class="line">compile <span class="string">group:</span> <span class="string">'com.squareup.retrofit2'</span>, <span class="string">name:</span> <span class="string">'converter-gson'</span>, <span class="string">version:</span> <span class="string">'2.2.0'</span></div><div class="line">compile <span class="string">group:</span> <span class="string">'com.squareup.retrofit2'</span>, <span class="string">name:</span> <span class="string">'adapter-rxjava2'</span>, <span class="string">version:</span> <span class="string">'2.2.0'</span></div><div class="line"></div><div class="line"><span class="comment">// Rx*</span></div><div class="line">compile <span class="string">'io.reactivex.rxjava2:rxjava:2.1.0'</span></div><div class="line">compile <span class="string">'io.reactivex.rxjava2:rxandroid:2.0.1'</span></div><div class="line">compile <span class="string">'io.reactivex.rxjava2:rxkotlin:2.0.1-RC1'</span></div></pre></td></tr></table></figure><p>其中，<code>Gson</code> 是 JSON 解析库，也可以使用 <code>Jackson</code> 替代；</p><p>上面的 <code>rxkotlin</code> 是 <code>Rxjava</code> 的 <code>Kotlin</code> 轻量支持库；</p><p>如果不使用 Kotlin 可以无视。</p><h2 id="2-构建-API"><a href="#2-构建-API" class="headerlink" title="2. 构建 API"></a>2. 构建 API</h2><p>使用 <code>Retrofit</code> 的第一步当然就是构建 API 接口；</p><p>不过既然我们使用的是 Rxjava2，那么，这个 API 接口当然就稍微有点不一样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TrendingApi</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@GET(<span class="meta-string">"&#123;language&#125;"</span>)</span></div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getTrending</span><span class="params">(<span class="meta">@Path(<span class="meta-string">"language"</span>)</span> language: <span class="type">String</span> = <span class="string">"."</span>, <span class="meta">@Query(<span class="meta-string">"since"</span>)</span> since: <span class="type">String</span>)</span></span></div><div class="line">            : Observable&lt;ResponseBody&gt;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看到，我们 API 返回的是一个 <code>Observable&lt;T&gt;</code> 对象，而非通常的 <code>Call&lt;T&gt;</code> 对象。</p><p>对于这个 <code>Observable</code>，假设我们的 Body 对象为 <code>T</code>，那么 <code>Observable</code> 一共有以下的几种可能情况：</p><ul><li><code>Observable&lt;T&gt;</code></li><li><code>Observable&lt;Response&lt;T&gt;&gt;</code></li><li><code>Observable&lt;Result&lt;T&gt;&gt;</code></li></ul><p>前两个自然不用说，第三个 <code>Result</code> 是 <code>Response&lt;T&gt;</code> 和 <code>Throwable</code> 的包装对象；</p><p>也就是说，如果使用 <code>Result</code> 的话，我们可以在 <code>onNext()</code> 中同时处理正常情况和异常情况。</p><blockquote><p>所谓的异常情况指的是抛出了 Exception</p></blockquote><h2 id="3-三种-Observable-的区别"><a href="#3-三种-Observable-的区别" class="headerlink" title="3. 三种 Observable 的区别"></a>3. 三种 <code>Observable</code> 的区别</h2><p>那么这三种 <code>Observable</code> 究竟有什么区别呢？</p><p>我们来看看具体 <code>adapter-rxjava2</code> 的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Observable&lt;Response&lt;R&gt;&gt; responseObservable = isAsync</div><div class="line">      ? <span class="keyword">new</span> CallEnqueueObservable&lt;&gt;(call)</div><div class="line">      : <span class="keyword">new</span> CallExecuteObservable&lt;&gt;(call);</div><div class="line"></div><div class="line">  Observable&lt;?&gt; observable;</div><div class="line">  <span class="keyword">if</span> (isResult) &#123;</div><div class="line">    observable = <span class="keyword">new</span> ResultObservable&lt;&gt;(responseObservable);</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isBody) &#123;</div><div class="line">    observable = <span class="keyword">new</span> BodyObservable&lt;&gt;(responseObservable);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    observable = responseObservable;</div><div class="line">  &#125;</div></pre></td></tr></table></figure><p>从这段代码可以看到，默认的情况就是 <code>Observable&lt;Response&lt;T&gt;&gt;</code>；</p><p>而这个默认的 <code>Observable</code> 是通过执行 <code>CallEnqueueObservable</code> 或者 <code>CallExecuteObservable</code> 得到的。</p><p>然后再通过判断 <code>Observable</code> 的包装状态，对上面得到的 <code>Observable&lt;Response&lt;T&gt;&gt;</code> 进行转换。</p><h3 id="3-1-Observable-lt-T-gt"><a href="#3-1-Observable-lt-T-gt" class="headerlink" title="3.1 Observable&lt;T&gt;"></a>3.1 <code>Observable&lt;T&gt;</code></h3><p>首先来看我们的 <code>BodyObservable</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</div><div class="line">  upstream.subscribe(<span class="keyword">new</span> BodyObserver&lt;T&gt;(observer));</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看到，在 <code>subscribeActual()</code> 中，对我们传入的 <code>observer</code> 封装了一层外壳 <code>BodyObserver</code>；</p><p>然后将其传入上层的 <code>subscribe</code> 中，以启动网络请求。</p><p>这层外壳正是这个 <code>Adapter</code> 的关键所在，通过使用另一个对象，来处理不同的网络情况，然后再委派到我们真正传入的 <code>observer</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BodyObserver</span>&lt;<span class="title">R</span>&gt; <span class="keyword">implements</span> <span class="title">Observer</span>&lt;<span class="title">Response</span>&lt;<span class="title">R</span>&gt;&gt; </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> R&gt; observer;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> terminated;</div><div class="line"></div><div class="line">  BodyObserver(Observer&lt;? <span class="keyword">super</span> R&gt; observer) &#123;</div><div class="line">    <span class="keyword">this</span>.observer = observer;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable disposable)</span> </span>&#123;</div><div class="line">    observer.onSubscribe(disposable);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Response&lt;R&gt; response)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (response.isSuccessful()) &#123;</div><div class="line">      observer.onNext(response.body());</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      terminated = <span class="keyword">true</span>;</div><div class="line">      Throwable t = <span class="keyword">new</span> HttpException(response);</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        observer.onError(t);</div><div class="line">      &#125; <span class="keyword">catch</span> (Throwable inner) &#123;</div><div class="line">        Exceptions.throwIfFatal(inner);</div><div class="line">        RxJavaPlugins.onError(<span class="keyword">new</span> CompositeException(t, inner));</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!terminated) &#123;</div><div class="line">      observer.onComplete();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable throwable)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!terminated) &#123;</div><div class="line">      observer.onError(throwable);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// This should never happen! onNext handles and forwards errors automatically.</span></div><div class="line">      Throwable broken = <span class="keyword">new</span> AssertionError(</div><div class="line">          <span class="string">"This should never happen! Report as a bug with the full stacktrace."</span>);</div><div class="line">      <span class="comment">//noinspection UnnecessaryInitCause Two-arg AssertionError constructor is 1.7+ only.</span></div><div class="line">      broken.initCause(throwable);</div><div class="line">      RxJavaPlugins.onError(broken);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看到，其实这层壳处理的并不是我们的 <code>Body</code> 对象，而是之前使用 <code>Call</code> 调用时返回的 <code>Response</code> 对象。</p><p>我们重点来看看 <code>onNext()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Response&lt;R&gt; response)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (response.isSuccessful()) &#123;</div><div class="line">    observer.onNext(response.body());</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    terminated = <span class="keyword">true</span>;</div><div class="line">    Throwable t = <span class="keyword">new</span> HttpException(response);</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      observer.onError(t);</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable inner) &#123;</div><div class="line">      Exceptions.throwIfFatal(inner);</div><div class="line">      RxJavaPlugins.onError(<span class="keyword">new</span> CompositeException(t, inner));</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看到，当成功访问并响应的时候(2xx)，结果返回给了我们的 <code>onNext()</code> ；</p><p>而当成功访问但不成功响应的时候(4xx/5xx)，返回的结果通过 <code>HttpException</code> 的包装，然后返回给了我们的 <code>onError()</code> 方法。</p><p>而当这个壳子中出现 <code>onError()</code> 时，意味着可能出现了断网的情况，或者其他异常；</p><p>此时也是通过 <code>onError()</code> 返回到我们的观察者中。</p><p>结论：</p><ul><li>2xx 结果通过 <code>onNext()</code> 返回</li><li>4xx/5xx 结果通过 <code>onError()</code> 返回</li><li>断网和其他异常情况也通过 <code>onError()</code> 返回</li></ul><h3 id="3-2-Observable-lt-Result-lt-T-gt-gt"><a href="#3-2-Observable-lt-Result-lt-T-gt-gt" class="headerlink" title="3.2 Observable&lt;Result&lt;T&gt;&gt;"></a>3.2 <code>Observable&lt;Result&lt;T&gt;&gt;</code></h3><p><code>Result</code> 是 <code>adapter-rxjava2</code> 新增的包装类，包装了 <code>error</code> 和 <code>response</code> ；</p><p>关于它具体如何工作的，我们来看看它的源码：</p><p>首先是 <code>Result</code> 类，下面的是 <code>ResultObservable</code> 使用到的静态工厂方法和 <code>Result</code> 的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Result&lt;T&gt; <span class="title">error</span><span class="params">(Throwable error)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (error == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"error == null"</span>);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Result&lt;&gt;(<span class="keyword">null</span>, error);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Result&lt;T&gt; <span class="title">response</span><span class="params">(Response&lt;T&gt; response)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (response == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"response == null"</span>);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Result&lt;&gt;(response, <span class="keyword">null</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Response&lt;T&gt; response;</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Throwable error;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">Result</span><span class="params">(Response&lt;T&gt; response, Throwable error)</span> </span>&#123;</div><div class="line">  <span class="keyword">this</span>.response = response;</div><div class="line">  <span class="keyword">this</span>.error = error;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看到，<code>error</code> 和 <code>response</code> 是不共戴天的关系，符合 <code>Retrofit</code> 的设计。</p><p>下面我们来看看具体的 <code>ResultObservable</code> 的包装类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultObserver</span>&lt;<span class="title">R</span>&gt; <span class="keyword">implements</span> <span class="title">Observer</span>&lt;<span class="title">Response</span>&lt;<span class="title">R</span>&gt;&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> Result&lt;R&gt;&gt; observer;</div><div class="line"></div><div class="line">    ResultObserver(Observer&lt;? <span class="keyword">super</span> Result&lt;R&gt;&gt; observer) &#123;</div><div class="line">      <span class="keyword">this</span>.observer = observer;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable disposable)</span> </span>&#123;</div><div class="line">      observer.onSubscribe(disposable);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Response&lt;R&gt; response)</span> </span>&#123;</div><div class="line">      observer.onNext(Result.response(response));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable throwable)</span> </span>&#123;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        observer.onNext(Result.&lt;R&gt;error(throwable));</div><div class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">          observer.onError(t);</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable inner) &#123;</div><div class="line">          Exceptions.throwIfFatal(inner);</div><div class="line">          RxJavaPlugins.onError(<span class="keyword">new</span> CompositeException(t, inner));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line">      observer.onComplete();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</div><div class="line">      observer.onComplete();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看到，这回，重点在 <code>onError</code> 方法；</p><p>通过重载 <code>onError</code> 并使用 <code>Result</code> 的静态工厂；</p><p>让我们的 <code>observer</code> 也能通过 <code>onNext</code> 获取到具体的 <code>Throwable</code>；</p><p>也就是说，我们可以在 <code>onNext()</code> 处理网络错误。</p><p>而当更严重的错误发生时，<code>onError()</code> 才会被调用</p><p>结论：</p><p>网络异常和正常的网络内容都通过 <code>onNext()</code> 进行处理。</p><h3 id="3-3-Observable-lt-Response-lt-T-gt-gt-的获取"><a href="#3-3-Observable-lt-Response-lt-T-gt-gt-的获取" class="headerlink" title="3.3 Observable&lt;Response&lt;T&gt;&gt; 的获取"></a>3.3 <code>Observable&lt;Response&lt;T&gt;&gt;</code> 的获取</h3><p>那么作为关键的 <code>Observable&lt;Response&lt;T&gt;&gt;</code> 对象是从哪里获取的呢？</p><p>让我们将目光转向在开头的两个 <code>Call</code> 开头的 <code>Observable</code>；</p><p>很容易知道，一个对应了 <code>Retrofit</code> 的 <code>call.execute()</code>；</p><p>而另外一个对应了 <code>call.enqueue()</code></p><p>为了简便，我们只看 <code>execute()</code> 部分的源码：</p><p>下面就是关键的 <code>subscribeActual</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> Response&lt;T&gt;&gt; observer)</span> </span>&#123;</div><div class="line">  <span class="comment">// Since Call is a one-shot type, clone it for each new observer.</span></div><div class="line">  Call&lt;T&gt; call = originalCall.clone();</div><div class="line">  observer.onSubscribe(<span class="keyword">new</span> CallDisposable(call));</div><div class="line"></div><div class="line">  <span class="keyword">boolean</span> terminated = <span class="keyword">false</span>;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    Response&lt;T&gt; response = call.execute();</div><div class="line">    <span class="keyword">if</span> (!call.isCanceled()) &#123;</div><div class="line">      observer.onNext(response);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!call.isCanceled()) &#123;</div><div class="line">      terminated = <span class="keyword">true</span>;</div><div class="line">      observer.onComplete();</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">    Exceptions.throwIfFatal(t);</div><div class="line">    <span class="keyword">if</span> (terminated) &#123;</div><div class="line">      RxJavaPlugins.onError(t);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!call.isCanceled()) &#123;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        observer.onError(t);</div><div class="line">      &#125; <span class="keyword">catch</span> (Throwable inner) &#123;</div><div class="line">        Exceptions.throwIfFatal(inner);</div><div class="line">        RxJavaPlugins.onError(<span class="keyword">new</span> CompositeException(t, inner));</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看到，通过调用 <code>call.execute()</code> 获取 <code>Response</code> 对象；</p><p>然后将获取到的 <code>Response</code> 对象进行传递，就实现了一个 <code>Observable</code> 的功能。</p><h3 id="3-4-原理和结论"><a href="#3-4-原理和结论" class="headerlink" title="3.4 原理和结论"></a>3.4 原理和结论</h3><p>通过以上的源码解读，我们得出了 <code>adapter-rxjava2</code> 的具体原理：</p><p>首先通过 <code>CallExecuteObservable</code> 获取到 <code>Observable&lt;Response&lt;T&gt;&gt;</code> 对象；</p><p>然后根据不同的 <code>Observable</code> 类型对这个对象进行变换，最后传出，得到了我们需要的 <code>Observable</code>；</p><p>在调用 <code>Observable.subscribe(observer)</code> 时；</p><p>首先是最外层的 <code>subscribeActual()</code> 被调用；</p><p>然后被层层传递，直到 <code>CallExecuteObservable</code> 的 <code>subscribeActual()</code> 调用 <code>call.execute()</code>；</p><p>然后将 <code>Response</code> 向下进行层层传递，完成了整个订阅流程。</p><p>结论：</p><ol><li><p>只有最后 <code>subscribe()</code> 调用，才会触发网络请求</p><blockquote><p>在此之前可以先保留 <code>Observable</code> 对象；<br>直到需要的时候再进行调用</p></blockquote></li><li><p><code>Observable&lt;T&gt;</code> 的 2xx 结果在 <code>onNext()</code> 调用，4xx/5xx 结果在 <code>onError()</code> 调用</p></li><li><p><code>Observable&lt;Result&lt;T&gt;&gt;</code> 的 <code>error</code> 和 <code>response</code> 都在 <code>onNext()</code> 调用</p></li></ol><h2 id="4-创建-Retrofit-实例"><a href="#4-创建-Retrofit-实例" class="headerlink" title="4. 创建 Retrofit 实例"></a>4. 创建 <code>Retrofit</code> 实例</h2><p>当我们的 API 创建好之后，我们就可以开始创建 <code>Retrofit</code> 实例；</p><p>为了能够使用 Rxjava，必须给 <code>Retrofit</code> 加上 <code>CallAdapterFactory</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">val</span> retrofitBuilder: Retrofit.Builder =</div><div class="line">         Retrofit.Builder()</div><div class="line">                 .baseUrl(BASE_URL)</div><div class="line">                 .addCallAdapterFactory(RxJava2CallAdapterFactory.create())</div><div class="line">                 .addConverterFactory(GsonConverterFactory.create(gson))</div></pre></td></tr></table></figure><p>这里来说一下有关 <code>RxJava2CallAdapterFactory</code> 的几个 <code>create()</code> 的区别；</p><p>这个工厂一共有三个静态构造方法：</p><ul><li><code>create()</code></li><li><code>createAsync()</code></li><li><code>createScheduler(scheduler)</code></li></ul><p>第一个是产生一个同步的 <code>Adapter</code>，相当于调用 <code>call.execute()</code>；</p><p>同时，也不对 <code>call.execute()</code> 的线程进行提前控制。</p><p>第二个是产生一个异步的 <code>Adapter</code>，相当于调用 <code>call.enqueue()</code>；</p><blockquote><p><strong>此时，<code>Observable</code> 的 <code>subscribeOn()</code> 方法失效</strong></p></blockquote><p>第三个是指定一个 <code>Scheduler</code>，让 <code>Adapter</code> 产生的 <code>Observable</code> 一开始就 <code>subscribeOn</code> 到那个线程上。</p><h2 id="5-调用网络-API"><a href="#5-调用网络-API" class="headerlink" title="5. 调用网络 API"></a>5. 调用网络 API</h2><p>终于，我们可以开始对构建起来的 API 进行调用了，调用的方法和 Rxjava 的普通使用无异；</p><p>下面给出一个基本的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ApiManager.createTrendingService(TrendingApi::<span class="class"><span class="keyword">class</span>)</span></div><div class="line"><span class="class">                   .<span class="title">getTrending</span>(<span class="title">since</span>)</span></div><div class="line"><span class="class">                   .<span class="title">subscribeOn</span>(<span class="title">Schedulers</span>.<span class="title">io</span>())</span></div><div class="line"><span class="class">                   .<span class="title">observeOn</span>(<span class="title">AndroidSchedulers</span>.<span class="title">mainThread</span>())</span></div><div class="line"><span class="class">                   .<span class="title">subscribe</span>(<span class="title">observer</span>)</span>;</div></pre></td></tr></table></figure><p>这里，让我们的网络请求在 <code>io()</code> 线程上发生；</p><p>然后在 Android 的主线程进行回调；</p><p>需要注意的是，我们需要使用 <code>AndroidSchedulers</code> 来进行主线程的指定。</p><blockquote><p>特别需要注意的是，<code>observeOn()</code> 是可以多次指定的<br>如果你需要对结果进行变换操作<br>请务必将 <code>observeOn()</code> 紧挨在 <code>subscribe()</code> 进行设置<br>否则就会在主线程进行请求的变换操作</p></blockquote><h2 id="6-取消请求"><a href="#6-取消请求" class="headerlink" title="6. 取消请求"></a>6. 取消请求</h2><p>讲了这么多都是在讲发起请求，那么该如何取消请求呢？</p><p>没有了 <code>Call</code> 对象，我们该如何取消已经发出去的请求呢？</p><p>实际上 <code>adapter-rxjava2</code> 已经考虑到了这一点。</p><p>在 <code>CallExecuteObservable</code> 中，它向 <code>observer</code> 的 <code>onSubscribe()</code> 传入了一个 <code>CallDisposable</code> 对象；</p><p>通过这个 <code>CallDisposable</code>，当我们取消订阅时，就会自动地将请求取消。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CallDisposable</span> <span class="keyword">implements</span> <span class="title">Disposable</span> </span>&#123;</div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Call&lt;?&gt; call;</div><div class="line"></div><div class="line">   CallDisposable(Call&lt;?&gt; call) &#123;</div><div class="line">     <span class="keyword">this</span>.call = call;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</div><div class="line">     call.cancel();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDisposed</span><span class="params">()</span> </span>&#123;</div><div class="line">     <span class="keyword">return</span> call.isCanceled();</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure><p>所以，只要在 <code>onSubscribe()</code> 中获取到 <code>Disposable</code> 对象；</p><p>通过调用 <code>dispose()</code> 就能取消请求。</p><h2 id="7-其他"><a href="#7-其他" class="headerlink" title="7. 其他"></a>7. 其他</h2><p><code>adapter-rxjava2</code> 除了支持 <code>Observable</code> 以外，还支持了 <code>Flowable</code>、<code>Single</code> 和 <code>Maybe</code> 等对象；</p><p>由于原理都是类似的，在这里就不详细展开了。</p><blockquote><p>不过，请务必注意 <code>Flowable</code> 和 <code>Observable</code> 的区别。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Retrofit 和 Rxjava 结合应该算得上是 Rxjava 在 Android 应用得最广泛的一个方面了。&lt;/p&gt;&lt;p&gt;这里就来讲讲关于这两个库具体组合的用法。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://wafer.li/categories/Android/"/>
    
      <category term="Retrofit" scheme="https://wafer.li/categories/Android/Retrofit/"/>
    
    
      <category term="Android" scheme="https://wafer.li/tags/Android/"/>
    
      <category term="Rxjava2" scheme="https://wafer.li/tags/Rxjava2/"/>
    
      <category term="Retrofit" scheme="https://wafer.li/tags/Retrofit/"/>
    
  </entry>
  
  <entry>
    <title>Rxjava2 坑点详解</title>
    <link href="https://wafer.li/Rxjava/Rxjava2%20%E5%9D%91%E7%82%B9%E8%AF%A6%E8%A7%A3/"/>
    <id>https://wafer.li/Rxjava/Rxjava2 坑点详解/</id>
    <published>2017-05-01T19:03:00.000Z</published>
    <updated>2017-05-01T23:30:49.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Rxjava，是一个响应式的(Reactive)，基于观察者模式的异步框架。</p><p>除此之外，还有其他的 RxScala 和 RxSwift 等。</p><blockquote><p>说起来现在已经 2017 年了，应该没有什么 Java 工程师不知道什么是 Rxjava 了吧</p></blockquote><a id="more"></a><p>网上关于 Rxjava 的文章已经非常多了， 如果你没有了解过 Rxjava；</p><p>那么请直接到文章最后看一些资料和教程；</p><p>这里就主要来讲讲一些 Rxjava2 的坑点。</p><h2 id="1-Observable-和-Flowable"><a href="#1-Observable-和-Flowable" class="headerlink" title="1. Observable 和 Flowable"></a>1. <code>Observable</code> 和 <code>Flowable</code></h2><p>Rxjava2 新增了一个 <code>Flowable</code>，看起来 API 调用和 <code>Observable</code> 类似，而且官方的 README 上都是 <code>Flowable</code> 的示例教程；</p><p>那么很自然的就会联想到 <code>Flowable</code> 是 <code>Obserable</code> 的替代用品；</p><p>它们的 API 调用没有什么区别；</p><p>如果你这么想那就是 <strong>大错特错</strong>！</p><p>它们俩存在一个很大的区别就是关于背压问题的处理。</p><h3 id="1-1-什么是背压-backpressure"><a href="#1-1-什么是背压-backpressure" class="headerlink" title="1.1 什么是背压(backpressure)"></a>1.1 什么是背压(backpressure)</h3><p>在异步任务中，经常会出现一种情况：生产者生产产品过快，而消费者消费速率不同；</p><p>如果不做处理，那么接收端就会被发送端淹没，或者发送端堆积一大堆事件无法处理，最终导致内存爆炸。</p><p>在计算机网络中，对于这种情况的最简单处理就是采用停等模型，直到收到接收端的回报之后，才发送下一个数据。</p><p>而背压，指的就是这样一种处理策略：</p><p>通过将默认的被动接受事件的模式变成 <strong>主动请求事件</strong> ，从而避免接收端处理不及而被淹没或者 OOM 的问题。</p><h3 id="1-2-关于背压的不同处理"><a href="#1-2-关于背压的不同处理" class="headerlink" title="1.2 关于背压的不同处理"></a>1.2 关于背压的不同处理</h3><p>那么两者具体的区别就是：</p><ol><li><p><code>Flowable</code> 是有背压策略的，需要<strong>主动请求事件发送</strong></p></li><li><p>而 <code>Observable</code> 是没有背压策略的，事件会自动发送，多了就会 OOM</p></li></ol><h3 id="1-3-具体的例子"><a href="#1-3-具体的例子" class="headerlink" title="1.3 具体的例子"></a>1.3 具体的例子</h3><p>Observable：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</div><div class="line">          .subscribe(<span class="keyword">new</span> Observer&lt;Integer&gt;() &#123;</div><div class="line">              <span class="meta">@Override</span></div><div class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</div><div class="line">                  <span class="comment">// Disposable 用来取消订阅</span></div><div class="line">              &#125;</div><div class="line"></div><div class="line">              <span class="meta">@Override</span></div><div class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer value)</span> </span>&#123;</div><div class="line"></div><div class="line">              &#125;</div><div class="line"></div><div class="line">              <span class="meta">@Override</span></div><div class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line"></div><div class="line">              &#125;</div><div class="line"></div><div class="line">              <span class="meta">@Override</span></div><div class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">              &#125;</div><div class="line">          &#125;)</div></pre></td></tr></table></figure><p><code>Observable</code> 对应的是 <code>Observer</code>；</p><p>这个写法是没有背压控制的，如果事件过多会 OOM</p><p>Flowable：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">Flowable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</div><div class="line">.subscribe(<span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</div><div class="line">    Subscription sub;</div><div class="line">    <span class="comment">//当订阅后，会首先调用这个方法，其实就相当于onStart()，</span></div><div class="line">    <span class="comment">//传入的Subscription s参数可以用于请求数据或者取消订阅</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Subscription s)</span> </span>&#123;</div><div class="line">        Log.w(<span class="string">"TAG"</span>,<span class="string">"onsubscribe start"</span>);</div><div class="line">        sub=s;</div><div class="line">        sub.request(<span class="number">1</span>);</div><div class="line">        Log.w(<span class="string">"TAG"</span>,<span class="string">"onsubscribe end"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer o)</span> </span>&#123;</div><div class="line">        Log.w(<span class="string">"TAG"</span>,<span class="string">"onNext---&gt;"</span>+o);</div><div class="line">        sub.request(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</div><div class="line">        t.printStackTrace();</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</div><div class="line">        Log.w(<span class="string">"TAG"</span>,<span class="string">"onComplete"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p><code>Flowable</code> 对应的是 <code>Subscriber</code></p><p>可以看到，在具体的回调方法中，我们需要使用 <code>request()</code> 来指示上游的数据传输。</p><p>否则， <strong>数据是不会自动传输的</strong>。</p><p>还有一个有趣的地方在于上面代码的输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">onsubscribe start</div><div class="line">onNext---&gt;0</div><div class="line">onNext---&gt;1</div><div class="line">onNext---&gt;2</div><div class="line">...</div><div class="line">onNext---&gt;10</div><div class="line">onComplete</div><div class="line">onsubscribe end</div></pre></td></tr></table></figure><p>可以看到，<code>onNext</code> 在 <code>onSubscribe</code> 方法 <strong>并没有执行完毕</strong> 就开始调用了。</p><p>具体来说，是在 <code>request()</code> 之后，<code>onNext</code> 方法就立即被执行了；</p><blockquote><p>不过在实践中也不一定是这样的结果</p></blockquote><p>所以千万要注意，在 <code>request()</code> 之前就要将所有的初始化工作做好。</p><h2 id="2-线程调度"><a href="#2-线程调度" class="headerlink" title="2. 线程调度"></a>2. 线程调度</h2><p>能够对线程进行自由调度是 Rxjava 的一大优势；</p><p>但是，由于 Rxjava 的 API 是流式调用，所以很可能会出现线程调度的坑。</p><p>具体来说，Rxjava 通过 <code>subscribeOn()</code> 和 <code>observeOn()</code> 来实现对线程的调度；</p><p>其中，<code>subscribeOn()</code> 指定的是数据的生产线程；</p><p><code>observeOn()</code> 指定的是数据的消费线程。</p><p>但是，一个很重要的区别在于：</p><ol><li><p><code>subscribeOn()</code> 只能指定一次</p><blockquote><p>如果多次指定，则以第一次为准</p></blockquote></li><li><p><code>observeOn()</code> 可以指定多次</p><blockquote><p>每指定一次，其之后流式操作所在的线程就会是指定的线程</p></blockquote></li></ol><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Observable.just(getFilePath())</div><div class="line">           <span class="comment">//指定在新线程中创建被观察者</span></div><div class="line">          .subscribeOn(Schedulers.newThread())</div><div class="line">          <span class="comment">//将接下来执行的线程环境指定为io线程</span></div><div class="line">          .observeOn(Schedulers.io())</div><div class="line">            <span class="comment">//map就处在io线程</span></div><div class="line">          .map(mMapOperater)</div><div class="line">            <span class="comment">//将后面执行的线程环境切换为主线程，</span></div><div class="line">            <span class="comment">//但是这一句依然执行在io线程</span></div><div class="line">          .observeOn(AndroidSchedulers.mainThread())</div><div class="line">          <span class="comment">//指定线程无效，但这句代码本身执行在主线程</span></div><div class="line">          .subscribeOn(Schedulers.io())</div><div class="line">          <span class="comment">//执行在主线程</span></div><div class="line">          .subscribe(mSubscriber)</div></pre></td></tr></table></figure><h2 id="3-参考资料"><a href="#3-参考资料" class="headerlink" title="3. 参考资料"></a>3. 参考资料</h2><p><a href="https://gank.io/post/560e15be2dca930e00da1083" target="_blank" rel="noopener">给 Android 开发者的 RxJava 详解</a></p><p><a href="http://www.jianshu.com/p/6fd8640046f1" target="_blank" rel="noopener">关于RxJava最友好的文章</a></p><p><a href="http://www.jianshu.com/p/e61e1307e538" target="_blank" rel="noopener">关于RxJava最友好的文章（进阶）</a></p><p><a href="http://www.jianshu.com/p/2c4799fa91a4" target="_blank" rel="noopener">关于RxJava最友好的文章——背压（Backpressure）</a></p><p><a href="http://www.jianshu.com/p/220955eefc1f" target="_blank" rel="noopener">关于 RxJava 最友好的文章—— RxJava 2.0 全新来袭</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Rxjava，是一个响应式的(Reactive)，基于观察者模式的异步框架。&lt;/p&gt;&lt;p&gt;除此之外，还有其他的 RxScala 和 RxSwift 等。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;说起来现在已经 2017 年了，应该没有什么 Java 工程师不知道什么是 Rxjava 了吧&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Rxjava" scheme="https://wafer.li/categories/Rxjava/"/>
    
    
      <category term="Rxjava2" scheme="https://wafer.li/tags/Rxjava2/"/>
    
      <category term="Rxjava" scheme="https://wafer.li/tags/Rxjava/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin Scoping 函数</title>
    <link href="https://wafer.li/Kotlin/Kotlin%20Scoping%20%E5%87%BD%E6%95%B0/"/>
    <id>https://wafer.li/Kotlin/Kotlin Scoping 函数/</id>
    <published>2017-04-22T12:02:00.000Z</published>
    <updated>2017-04-22T16:41:32.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在 Kotlin 的 <a href="https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/src/kotlin/util/Standard.kt" target="_blank" rel="noopener">Standard.kt</a> 中提供了一些特殊的高阶函数；</p><p>它们被称作 <strong>Scoping 函数</strong>，此类函数通过使用一个函数 <code>block</code>，将你需要对某对象进行的一系列操作限制在 lambda 作用域内；</p><p>这样，对于该对象操作的代码就不会泄露到外层作用域，使得代码更为干净整洁。</p><p>例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">DbConnection.getConnection().let &#123; connection -&gt;</div><div class="line">&#125;</div><div class="line"><span class="comment">// connection is no longer visible here</span></div></pre></td></tr></table></figure><p>可以看到，对于 <code>connection</code> 的操作就仅局限于 <code>let</code> 的 lambda 区域，而在 lambda 区域外是不可见的；</p><p>这就可以保证对 <code>connection</code> 的操作，不会影响到接下来的作用域。</p><a id="more"></a><h2 id="1-let"><a href="#1-let" class="headerlink" title="1. let"></a>1. <code>let</code></h2><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> T.<span class="title">let</span><span class="params">(f: (<span class="type">T</span>)</span></span> -&gt; R): R = f(<span class="keyword">this</span>)</div></pre></td></tr></table></figure><h3 id="1-2-例子"><a href="#1-2-例子" class="headerlink" title="1.2 例子"></a>1.2 例子</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> s = <span class="string">"hoge"</span>.let &#123; it.toUpperCase() &#125;</div><div class="line">println(s) <span class="comment">//=&gt; HOGE</span></div></pre></td></tr></table></figure><p>从定义之中我们可以看到，<code>let</code> 是所有类型都具有的扩展函数；</p><p>它的 <code>lambda</code> 的参数就是 <code>let</code> 的调用者。</p><h3 id="1-3-主要用途"><a href="#1-3-主要用途" class="headerlink" title="1.3 主要用途"></a>1.3 主要用途</h3><p><code>let</code> 的主要用途在 Kotlin 的 <a href="https://kotlinlang.org/docs/reference/idioms.html#execute-if-not-null" target="_blank" rel="noopener">Idioms</a> 中有介绍；</p><p>主要就是用于在对象 <code>nullable</code> 的时候，对对象进行操作；</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">data</span>?.let &#123;</div><div class="line">    ... <span class="comment">// execute this block if not null</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当 <code>data</code> 为 <code>null</code> 时，<code>let</code> 就不执行，而直接返回 <code>null</code>；</p><p>否则就执行 <code>let</code> 的 lambda。</p><p>此时，它与 Java <code>Optional</code> 的以下三个函数的功能类似：</p><ul><li><code>map</code></li><li><code>flatMap</code></li><li><code>ifPresent</code></li></ul><p>可以看到，<code>let</code> 实际上就相当于集合中的 <code>map</code>，作用就是进行元素的变换功能；</p><p><img src="https://ww2.sinaimg.cn/large/006tNbRwgy1fevs5lulszj30ho08k74u.jpg" alt=""></p><p>注意，不能在 <code>let</code> 中调用 <code>it</code> 的修改方法；</p><p>否则，就会对原有对象进行改变。</p><h2 id="2-with"><a href="#2-with" class="headerlink" title="2. with"></a>2. <code>with</code></h2><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> <span class="title">with</span><span class="params">(receiver: <span class="type">T</span>, f: <span class="type">T</span>.()</span></span> -&gt; R): R = receiver.f()</div></pre></td></tr></table></figure><h3 id="2-2-例子"><a href="#2-2-例子" class="headerlink" title="2.2 例子"></a>2.2 例子</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> w = Window()</div><div class="line">with(w) &#123;</div><div class="line">  setWidth(<span class="number">100</span>)</div><div class="line">  setHeight(<span class="number">200</span>)</div><div class="line">  setBackground(RED)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>和 <code>let</code> 不同，<code>with</code> <strong>并不是扩展函数</strong>；</p><p>它的第一个参数，是任意类型的对象，如上面的 <code>x</code>；</p><p>需要注意的是它的 lambda 部分，它的 lambda 要求接收者（调用者）必须是第一个参数的类型；</p><p>也就是说，我们可以在它的 lambda 中调用第一个参数的方法；</p><p>正如上面的例子，其中的几个 <code>set</code> 方法都隐含了调用者是 <code>w</code></p><h3 id="2-3-主要用途"><a href="#2-3-主要用途" class="headerlink" title="2.3 主要用途"></a>2.3 主要用途</h3><p>由于指定了接收者类型，所以 <code>with</code> 函数主要用于对复杂对象的一系列配置操作。</p><p>如上面的设置 <code>Window</code> 的宽度和高度，以及背景颜色等。</p><p><img src="https://ww4.sinaimg.cn/large/006tNbRwgy1fevsj7j8fij30e60agjrw.jpg" alt=""></p><p>可以看到，<code>with</code> 的调用 <strong>会改变传入的对象</strong></p><p>实际上，这里也可以使用 <code>let</code> 函数进行这种操作；</p><p>不过由于 <code>let</code> 函数是将对象当做 <strong>参数</strong> 传入，所以如果要获得和 <code>with</code> 一样的效果，就必须在前面加 <code>it</code>：</p><p><img src="https://ww3.sinaimg.cn/large/006tNbRwly1fevslr0wr7j30iu0aijrz.jpg" alt=""></p><p>所以，<code>let</code> 并不适合这里所说的这个用途，利用 <code>let</code> 进行元素变换即可。</p><h2 id="3-run"><a href="#3-run" class="headerlink" title="3. run"></a>3. <code>run</code></h2><h3 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1 定义"></a>3.1 定义</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> T.<span class="title">run</span><span class="params">(f: <span class="type">T</span>.()</span></span> -&gt; R): R = f()</div></pre></td></tr></table></figure><h3 id="3-2-例子"><a href="#3-2-例子" class="headerlink" title="3.2 例子"></a>3.2 例子</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> s = <span class="string">"hoge"</span>.run &#123; toUpperCase() &#125;</div><div class="line">println(s) <span class="comment">//=&gt; HOGE</span></div></pre></td></tr></table></figure><p>可以看到，<code>run</code> 实际上就是 <code>let</code> 和 <code>with</code> 的结合；</p><p>可以让 <code>with</code> 不需要指定 <code>receiver</code> 参数就进行对象内部属性的配置；</p><p>同时，<code>run</code> 也是一个扩展函数，可以通过任何的类进行调用。</p><h3 id="3-3-主要用途"><a href="#3-3-主要用途" class="headerlink" title="3.3 主要用途"></a>3.3 主要用途</h3><p>作为 <code>let</code> 和 <code>with</code> 的合体方法，那么最主要的用途当然还是进行某个对象的配置。</p><p><img src="https://ww1.sinaimg.cn/large/006tNbRwgy1fevw96ztszj30go0843yz.jpg" alt=""></p><p>需要注意的是，<code>run</code> 也会对对象进行改变。</p><h2 id="4-apply"><a href="#4-apply" class="headerlink" title="4. apply"></a>4. <code>apply</code></h2><h3 id="4-1-定义"><a href="#4-1-定义" class="headerlink" title="4.1 定义"></a>4.1 定义</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">apply</span><span class="params">(f: <span class="type">T</span>.()</span></span> -&gt; <span class="built_in">Unit</span>): T &#123; f(); <span class="keyword">return</span> <span class="keyword">this</span> &#125;</div></pre></td></tr></table></figure><h3 id="4-2-例子"><a href="#4-2-例子" class="headerlink" title="4.2 例子"></a>4.2 例子</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> s = <span class="string">"hoge"</span>.apply &#123; toUpperCase() &#125;</div><div class="line">println(s) <span class="comment">//=&gt; hoge</span></div></pre></td></tr></table></figure><p>相比之前的结果，返回的依旧是小写字符；</p><p>这是由于 <code>apply</code> 返回的是 <code>apply</code> 的调用者的缘故。</p><h3 id="4-3-主要用途"><a href="#4-3-主要用途" class="headerlink" title="4.3 主要用途"></a>4.3 主要用途</h3><p>由于 <code>apply</code> 的返回类型为调用者自身，所以可以利用 <code>apply</code> 实现一个 <strong>流式 API 调用</strong>。</p><p>实际上就是 <code>with</code> 最后返回 <code>this</code> 的简略版本。</p><p><img src="https://ww1.sinaimg.cn/large/006tNbRwgy1fevwr9abcuj30va062q3m.jpg" alt=""></p><h2 id="5-also"><a href="#5-also" class="headerlink" title="5. also"></a>5. <code>also</code></h2><p>这是 Kotlin 1.1 新增的 scoping 函数</p><h3 id="5-1-定义"><a href="#5-1-定义" class="headerlink" title="5.1 定义"></a>5.1 定义</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">also</span><span class="params">(block: (<span class="type">T</span>)</span></span> -&gt; <span class="built_in">Unit</span>): T &#123; block(<span class="keyword">this</span>); <span class="keyword">return</span> <span class="keyword">this</span> &#125;</div></pre></td></tr></table></figure><h3 id="5-2-使用例子"><a href="#5-2-使用例子" class="headerlink" title="5.2 使用例子"></a>5.2 使用例子</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> s = <span class="string">"hoge"</span>.also &#123; it.toUpperCase() &#125;</div><div class="line">println(s) <span class="comment">//=&gt; hoge</span></div></pre></td></tr></table></figure><p>可以看到，其作用和 <code>apply</code> 一样；</p><p>但是和 <code>apply</code> 的区别在于，<code>also</code> 的函数参数并非指定接收者；</p><p>而是将调用者 <code>T</code> 当做其参数传入 lambda；</p><p>类似于 <code>let</code> 的 <code>apply</code> 版本。</p><h3 id="5-3-主要用途"><a href="#5-3-主要用途" class="headerlink" title="5.3 主要用途"></a>5.3 主要用途</h3><p>那么这样做有什么好处呢？</p><p>首先，由于 <strong>没有指定接收者</strong>，所以 lambda 内外的 <code>this</code> 的含义没有改变：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// applyを使用</span></div><div class="line"><span class="keyword">val</span> button = Button(<span class="keyword">this</span>).apply &#123;</div><div class="line">  text = <span class="string">"Click me"</span></div><div class="line">  setOnClickListener &#123;</div><div class="line">    startActivity(Intent(<span class="keyword">this</span><span class="symbol">@MainActivity</span>, NextActivity::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>))</span></div><div class="line">    <span class="comment">// 単なる「this」ではNG   ^</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// alsoを使用</span></div><div class="line"><span class="keyword">val</span> button = Button(<span class="keyword">this</span>).also &#123; button -&gt;</div><div class="line">  button.text = <span class="string">"Click me"</span></div><div class="line">  button.setOnClickListener &#123;</div><div class="line">    startActivity(Intent(<span class="keyword">this</span>, NextActivity::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>))</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其次，可以通过赋予 lambda 参数名字，例如上面的 <code>button</code> ，增强可读性。</p><h3 id="5-4-和-let-的区别"><a href="#5-4-和-let-的区别" class="headerlink" title="5.4 和 let 的区别"></a>5.4 和 <code>let</code> 的区别</h3><p><code>also</code> 和 <code>let</code> 都是通过将调用者作为 lambda 的参数传入函数的形式进行调用；</p><p>其区别就在于 <code>also</code> 最终返回值为其自身的调用者，即 <code>this</code>；</p><p>而 <code>let</code> 的最终返回值由它的 lambda 的最后一个表达式的返回值决定。</p><p>类似于 <code>apply</code> 和 <code>with</code> 的区别；</p><p>同理，也可以利用 <code>let</code> 来实现上面的 <code>also</code> 实现的功能：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> button = Button(<span class="keyword">this</span>).let &#123; button -&gt;</div><div class="line">  button.text = <span class="string">"Click me"</span></div><div class="line">  button.setOnClickListener &#123;</div><div class="line">    startActivity(Intent(<span class="keyword">this</span>, NextActivity::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>))</span></div><div class="line">  &#125;</div><div class="line">  button <span class="comment">// letの場合はこれが必要になる</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><ol><li><code>let</code> 用于进行元素变换操作，类似于 <code>map</code></li><li><code>with</code> 用于对复杂对象的配置，需要提供具体的对象</li><li><code>run</code> 是 <code>with</code> 的 <code>let</code> 版本，配置对象属性，不需要提供具体对象</li><li><code>apply</code> 是 <code>with</code> 的流式 API 版本</li><li><code>also</code> 是 <code>let</code> 的 <code>apply</code> 版本，用于对象配置，同时保留流式 API 和 当前 <code>this</code> 的含义</li></ol><h2 id="7-参考资料"><a href="#7-参考资料" class="headerlink" title="7. 参考资料"></a>7. 参考资料</h2><p><a href="http://qiita.com/ngsw_taro/items/d29e3080d9fc8a38691e#%E5%AE%9A%E7%BE%A9-2" target="_blank" rel="noopener">Kotlin スコープ関数 用途まとめ</a></p><p><a href="http://beust.com/weblog/2015/10/30/exploring-the-kotlin-standard-library/" target="_blank" rel="noopener">Exploring the Kotlin standard library</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Kotlin 的 &lt;a href=&quot;https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/src/kotlin/util/Standard.kt&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Standard.kt&lt;/a&gt; 中提供了一些特殊的高阶函数；&lt;/p&gt;&lt;p&gt;它们被称作 &lt;strong&gt;Scoping 函数&lt;/strong&gt;，此类函数通过使用一个函数 &lt;code&gt;block&lt;/code&gt;，将你需要对某对象进行的一系列操作限制在 lambda 作用域内；&lt;/p&gt;&lt;p&gt;这样，对于该对象操作的代码就不会泄露到外层作用域，使得代码更为干净整洁。&lt;/p&gt;&lt;p&gt;例如：&lt;/p&gt;&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;DbConnection.getConnection().let &amp;#123; connection -&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// connection is no longer visible here&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;可以看到，对于 &lt;code&gt;connection&lt;/code&gt; 的操作就仅局限于 &lt;code&gt;let&lt;/code&gt; 的 lambda 区域，而在 lambda 区域外是不可见的；&lt;/p&gt;&lt;p&gt;这就可以保证对 &lt;code&gt;connection&lt;/code&gt; 的操作，不会影响到接下来的作用域。&lt;/p&gt;
    
    </summary>
    
      <category term="Kotlin" scheme="https://wafer.li/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="https://wafer.li/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Scala for-comprehension</title>
    <link href="https://wafer.li/Scala/Scala%20for-comprehension/"/>
    <id>https://wafer.li/Scala/Scala for-comprehension/</id>
    <published>2017-04-22T05:21:00.000Z</published>
    <updated>2017-04-22T08:08:51.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Scala 作为函数式语言，提供了很多用于高阶函数来解决一类范式问题；</p><p>但是，使用过多的高阶函数就会让代码的可读性变差；</p><p>所以，对此 Scala 提供了一种类 Python 的简便的语法糖，用来解决代码的可读性问题。</p><a id="more"></a><h2 id="1-问题背景"><a href="#1-问题背景" class="headerlink" title="1. 问题背景"></a>1. 问题背景</h2><p>在这里举一个 <em>Effective Scala</em> 中的例子：</p><p>比如说，我要列出所有不同字母组成的 <code>pair</code>，那么该怎么办呢？</p><p>如果用 Java 的话，就会有两层 <code>for</code>，那么在 Scala 下，我们就应该用到 <code>flatMap</code>：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> chars = 'a' to 'z'</div><div class="line"></div><div class="line">chars flatMap &#123; a =&gt;</div><div class="line">    chars flatMap &#123; b =&gt;</div><div class="line">        <span class="type">Vector</span>(<span class="string">"%c%c"</span>.format(a, b))</div><div class="line">    &#125;</div><div class="line">&#125; filter &#123; s =&gt; s.head != s.last &#125;</div></pre></td></tr></table></figure><p>这里用到了两个 <code>flatMap</code>，为什么？</p><p>首先，如果都使用 <code>map</code>，那么内部的 <code>map</code> 将元素转变为了 <code>Vector</code>；</p><p>而 <code>char</code> 作为 <code>Range</code>，会默认选择 <code>Vector</code> 作为 <code>map</code> 的选项；</p><p>此时， <code>a</code> 转换成的东西就变成了 <code>Vector[Vector[String]]</code>；</p><p>而 <code>chars</code> 又会默认生成一层 <code>Vector</code>；</p><p>所以，最后生成的东西就会有三层 <code>Vector</code>，即 <code>Vector[Vector[Vector(String)]]</code>；</p><p>所以，我们需要两次 <code>flatten</code> 进行展平，才能最终得到 <code>Vector(String)</code>；</p><p>这也是为什么需要两次 <code>flatMap</code> 的原因。</p><p>可以看到，如果采用 <code>flatMap</code>，那么操作就会变得十分难以理解。</p><h2 id="2-for-comprehension"><a href="#2-for-comprehension" class="headerlink" title="2. for-comprehension"></a>2. <code>for-comprehension</code></h2><p>对此，Scala 提供了一种简便的，用于生成 <code>Seq</code> 的 <code>for</code> 表达式；</p><p>通常称为 <code>for-comprehension</code>，也称为 <code>Sequence Comprehension</code>，或者 <code>for expression</code>。</p><p>它的语法结构如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (s) <span class="keyword">yield</span> e</div></pre></td></tr></table></figure><p>其中，<code>s</code> 被称作 <code>enumerators</code>，<code>e</code> 则是遍历生成的元素；</p><p>表达式对于 <code>s</code> 有以下几点要求：</p><ol><li><p><code>s</code> 是 <code>generator</code> 和 <code>filter</code> 组成的，以分号间隔的语句序列。</p></li><li><p><code>genrator</code> 的形式为： <code>p &lt;- c</code>。</p><blockquote><p>其中 <code>p</code> 是一个模式(pattern)，<code>c</code> 则是一个集合</p></blockquote></li><li><p><code>filter</code> 的形式为 <code>if condition</code>，其中 <code>condition</code> 是个布尔表达式</p></li><li><p>允许多个 <code>generator</code>，但是在下面的 <code>generator</code> 必须比在上面的要变化的快。</p><blockquote><p>换成指令性语言的话，就是在下面的 <code>generator</code> 必须在更内部的 <code>for</code> 循环中。</p></blockquote></li></ol><p>经过执行之后，这个表达式会返回一个由 <code>e</code> 组成的集合；</p><p>具体返回的集合类型，例如 <code>List</code> 和 <code>Vector</code>，则由 <code>s</code> 来决定；</p><p>如果类型不能满足，则会向类型结构的上一层回溯，直到找到一个最接近的满足要求的类型为止。</p><p>同时，<code>for-comprehension</code> 可以使用花括号代替圆括号，此时，就不需要用分号来分隔语句了。</p><h2 id="3-使用-for-comprehension-解决问题"><a href="#3-使用-for-comprehension-解决问题" class="headerlink" title="3. 使用 for-comprehension 解决问题"></a>3. 使用 <code>for-comprehension</code> 解决问题</h2><p>那么，对于上面的问题，我们试着使用 <code>for-comprehension</code> 来解决：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> chars = 'a' to 'z'</div><div class="line"></div><div class="line"><span class="keyword">for</span> &#123;</div><div class="line">    a &lt;- chars</div><div class="line">    b &lt;- chars</div><div class="line">    <span class="keyword">if</span> (a != b)</div><div class="line">&#125; <span class="keyword">yield</span> <span class="string">"%c%c"</span>.format(a, b)</div></pre></td></tr></table></figure><p>可以看到，使用 <code>for-comprehension</code> 来解决，写出来的代码会比 <code>flatMap</code> 简单得多。</p><h2 id="4-关于返回类型"><a href="#4-关于返回类型" class="headerlink" title="4. 关于返回类型"></a>4. 关于返回类型</h2><p>对于上面的表达式，它的返回类型是什么呢？</p><p>实际上，是一个 <code>Vector</code>。</p><p>为什么是一个 <code>Vector</code> ？</p><p>这是因为，<code>chars</code> 实际上是一个 <code>Range</code> 对象；</p><p>而对于 <code>Range</code> 对象，它不能拥有一堆 <code>String</code>；</p><p>此时，Scala 编译器会在类型结构中向上寻找最近的满足条件的类型；</p><p>此时，寻找到的是 <code>IndexedSeq</code>，而这个类型的默认 <code>Seq</code> 实现就是 <code>Vector</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Scala 作为函数式语言，提供了很多用于高阶函数来解决一类范式问题；&lt;/p&gt;&lt;p&gt;但是，使用过多的高阶函数就会让代码的可读性变差；&lt;/p&gt;&lt;p&gt;所以，对此 Scala 提供了一种类 Python 的简便的语法糖，用来解决代码的可读性问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Scala" scheme="https://wafer.li/categories/Scala/"/>
    
    
      <category term="Scala" scheme="https://wafer.li/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Scala List 高阶函数</title>
    <link href="https://wafer.li/Scala/Scala%20List%20%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"/>
    <id>https://wafer.li/Scala/Scala List 高阶函数/</id>
    <published>2017-04-20T18:20:00.000Z</published>
    <updated>2017-04-22T18:21:13.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>高阶函数是函数式编程的一个很大的特性；</p><p>同时，其中集合类的高阶函数在日常的开发和使用中，占了一个很重要的位置；</p><p>但是，这些函数有可能会在刚接触的时候搞不懂它们的具体作用；</p><p>那么今天就以 <code>List</code> 来说一说常用的高阶函数具体的作用。</p><a id="more"></a><h2 id="1-子集操作"><a href="#1-子集操作" class="headerlink" title="1. 子集操作"></a>1. 子集操作</h2><p>在一个集合中选取一些特定的元素作为子集；</p><p>我们在指令性语言中，通常选用 <code>for</code> 语句来实现这个需求；</p><p>而在函数式语言中，我们有对应的高阶函数来解决这个问题。</p><h3 id="1-1-filter-p-T-gt-Boolean"><a href="#1-1-filter-p-T-gt-Boolean" class="headerlink" title="1.1 filter(p: (T) =&gt; Boolean)"></a>1.1 <code>filter(p: (T) =&gt; Boolean)</code></h3><p>顾名思义， <strong>过滤器</strong>，用来 <strong>选取符合条件的元素</strong>， 并将其作为返回值；</p><p>这里的 <strong>符合条件</strong> 指的是 使得函数 <code>p</code> 的返回值为 <code>true</code> 的元素。</p><p>例如：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</div><div class="line"></div><div class="line">list.filter((x) =&gt; x &gt; <span class="number">2</span>) <span class="comment">// List(3, 4)</span></div></pre></td></tr></table></figure><h3 id="1-2-filterNot-p-T-gt-Boolean"><a href="#1-2-filterNot-p-T-gt-Boolean" class="headerlink" title="1.2 filterNot(p: (T) =&gt; Boolean)"></a>1.2 <code>filterNot(p: (T) =&gt; Boolean)</code></h3><p>同理，这个函数是上面的反面，也就是用来 <strong>过滤掉</strong> 符合条件的元素；</p><p>返回的是， <strong>不包含符合元素的子集</strong>；</p><p>例如：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>)</div><div class="line"></div><div class="line">list.filterNot((x) =&gt; x == <span class="number">2</span>) <span class="comment">// List(1, 3)</span></div></pre></td></tr></table></figure><h3 id="1-3-partition-p-T-gt-Boolean"><a href="#1-3-partition-p-T-gt-Boolean" class="headerlink" title="1.3 partition(p: (T) =&gt; Boolean)"></a>1.3 <code>partition(p: (T) =&gt; Boolean)</code></h3><p>这个函数是上面两个函数的集合体，返回的是一个 <code>Turple</code>，包含的元素为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(list.filter, list.filterNot)</div></pre></td></tr></table></figure><p>例如：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</div><div class="line"></div><div class="line"><span class="comment">// Returns: (List(1, 2, 3), List(4, 5, 6, 7))</span></div><div class="line">list.partition((x) =&gt; x &lt; <span class="number">4</span>)</div></pre></td></tr></table></figure><h3 id="1-4-takeWhile-p-T-gt-Boolean"><a href="#1-4-takeWhile-p-T-gt-Boolean" class="headerlink" title="1.4 takeWhile(p: (T) =&gt; Boolean)"></a>1.4 <code>takeWhile(p: (T) =&gt; Boolean)</code></h3><p>这个函数会一直选取元素， <strong>直到 <code>p</code> 的返回值为 <code>false</code></strong>，然后将元素作为新的集合返回。</p><p>可以看到，这个函数返回的就是 <strong>符合条件的集合前缀</strong></p><p>例如：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</div><div class="line"></div><div class="line"><span class="comment">// 注意最后一个 1 并没有拿走</span></div><div class="line">list.takeWhile((x) =&gt; x == <span class="number">1</span>) <span class="comment">// List(1, 1, 1, 1)</span></div></pre></td></tr></table></figure><h3 id="1-5-dropWhile-p-T-gt-Boolean"><a href="#1-5-dropWhile-p-T-gt-Boolean" class="headerlink" title="1.5 dropWhile(p: (T) =&gt; Boolean)"></a>1.5 <code>dropWhile(p: (T) =&gt; Boolean)</code></h3><p>和上面的方法相反，这个方法会一直 <strong>丢弃</strong> 元素，直到 <code>p</code> 的返回值为 <code>false</code>；</p><p>那么可以看到，这个函数返回的就是 <strong>不符合条件的集合后缀</strong>；</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>)</div><div class="line"></div><div class="line">list.dropWhile((x) x != <span class="number">4</span>) <span class="comment">// List(4, 2, 1)</span></div></pre></td></tr></table></figure><h3 id="1-6-span-p-T-gt-Boolean"><a href="#1-6-span-p-T-gt-Boolean" class="headerlink" title="1.6 span(p: (T) =&gt; Boolean)"></a>1.6 <code>span(p: (T) =&gt; Boolean)</code></h3><p>这个函数是上两个函数的结合，它返回的是如下的一个 <code>Turple</code>：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(list.takeWhile, list.dropWhile)</div></pre></td></tr></table></figure><h3 id="1-7-partition、span-和它们的基本方法的区别"><a href="#1-7-partition、span-和它们的基本方法的区别" class="headerlink" title="1.7 partition、span 和它们的基本方法的区别"></a>1.7 <code>partition</code>、<code>span</code> 和它们的基本方法的区别</h3><p>既然 <code>partition</code> 和 <code>span</code> 都可以用基本的 <code>filter</code>、<code>filterNot</code> 和 <code>takeWhile</code>、<code>dropWhile</code> 来解决，那为什么还要专门实现一次这两个方法呢？</p><p>其实，<code>span</code> 和 <code>partition</code> 只需要扫描一次集合；</p><p>但是如果使用 <code>filter</code>、<code>filterNot</code> 和 <code>takeWhile</code>、<code>dropWhile</code> 来实现的话，就需要扫描两次集合了。</p><p>所以，如果同时需要两者的数据的话，那么使用 <code>span</code> 和 <code>partition</code> 显然是更经济的。</p><h3 id="1-8-withFilter"><a href="#1-8-withFilter" class="headerlink" title="1.8 withFilter"></a>1.8 <code>withFilter</code></h3><p>Scala 除了 <code>filter</code> 之外，还提供了一个 <code>withFilter</code> 函数；</p><p>那么，这两者有什么区别呢？</p><p>根据文档：</p><blockquote><p>Note: the difference between <code>c filter p</code> and <code>c withFilter p</code> is that the former creates a new collection, whereas the latter only restricts the domain of subsequent map, flatMap, foreach, and withFilter operations.</p></blockquote><p>也就是说，<code>filter</code> 会返回一个 <strong>新的 <code>List</code></strong>；</p><p>但是 <code>withFilter</code> 不会返回新的 <code>List</code>；</p><p>它只会提供一个过滤器的作用，让符合条件的元素通过，以方便接下来的 <code>map</code> 等其他高阶函数的使用；</p><p>而就效率而言，<code>withFilter</code> 比 <code>filter</code> 要快。</p><p>如果你需要返回一个新的集合，就使用 <code>filter</code>；</p><p>如果你只是需要一个元素过滤器，而接下来，还需要进行其他操作，那么就使用 <code>withFilter</code></p><h2 id="2-元素检查"><a href="#2-元素检查" class="headerlink" title="2. 元素检查"></a>2. 元素检查</h2><p>有时候，我们会希望检查集合内部的元素状态；</p><p>比如说， <strong>是否所有的元素都满足某个特定条件</strong>；</p><p>或者， <strong>是否有元素满足特定条件</strong>。</p><p>在 Scala 中，我们有高阶函数来进行这个操作。</p><h3 id="2-1-forAll-p-T-gt-Boolean-Boolean"><a href="#2-1-forAll-p-T-gt-Boolean-Boolean" class="headerlink" title="2.1 forAll(p: (T) =&gt; Boolean): Boolean"></a>2.1 <code>forAll(p: (T) =&gt; Boolean): Boolean</code></h3><p>顾名思义，检查 <strong>是否所有的元素都满足特定条件</strong></p><p>例如：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</div><div class="line"></div><div class="line">list.forAll(c =&gt; c &gt; <span class="number">0</span>) <span class="comment">// true</span></div></pre></td></tr></table></figure><h3 id="2-2-exists-p-T-gt-Boolean-Boolean"><a href="#2-2-exists-p-T-gt-Boolean-Boolean" class="headerlink" title="2.2 exists(p: (T) =&gt; Boolean): Boolean"></a>2.2 <code>exists(p: (T) =&gt; Boolean): Boolean</code></h3><p>同理，检查 <strong>是否存在满足条件的元素</strong></p><p>例如：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</div><div class="line"></div><div class="line">list.exists(c =&gt; c &lt; <span class="number">0</span>) <span class="comment">// false</span></div></pre></td></tr></table></figure><h2 id="3-变换"><a href="#3-变换" class="headerlink" title="3. 变换"></a>3. 变换</h2><h3 id="3-1-map-f-T-gt-U"><a href="#3-1-map-f-T-gt-U" class="headerlink" title="3.1 map(f: (T) =&gt; U)"></a>3.1 <code>map(f: (T) =&gt; U)</code></h3><p><code>map</code> 函数，可以说是这里面用的最多的高阶函数了；</p><p><code>map</code> 函数的真正作用，实际上是一种变换功能，而且不仅可以变换成和现元素类型相同的类型，也可以变换成不同的类型；</p><p>也就是说，可以通过 <code>map</code> 函数，将一种元素的集合，变成另一种元素的集合。</p><p>例子：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将所有元素都乘以 2</span></div><div class="line"></div><div class="line"><span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</div><div class="line"></div><div class="line">list.map((x) =&gt; x * <span class="number">2</span>)  <span class="comment">// List(2, 4, 6, 8)</span></div></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将 Int 变成 String</span></div><div class="line"></div><div class="line"><span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</div><div class="line"></div><div class="line">list.map((x) =&gt; x.toString())   <span class="comment">// List("1", "2", "3", "4")</span></div></pre></td></tr></table></figure><h3 id="3-2-flatten"><a href="#3-2-flatten" class="headerlink" title="3.2 flatten"></a>3.2 <code>flatten</code></h3><p>这个函数可以将嵌套的 <code>List</code> 展平，就像它的名字一样。</p><p>例如：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> listOfLists = <span class="type">List</span>(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>), <span class="type">List</span>(<span class="number">3</span>, <span class="number">4</span>))</div><div class="line"></div><div class="line">listOfLists.flatten = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</div></pre></td></tr></table></figure><h3 id="3-3-flatMap"><a href="#3-3-flatMap" class="headerlink" title="3.3 flatMap"></a>3.3 <code>flatMap</code></h3><p>它是 <code>map</code> 和 <code>flatten</code> 的集合体，相当于先进行 <code>map</code> 然后 <code>flatten</code>。</p><p>例子：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> listOfLists = <span class="type">List</span>(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>), <span class="type">List</span>(<span class="number">3</span>, <span class="number">4</span>))</div><div class="line"></div><div class="line">listOfLists.flatMap((x) =&gt; x.map(_ * <span class="number">2</span>)) <span class="comment">// List(2, 4, 6, 8)</span></div></pre></td></tr></table></figure><p>也就是说，<code>flatMap</code> 先将元素 <code>map</code> 成 <strong>嵌套的</strong> <code>List</code>；</p><p>随后，再调用 <code>flatten</code>，将嵌套的 <code>List</code> 展平</p><blockquote><p><code>flatMap</code> 的作用过于强大，使用时需要小心谨慎<br>在 Twitter 的 <em>Effective Scala</em> 中，推荐使用 <em>for-comprehention</em> 来代替 <code>flatMap</code> 的使用</p></blockquote><h3 id="3-4-zip-T-xs-List-U-List-T-U"><a href="#3-4-zip-T-xs-List-U-List-T-U" class="headerlink" title="3.4 zip[T](xs: List[U]): List[(T, U)]"></a>3.4 <code>zip[T](xs: List[U]): List[(T, U)]</code></h3><p>压缩，它的左右两个操作数分别是 <strong>两个 <code>List</code></strong>；</p><p>然后返回一个分别包含两个 <code>List</code> 元素的二元组的 <code>List</code>。</p><p>例如：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> list1 = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</div><div class="line"><span class="keyword">val</span> list2 = <span class="type">List</span>(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>)</div><div class="line"></div><div class="line"><span class="comment">// List((1, "a"), (2, "b"), (3, "c"), (4, "d"))</span></div><div class="line">list1 zip list2</div></pre></td></tr></table></figure><h3 id="3-5-unzip"><a href="#3-5-unzip" class="headerlink" title="3.5 unzip"></a>3.5 <code>unzip</code></h3><p>有压缩就有解压；</p><p>这个函数的作用就是将上面压缩后的结果解压出来；</p><p>具体来说就是接受一个二元组的 <code>List</code>， 返回一个 <code>List</code> 的二元组。</p><p>例如：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> list1 = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</div><div class="line"><span class="keyword">val</span> list2 = <span class="type">List</span>(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>)</div><div class="line"></div><div class="line"><span class="comment">// (List(1, 2, 3, 4), List("a", "b", "c", "d"))</span></div><div class="line">(list1 zip list2) unzip</div></pre></td></tr></table></figure><h3 id="3-6-collect"><a href="#3-6-collect" class="headerlink" title="3.6 collect"></a>3.6 <code>collect</code></h3><p>根据文档，<code>collect</code> 接受一个 <code>PartialFunction</code>，然后对集合中的每个元素都 apply 这个函数，返回一个新的集合。</p><p>听起来，这个方法和 <code>map</code> 很像，不过其区别就是在于 <code>collect</code> 接受的是一个 <code>PartialFnction</code> ；</p><p>这具体是什么意思呢？</p><p>我们来举个例子：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> convertFn: <span class="type">PartialFunction</span>[<span class="type">Any</span>, <span class="type">Int</span>] = &#123;</div><div class="line">  <span class="keyword">case</span> i: <span class="type">Int</span> =&gt; i;</div><div class="line">  <span class="keyword">case</span> s: <span class="type">String</span> =&gt; s.toInt;</div><div class="line">  <span class="keyword">case</span> <span class="type">Some</span>(s: <span class="type">String</span>) =&gt; s.toInt</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="type">List</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="type">Some</span>(<span class="number">4</span>), <span class="type">Some</span>(<span class="string">"5"</span>)).</div><div class="line">  collect(convertFn)</div><div class="line"></div><div class="line"><span class="comment">// List[Int] = List(0, 1, 2, 3, 5)</span></div></pre></td></tr></table></figure><p>注意到， <code>collect</code> 的 lambda 中，并没有对所有的 <code>case</code> 都进行处理；</p><p>上面的 <code>List</code> 除了含有 <code>String</code> 、 <code>Int</code> 和 <code>Some[String]</code> 之外，还含有 <code>Some[Int]</code>；</p><p>这就是所谓的 <code>PartialFunction</code> ，它并没有对所有的情形都进行处理，也没有提供一个默认的选项。</p><p>如果上面的 <code>collect</code> 替换为 <code>map</code>，则第四个 <code>Some(4)</code> 就会导致 <code>MatchError</code>；</p><p>而 <code>collect</code> 则避开了这个错误。</p><p>理论上，<code>collect</code> 进行了 <code>map</code> 和 <code>filter</code> 的两重功能。</p><p>虽然，<code>collect</code> 不会造成 <code>MatchError</code>；</p><p>但是 <code>collect</code> 不是使用 <code>try...catch</code> 实现的。</p><p><code>collect</code> 是通过检查函数中提供的 <code>case</code> 检查；</p><p>如果 <code>case</code> 不匹配，则跳过该元素，不调用函数；</p><p>如果 <code>case</code> 中存在 <code>???</code>，那么同样也会抛出异常：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="type">List</span>(<span class="number">1</span>, <span class="string">""</span>).collect(</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">case</span> i: <span class="type">Int</span> =&gt; i;</div><div class="line">    <span class="keyword">case</span> _ =&gt; ???</div><div class="line">  &#125;</div><div class="line">)</div><div class="line"></div><div class="line">scala.<span class="type">NotImplementedError</span>: an implementation is missing</div><div class="line">  at scala.<span class="type">Predef</span>$.$qmark$qmark$qmark(<span class="type">Predef</span>.scala:<span class="number">225</span>)</div><div class="line">  at $anonfun$<span class="number">1.</span>applyOrElse(&lt;console&gt;:<span class="number">8</span>)</div><div class="line">  at scala.collection.immutable.<span class="type">List</span>.collect(<span class="type">List</span>.scala:<span class="number">303</span>)</div><div class="line">  ... <span class="number">33</span> elided</div></pre></td></tr></table></figure><h3 id="3-7-collectFirst"><a href="#3-7-collectFirst" class="headerlink" title="3.7 collectFirst"></a>3.7 <code>collectFirst</code></h3><p>这是 <code>collect</code> 的简化版本；</p><p>它只会将函数应用在 <strong>第一个满足</strong> 其 <code>case</code> 的元素中，并返回一个包含该元素的 <code>Option</code> 对象。</p><p>如果不存在这样的函数，那么就返回 <code>None</code></p><h3 id="3-8-groupBy-A-f-A-gt-K-Map-K-Seq-A"><a href="#3-8-groupBy-A-f-A-gt-K-Map-K-Seq-A" class="headerlink" title="3.8 groupBy[A](f: (A) =&gt; K): Map[K, Seq[A]]"></a>3.8 <code>groupBy[A](f: (A) =&gt; K): Map[K, Seq[A]]</code></h3><p><code>groupBy</code> 通过函数 <code>f</code>，将 <code>List</code> 分成不同的部分；</p><p>每一个部分由一个键值 <code>K</code> 来进行映射，最终返回结果为一个 <code>Map</code> 对象。</p><p>例子：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> fruit = <span class="type">List</span>(<span class="string">"apple"</span>, <span class="string">"peer"</span>, <span class="string">"orange"</span>, <span class="string">"pineapple"</span>)</div><div class="line"></div><div class="line">fruit groupBy (_.head)</div><div class="line"></div><div class="line"><span class="comment">//&gt; Map(p -&gt; List("peer", "pineapple"),</span></div><div class="line"><span class="comment">//      a -&gt; List("apple"),</span></div><div class="line"><span class="comment">//      o -&gt; List("orange"))</span></div></pre></td></tr></table></figure><h2 id="4-规约"><a href="#4-规约" class="headerlink" title="4. 规约"></a>4. 规约</h2><p>在一个集合中，我们通常还会进行规约操作；</p><p>例如求一个 1 到 100 的和；</p><p>那么，此时，我们就是将一个 1 到 100 的集合规约到一个 <code>Int</code>，它是这个集合所有元素的和。</p><p>下面介绍的就是一系列规约函数。</p><h3 id="4-1-reduceLeft-op-B-T-gt-B"><a href="#4-1-reduceLeft-op-B-T-gt-B" class="headerlink" title="4.1 reduceLeft(op: (B, T) =&gt; B)"></a>4.1 <code>reduceLeft(op: (B, T) =&gt; B)</code></h3><p>顾名思义，从左到右进行规约操作；</p><p>该函数会从左到右地使用操作符 <code>op</code> 将元素连接起来。</p><p>注意 <code>op</code> 是个二元操作，它接受两个参数，返回一个值。</p><p>那么产生的结果就是一个 <strong>左斜的树</strong>：</p><p><img src="http://www.plantuml.com/plantuml/svg/RO_12i8m44Jl-OhyW8Ucnn3fpOye7bPsQGin6v8LMyH_DwqIMd1lCs-MOReiaEHnzmgd8K4SzKM_b2uN64dtUOH8BdgOWj0iLxinmg4mI8cV8m6wm84AsXZ7HlSURkGTnr-Ue_dZjGUlFf_EUcxiGPgApQgBRVTwRYjllxpKPLayEMGHmbtb6WzMlLL70Slk3m00"></p><p>需要注意的是，<code>reduceLeft</code> 不仅能返回和原有元素相同类型的值，也能返回不同类型的值；</p><p>基于这样的树结构，那么对 <code>op</code> 的类型就有了要求；</p><p>可以看到，在上面，下方的 <code>op</code> 的返回值是作为上方 <code>op</code> 的左节点；</p><p>也就是说，<code>reduceLeft</code> 要求， <strong><code>op</code> 的左边参数的类型，必须和其返回值的类型相同。</strong></p><h3 id="4-2-foldLeft-z-B-op-B-T-gt-B"><a href="#4-2-foldLeft-z-B-op-B-T-gt-B" class="headerlink" title="4.2 foldLeft(z: B)(op: (B, T) =&gt; B)"></a>4.2 <code>foldLeft(z: B)(op: (B, T) =&gt; B)</code></h3><p><code>foldLeft</code> 则是对 <code>reduceLeft</code> 的进一步泛化；</p><p><code>reduceLeft</code> 是不允许在 <strong>空列表</strong> 中执行的；</p><p>对此，<code>foldLeft</code> 提供了一个 <strong>初始值</strong> <code>z</code>；</p><p>如果列表为空，那么就返回 <code>z</code>；</p><p>它生成的树如下：</p><p><img src="http://www.plantuml.com/plantuml/svg/RO_12i8m44Jl-OhyW8Usnn3fpOye7bPsQGen6z8LMyL_DwqI8hYtcJVBCFqiaEHszGgdCK5q-gIVIkSBZAI7sK4a6prCGMYHizaPuPWPfCHtHu0sSA2CTiQnqOE72tdByPldsFxnkX-lF1-E-c5gjJI5jflEjgdrqXRUVNXkcsNrP9552Al6BHwCUgcU0kRPRm00"></p><p>这里比较有意思的就是 <code>foldLeft</code> 实际上是一个 <strong>柯里化函数</strong>；</p><p>可以先提供初始值，然后在 <code>op</code> 操作确定之后，再进行规约运算。</p><h3 id="4-3-reduceRight-op-T-B-gt-B"><a href="#4-3-reduceRight-op-T-B-gt-B" class="headerlink" title="4.3 reduceRight(op: (T, B) =&gt; B)"></a>4.3 <code>reduceRight(op: (T, B) =&gt; B)</code></h3><p>我们既然能从左边规约，当然也可以从右边规约；</p><p><code>reduceRight</code> 的作用就是， <strong>从右到左</strong> 执行规约操作；</p><p>那么，它所生成的树就是 <strong>右斜的</strong>：</p><p><img src="http://www.plantuml.com/plantuml/svg/RP312eCm44JlVaNmN0_giQHuwqU4KhPaKI7DXcIBbj9_RunjLN1FOLvcTjWcC7X-t4sc-zQ3wyHPl38Hnv965JfmA9s1tZAEV3acXBf51TxJq25eQSbY90cHAuKoS4CZoNs_awjsj7gZ9N6ysf-OntTHvfSbjJY9iLGClN7aMORXdvHONBA2gpvLSbQxpcfsnYehwq44VXgKcfXHBq5r2fegxaNDT0Ed4k-iGQlZVJy0"></p><p>同理，<code>reduceRight</code> 要求，它的右操作数的类型必须和它的返回值类型相同。</p><h3 id="4-4-foldRight-z-B-op-T-B-gt-B"><a href="#4-4-foldRight-z-B-op-T-B-gt-B" class="headerlink" title="4.4 foldRight(z: B)(op: (T, B) =&gt; B)"></a>4.4 <code>foldRight(z: B)(op: (T, B) =&gt; B)</code></h3><p>同样的，我们也具有一个 <code>foldRight</code> 函数，在集合为空时，返回初始值 <code>z</code>；</p><p>它生成的树如下：</p><p><img src="http://www.plantuml.com/plantuml/svg/RP0n3i8m34Ntdi87WA7fY8AwSOY8mIXMMod4KMBK0kBkX81AGVNev_TjkKs2KIvdLzcXYnXwEC2zWboUBPdKOo0T70vUQ9BZhY2o7HcCaSUUq6hFdZ8fY4CDnk69dERm6UUWLdhDJs-MjtkOQYCukC1HT1fdeR2SjO2BjQgOQjLKRpDlNAWRI79rf2sBaFq6DQ_X6wm65JPv-3lXKRNaRNxY4m00"></p><h3 id="4-5-left-和-right-的区别"><a href="#4-5-left-和-right-的区别" class="headerlink" title="4.5 left 和 right 的区别"></a>4.5 <code>left</code> 和 <code>right</code> 的区别</h3><p>那么 <code>left</code> 和 <code>right</code> 有什么区别呢？</p><p>实际上，高阶函数的作用范围都是 <strong>整个列表</strong>；</p><p>所以，对于满足 <strong>交换律</strong> 和 <strong>结合律</strong> 的运算，从左边执行和从右边执行的结果是 <strong>一样的</strong>，例如 <strong>加法操作</strong>；</p><p>但是，对于不满足交换律和结合律的运算，例如 <strong>减法操作</strong>；</p><p>那么这两个函数的执行结果就不一样。</p><h3 id="4-6-其他规约函数"><a href="#4-6-其他规约函数" class="headerlink" title="4.6 其他规约函数"></a>4.6 其他规约函数</h3><p>Scala 还提供了一些其他的针对数字类型的规约函数；</p><p>例如：<code>sum</code>， <code>product</code>，<code>max</code> 和 <code>min</code>；</p><p>不过，<code>sum</code> 和 <code>product</code> 只能用于数字类型，否则会报错。</p><h2 id="5-其他高阶函数"><a href="#5-其他高阶函数" class="headerlink" title="5. 其他高阶函数"></a>5. 其他高阶函数</h2><p>Scala 集合中还拥有其他的高阶函数，诸如：<code>count</code>、<code>find</code>、<code>sortWith</code> 等；</p><p>这些函数的作用比较明显，可以从它的命名中推测出其作用，在这里就不多做解释了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;高阶函数是函数式编程的一个很大的特性；&lt;/p&gt;&lt;p&gt;同时，其中集合类的高阶函数在日常的开发和使用中，占了一个很重要的位置；&lt;/p&gt;&lt;p&gt;但是，这些函数有可能会在刚接触的时候搞不懂它们的具体作用；&lt;/p&gt;&lt;p&gt;那么今天就以 &lt;code&gt;List&lt;/code&gt; 来说一说常用的高阶函数具体的作用。&lt;/p&gt;
    
    </summary>
    
      <category term="Scala" scheme="https://wafer.li/categories/Scala/"/>
    
    
      <category term="Scala" scheme="https://wafer.li/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>ofo 使用体验</title>
    <link href="https://wafer.li/Talk/ofo%20%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C/"/>
    <id>https://wafer.li/Talk/ofo 使用体验/</id>
    <published>2017-04-18T13:10:00.000Z</published>
    <updated>2017-04-18T13:34:15.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>最近因为和舍友出去看电影，终于第一次体验了一下著名的小黄车 ofo；</p><p>ofo 的确是很方便，同时也解决了所谓「最后一公里」的这个需求痛点；</p><p>但是，我不得不说，ofo 的运营团队还很年轻，一些很基本的流程问题都没搞清楚就胡乱上线功能。</p><a id="more"></a><h2 id="1-校园认证"><a href="#1-校园认证" class="headerlink" title="1. 校园认证"></a>1. 校园认证</h2><p>就比如说 ofo 的校园认证，的确对我等大学生有很大的优惠；</p><p>但是，当你校园认证不通过，而你急着用车，去进行了普通认证，那么：</p><p><strong>你就再也不能进行校园认证了!</strong></p><p>明明就是一个很容易考虑到的 Corner Case，可是 ofo 却没有处理好；</p><p>看来 ofo 还需要多招几个测试大牛。</p><h2 id="2-客服电话"><a href="#2-客服电话" class="headerlink" title="2. 客服电话"></a>2. 客服电话</h2><p>APP 上解决不了的问题，一般的用户就会想着去联系客服解决；</p><p>在这里我不得不说一声 MMP，ofo 的客服电话三天两头打不通；</p><p>在半个小时之内，我连续向其拨打了 12 通电话；但是，只有 3 通是能接通的。</p><p>第一通电话接通之后，首先是让我退押金，然后再打电话；</p><blockquote><p>这也无可厚非，毕竟银行信用卡激活就是这么要求的</p></blockquote><p>第二通电话，就有点莫名其妙了，首先接话员连普通话也说不标准；</p><p>然后说没有权限恢复我的认证状态，在经过多次撕逼之后，让我去找一个微信号去解决；</p><p>结果这个微信号居然是个 <strong>异常号！</strong></p><p>第三通电话之后，告诉我，你还有余额没有退，所以不能给你恢复认证状态。</p><p>结果呢？帮我申请了余额退款，说要到账之后才能进行下一步的操作。</p><p>所以就导致我现在，没有押金，余额还在银行流转，所以小黄车就不关我什么事了。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>可以看出，就是因为一个没有考虑到的 Corner Case ，现在我只能去骑 mobike;</p><p>想到当年即使是写小学期项目，也要跟队员讨论个大半天的 Corner Case 才开始着手编码；</p><p>可能这就是互联网 APP 泡沫生态的现状吧：</p><p>大家都去抢功能，让功能尽早上线，剩下的维护啊支持啊，都可以往后边放一放。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近因为和舍友出去看电影，终于第一次体验了一下著名的小黄车 ofo；&lt;/p&gt;&lt;p&gt;ofo 的确是很方便，同时也解决了所谓「最后一公里」的这个需求痛点；&lt;/p&gt;&lt;p&gt;但是，我不得不说，ofo 的运营团队还很年轻，一些很基本的流程问题都没搞清楚就胡乱上线功能。&lt;/p&gt;
    
    </summary>
    
      <category term="杂谈" scheme="https://wafer.li/categories/Talk/"/>
    
    
      <category term="ofo" scheme="https://wafer.li/tags/ofo/"/>
    
      <category term="杂谈" scheme="https://wafer.li/tags/Talk/"/>
    
  </entry>
  
  <entry>
    <title>Coursera 作业之函数集合</title>
    <link href="https://wafer.li/Coursera/Scala/Coursera%20%E4%BD%9C%E4%B8%9A%E4%B9%8B%E5%87%BD%E6%95%B0%E9%9B%86%E5%90%88/"/>
    <id>https://wafer.li/Coursera/Scala/Coursera 作业之函数集合/</id>
    <published>2017-04-16T17:41:00.000Z</published>
    <updated>2017-04-18T16:32:07.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>本文源码：<br><a href="https://github.com/wafer-li/scala-coursera/tree/master/funsets" target="_blank" rel="noopener">https://github.com/wafer-li/scala-coursera/tree/master/funsets</a></p></blockquote><h2 id="1-背景知识"><a href="#1-背景知识" class="headerlink" title="1. 背景知识"></a>1. 背景知识</h2><p>该作业是实现一个函数集合的相关内容。</p><p>何为函数集合？</p><p>一般来说，编程语言中的集合(Collection)都是有限集合；</p><p>但是，在数学上，还有很多的集合是无限集合，比如说 <strong>负数集</strong>；</p><p>我们有没有一种办法去表示这个集合呢？</p><a id="more"></a><p>当然有的，对于上面的负数集来说，我们如何知道一个数字是不是负数集中的元素呢？</p><p>将它与 0 进行比较，如果 x &lt; 0，那么它就是负数集的元素。</p><p>此时，<code>(x) =&gt; x == 0</code> 就成为了负数集的判断标准，我们将其作为负数集的 <strong>特征函数</strong>，通过特征函数来指代特定的集合。</p><p>于是，我们得到了函数集合的定义：<code>type Set = (Int) =&gt; Boolean</code></p><p>和它的一个基本方法 <code>contains()</code>：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">contains</span></span>(set: <span class="type">Set</span>, x : <span class="type">Int</span>) = set(x)</div></pre></td></tr></table></figure><h2 id="2-基本方法"><a href="#2-基本方法" class="headerlink" title="2. 基本方法"></a>2. 基本方法</h2><p>接下来，题目要求我们实现一些集合的基本方法。</p><h3 id="2-1-singletonSet"><a href="#2-1-singletonSet" class="headerlink" title="2.1 singletonSet()"></a>2.1 <code>singletonSet()</code></h3><p>如何返回一个只有一个元素的函数集合呢？</p><p>对于我们的特征函数来说，也就是只有给定的元素才能满足这个特征函数，这样的集合就是只存在给定元素的集合。</p><p>所以，定义如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">singletonSet</span></span>(elem: <span class="type">Int</span>): <span class="type">Set</span> = (x) =&gt; x == elem</div></pre></td></tr></table></figure><h3 id="2-2-交、并、补"><a href="#2-2-交、并、补" class="headerlink" title="2.2 交、并、补"></a>2.2 交、并、补</h3><p>这几个基本的数学集合操作并不难，只需要抓住我们特征函数就是 <code>contains()</code> 这一点就行了。</p><h3 id="2-3-filter"><a href="#2-3-filter" class="headerlink" title="2.3 filter()"></a>2.3 <code>filter()</code></h3><p>这个方法算是在 JVM 函数式语言中经常出现的集合方法；</p><p>作用就是返回满足条件的集合内的元素；</p><p>其中，一个很有趣的地方在于，<code>filter(s, p)</code> 的两个参数，虽然其表面上的类型不一样；</p><p>但是实际上他们的类型是一样的，也就是说，<code>s</code> 和 <code>p</code> 都是集合！</p><p>所以，我们只需要返回 <code>s</code> 和 <code>p</code> 的交集就行了</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">filter</span></span>(s: <span class="type">Set</span>, p: <span class="type">Int</span> =&gt; <span class="type">Boolean</span>) = intersect(s, p)</div></pre></td></tr></table></figure><h2 id="3-forAll"><a href="#3-forAll" class="headerlink" title="3. forAll()"></a>3. <code>forAll()</code></h2><p>然后，有趣的地方来了，题目要求我们实现一个 <code>forAll()</code> 方法，用来检测是否 <strong>所有的</strong> 元素都满足给定的条件。</p><p>当然，我们不能遍历全部的无限集元素；</p><p>所以，我们就采取一个区间的办法，如果在这个区间内的所有的元素都满足条件，那么我们有信心认为所有的元素都满足了条件。</p><p>在这里，同样要注意， <code>s</code> 和 <code>p</code> 的类型实际上是一样的！</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">forall</span></span>(s: <span class="type">Set</span>, p: <span class="type">Int</span> =&gt; <span class="type">Boolean</span>): <span class="type">Boolean</span> = &#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">iter</span></span>(a: <span class="type">Int</span>): <span class="type">Boolean</span> = &#123;</div><div class="line">    <span class="keyword">if</span> (a &gt; bound) <span class="literal">true</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (diff(s, p)(a)) <span class="literal">false</span></div><div class="line">    <span class="keyword">else</span> iter(a + <span class="number">1</span>)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  iter(-bound)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="4-exists"><a href="#4-exists" class="headerlink" title="4. exists()"></a>4. <code>exists()</code></h2><p>本题第二难的地方来了，题目要求实现一个 <code>exists()</code> 函数，用于检测 <strong>是否存在</strong> 一个元素满足给定的条件。</p><p>按说这个还不是很难，但是，题目要求使用 <code>forAll()</code> 进行实现。</p><p>按照我的早就丢给高中老师的逻辑关系知识，『所有』和 『存在』好像并无什么联系。</p><p>不过，在论坛上有人提醒了我，可以使用 <strong>间接法</strong>；</p><p>也就是说，我们可以考虑一下 <strong>不存在</strong> 的情况；</p><p>也就是说，对于 <strong>所有的</strong> 元素，都 <strong>不满足</strong> 给定的条件；</p><p>到此，我们就可以利用上之前实现的 <code>forAll()</code> 了。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">exists</span></span>(s: <span class="type">Set</span>, p: <span class="type">Int</span> =&gt; <span class="type">Boolean</span>) =</div><div class="line">    !forAll(s, (elem) =&gt; !p(elem))</div></pre></td></tr></table></figure><p>但是，这显得太长了，能不能缩短到只有一行代码呢？</p><p>之前提到，<code>s</code> 和 <code>p</code> 的类型实际上是一样的，也就是说，我们可以重用上面的方法来对 <code>s</code> 和 <code>p</code> 进行处理。</p><p>那么，<code>s</code> 和 <code>p</code> 在不存在的情况下，是什么样的关系呢？</p><p>我们可以从上面的结论出发继续思考：</p><p>对于所有的元素，都不满足给定条件 $\Rightarrow$ 对于 <code>s</code> 的所有元素，都位于「在 <code>s</code> 且不在 <code>p</code> 中」这个集合内</p><p>所以，我们得到了一个简便的写法：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">exists</span></span>(s: <span class="type">Set</span>, p: <span class="type">Int</span> =&gt; <span class="type">Boolean</span>) = !forAll(s, diff(s, p))</div></pre></td></tr></table></figure><h2 id="5-map"><a href="#5-map" class="headerlink" title="5. map()"></a>5. <code>map()</code></h2><p>本题最难的部分来了，<code>map()</code> 函数，用于对集合中的元素进行变换操作，返回一个变换过后的新集合。</p><p>鉴于我们的集合是一个 <strong>函数</strong>，那么 <code>map()</code> 方法也就是返回一个 <strong>新函数</strong>，用来检测参数是否满足新变换过后的条件。</p><p>因为 <code>map()</code> 函数是针对原有集合进行变换，所以，我们应该基于原有集合生成上面的新函数。</p><p>也就是说，对于原有集合来说，是否存在一个元素，它变换过后的数值和传入的参数相等：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">map</span></span>(s: <span class="type">Set</span>, f: <span class="type">Int</span> =&gt; <span class="type">Int</span>) =</div><div class="line">    x =&gt; exists(s, elem =&gt; x==f(elem))</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;本文源码：&lt;br&gt;&lt;a href=&quot;https://github.com/wafer-li/scala-coursera/tree/master/funsets&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/wafer-li/scala-coursera/tree/master/funsets&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;1-背景知识&quot;&gt;&lt;a href=&quot;#1-背景知识&quot; class=&quot;headerlink&quot; title=&quot;1. 背景知识&quot;&gt;&lt;/a&gt;1. 背景知识&lt;/h2&gt;&lt;p&gt;该作业是实现一个函数集合的相关内容。&lt;/p&gt;&lt;p&gt;何为函数集合？&lt;/p&gt;&lt;p&gt;一般来说，编程语言中的集合(Collection)都是有限集合；&lt;/p&gt;&lt;p&gt;但是，在数学上，还有很多的集合是无限集合，比如说 &lt;strong&gt;负数集&lt;/strong&gt;；&lt;/p&gt;&lt;p&gt;我们有没有一种办法去表示这个集合呢？&lt;/p&gt;
    
    </summary>
    
      <category term="Coursera" scheme="https://wafer.li/categories/Coursera/"/>
    
      <category term="Scala" scheme="https://wafer.li/categories/Coursera/Scala/"/>
    
    
      <category term="Scala" scheme="https://wafer.li/tags/Scala/"/>
    
      <category term="Coursera" scheme="https://wafer.li/tags/Coursera/"/>
    
  </entry>
  
  <entry>
    <title>Scala 模式匹配</title>
    <link href="https://wafer.li/Scala/Scala%20%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/"/>
    <id>https://wafer.li/Scala/Scala 模式匹配/</id>
    <published>2017-04-15T18:07:00.000Z</published>
    <updated>2017-04-18T16:32:07.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>模式匹配，是 Scala 相比 Java 在类型上的一个很好地改进；</p><p>通过引入模式匹配，消除了 Java 中常见的类型检测和强制转换(cast)；</p><p>拥有更高的安全性</p><a id="more"></a><h2 id="1-问题背景"><a href="#1-问题背景" class="headerlink" title="1. 问题背景"></a>1. 问题背景</h2><p>模式匹配主要解决的问题就是一个树状的类型依赖图；</p><p>比如算数表达式，由文法可知，它是具有树状依赖关系的：</p><script type="math/tex;mode=display">\begin{aligned}E & \rightarrow \\& E+E \ | \\& E-E \ | \\& E*E \ | \\& E/E \ | \\& (E) \ | \\&  i\end{aligned}</script><p>所以，我们可以使用如下的类来表示一个算术表达式：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Expr</span></span></div><div class="line"><span class="class"><span class="title">class</span> <span class="title">Number</span>(<span class="params">n: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Expr</span></span></div><div class="line"><span class="class"><span class="title">class</span> <span class="title">Sum</span>(<span class="params">leftOp: <span class="type">Expr</span>, rightOp: <span class="type">Expr</span></span>) <span class="keyword">extends</span> <span class="title">Expr</span></span></div></pre></td></tr></table></figure><p>那么当我们需要使用类似 <code>eval()</code> 的方法时，该如何实现这个方法呢？</p><h2 id="2-各有缺陷的解法"><a href="#2-各有缺陷的解法" class="headerlink" title="2. 各有缺陷的解法"></a>2. 各有缺陷的解法</h2><h3 id="2-1-使用类型说明"><a href="#2-1-使用类型说明" class="headerlink" title="2.1 使用类型说明"></a>2.1 使用类型说明</h3><p>一个暴力解决的思路就是为 <code>Expr</code> 添加上一个类型的说明，即：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Expr</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNumber</span></span>: <span class="type">Boolean</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSum</span></span>: <span class="type">Boolean</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>不过，随着以后算术表达式的种类越来越多，比如加入了乘法和除法；</p><p>那么，这个实现会导致方法数的平方级别爆炸。</p><blockquote><p>每增加一个种类，都需要对现有的所有类进行方法的增加</p></blockquote><p>显然，使用类型说明(classification) 是不行的。</p><h3 id="2-2-类型检测和造型"><a href="#2-2-类型检测和造型" class="headerlink" title="2.2 类型检测和造型"></a>2.2 类型检测和造型</h3><p>Java 这门面向对象语言对此则有比较好的解法：</p><p>通过对对象进行类型检测和强制转换(cast)；</p><p>由于强制转换后类型得到限定，所以就可以分别进行检测工作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">eval</span><span class="params">(Expr e)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> Number) &#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> Sum) &#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>相对的，Scala 也具有这种语法特性：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">eval</span></span>(e: <span class="type">Expr</span>): <span class="type">Int</span> = &#123;</div><div class="line">    <span class="keyword">if</span> (e.isInstanceOf[<span class="type">Number</span>]) &#123;</div><div class="line">        e.asInstanceOf[<span class="type">Number</span>].numberValue</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (e.isInstanceOf[<span class="type">Sum</span>]) &#123;</div><div class="line">        <span class="keyword">val</span> sum = e.asInstanceOf[<span class="type">Sum</span>]</div><div class="line">        eval(sum.leftOp) + eval(sum.rightOp)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>不过，这种方法由于是比较低层级的，具有指令性特征；</p><p>同时，过多的类型检测和强制转换也造成了诸多不安全因素：</p><p>如果运行时类型改变了，那么很可能会出现异常。</p><h3 id="2-3-面向对象的解法"><a href="#2-3-面向对象的解法" class="headerlink" title="2.3 面向对象的解法"></a>2.3 面向对象的解法</h3><p>现在我们来选择一个更高级的解决办法，通过利用多态特性，来解决此类问题。</p><p>相比将 <code>eval()</code> 作为一个外部的函数，不如将其作为类的一个内部方法：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Expr</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eval</span></span>: <span class="type">Int</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Number</span>(<span class="params">n: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Expr</span> </span>&#123;</div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">eval</span></span>: <span class="type">Int</span> = n</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sum</span>(<span class="params">leftOp: <span class="type">Expr</span>, rightOp: <span class="type">Expr</span></span>) <span class="keyword">extends</span> <span class="title">Expr</span> </span>&#123;</div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">eval</span></span>: <span class="type">Int</span> = leftOp.eval + rightOp.eval</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>通过语言自带的多态特性，我们可以使用到具体的 <code>eval()</code>；</p><p>这样就能很优雅的解决上面的问题；</p><p>不过，这种写法有个缺陷；</p><p>如果我们需要添加一个新的方法，例如 <code>show()</code>，则需要更改所有的现存类；</p><p>而且，如果我们需要一个化简操作，它不能仅仅只考虑一个节点，而需要多个节点综合考虑；</p><p>这样，我们可以发现，即使使用多态，也没能解决我们所有的问题</p><h2 id="3-模式匹配"><a href="#3-模式匹配" class="headerlink" title="3. 模式匹配"></a>3. 模式匹配</h2><p>在 Scala 中，具有一个很常用的语法用于解决这类问题，即 <strong>模式匹配</strong>；</p><p>模式匹配使用 <code>match</code> 定义：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">e <span class="keyword">match</span> &#123;</div><div class="line">    <span class="keyword">case</span> <span class="type">Number</span>(n) =&gt; n</div><div class="line">    <span class="keyword">case</span> <span class="type">Sum</span>(left, right) =&gt; left.eval + right.eval</div><div class="line">    <span class="keyword">case</span> anotherE =&gt; anotherE.eval</div><div class="line">    <span class="keyword">case</span> _ =&gt; <span class="comment">//Ignore</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>match</code> 语句块中，包含多个 <code>case</code> 语句；</p><p>每个 <code>case</code> 语句包括：<code>case</code> 关键字，模式和表达式，模式和表达式使用 <code>=&gt;</code> 分隔。</p><p>乍一看，这个语法和 C++/Java 中的 <code>switch</code> 很像；</p><p>不过，它进行了大幅度的强化，主要就是放宽了对选择器的限制：</p><p>现在 <code>case</code> 语句可以是：</p><ol><li>构造器</li><li>变量</li><li>常量</li><li>通配符 <code>_</code></li></ol><p>其中：</p><ul><li>构造器必须是 <code>case class</code></li><li>变量必须以小写字母开头</li><li>常量必须以大写字母开头</li></ul><h2 id="4-匹配处理"><a href="#4-匹配处理" class="headerlink" title="4. 匹配处理"></a>4. 匹配处理</h2><p>首先，如果没有 <code>case</code> 能够匹配选择器，则会抛出异常。</p><p>然后，如果匹配成功，会将 <strong>整个 <code>match</code> 语句</strong> 替换为 <code>case</code> 的 right-hand side。</p><p>对于不同的情况，则是：</p><ul><li>构造器，将参数绑定 <code>case</code> 中的形参</li><li>变量，对变量进行赋值</li><li>常量，检测和常量的相等性</li></ul><h2 id="5-Case-Class"><a href="#5-Case-Class" class="headerlink" title="5. Case Class"></a>5. Case Class</h2><p>Case Class 是一种特殊的类，通常用于进行模式匹配；</p><p>但是，它还具有一些其他的有用特性：</p><p>它不需要 <code>new</code> 关键字进行构建：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="type">Person</span>(name: <span class="type">String</span>, age: <span class="type">Int</span>)</div><div class="line"></div><div class="line"><span class="keyword">val</span> person = <span class="type">Person</span>(<span class="string">"hehe"</span>, <span class="number">18</span>)</div></pre></td></tr></table></figure><p>它的主要构造器参数直接可以作为类的字段：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> name = person.name</div></pre></td></tr></table></figure><p>它的相等性判断是结构化的，当它所有的成员都相等时，它就相等，和引用无关；</p><p>同时还提供了 <code>toString()</code> 方法：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> firstSms = <span class="type">SMS</span>(<span class="string">"12345"</span>, <span class="string">"Hello!"</span>)</div><div class="line"><span class="keyword">val</span> secondSms = <span class="type">SMS</span>(<span class="string">"12345"</span>, <span class="string">"Hello!"</span>)</div><div class="line"></div><div class="line"><span class="keyword">if</span> (firstSms == secondSms) &#123;</div><div class="line">  println(<span class="string">"They are equal!"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line">println(<span class="string">"SMS is: "</span> + firstSms)</div></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">They are equal!</div><div class="line">SMS is: SMS(12345, Hello!)</div></pre></td></tr></table></figure><h2 id="6-模式匹配的解决办法"><a href="#6-模式匹配的解决办法" class="headerlink" title="6. 模式匹配的解决办法"></a>6. 模式匹配的解决办法</h2><p>使用模式匹配，我们不仅可以对单个节点进行解析工作；</p><p>同时，我们还可以查看节点之间的关系：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Expr</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">eval</span></span>: <span class="type">Int</span> = <span class="keyword">this</span> <span class="keyword">match</span> &#123;</div><div class="line">    <span class="keyword">case</span> <span class="type">Number</span>(n) =&gt; n</div><div class="line">    <span class="keyword">case</span> <span class="type">Sum</span>(left, right) =&gt; left.eval + right.eval</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">show</span></span>: <span class="type">String</span> = <span class="keyword">this</span> <span class="keyword">match</span> &#123;</div><div class="line">    <span class="keyword">case</span> <span class="type">Number</span>(n) =&gt; n.toString</div><div class="line">    <span class="keyword">case</span> <span class="type">Sum</span>(left, right) =&gt; left.show + <span class="string">"+"</span> + right.show</div><div class="line">    <span class="keyword">case</span> <span class="type">Prod</span>(left, right) =&gt;</div><div class="line">      <span class="function"><span class="keyword">def</span> <span class="title">f</span></span>(e: <span class="type">Expr</span>): <span class="type">String</span> = e <span class="keyword">match</span> &#123;</div><div class="line">        <span class="keyword">case</span> <span class="type">Sum</span>(l, r) =&gt; <span class="string">"("</span> + l.show + <span class="string">"+"</span> + r.show + <span class="string">")"</span></div><div class="line">        <span class="keyword">case</span> _ =&gt; e.show</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      f(left) + <span class="string">"*"</span> + f(right)</div><div class="line">    <span class="keyword">case</span> <span class="type">Var</span>(x) =&gt; x</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Number</span>(<span class="params">n: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Expr</span></span></div><div class="line"><span class="class"></span></div><div class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Sum</span>(<span class="params">left: <span class="type">Expr</span>, right: <span class="type">Expr</span></span>) <span class="keyword">extends</span> <span class="title">Expr</span></span></div><div class="line"><span class="class"></span></div><div class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Var</span>(<span class="params">x: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Expr</span></span></div><div class="line"><span class="class"></span></div><div class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Prod</span>(<span class="params">left: <span class="type">Expr</span>, right: <span class="type">Expr</span></span>) <span class="keyword">extends</span> <span class="title">Expr</span></span></div></pre></td></tr></table></figure><p>上面的 <code>show</code> 方法通过查看子节点情况，实现了优先级区分:</p><p><img src="https://ww1.sinaimg.cn/large/006tNc79ly1fenynuh6prj316g09g763.jpg" alt=""></p><h2 id="7-和多态方法的区别"><a href="#7-和多态方法的区别" class="headerlink" title="7. 和多态方法的区别"></a>7. 和多态方法的区别</h2><p>那么模式匹配相比面向对象方法有什么优势呢？</p><p>如果你倾向于在现有的类架构上添加 <strong>通用的方法</strong>，那么采用模式匹配会更好；</p><p>因为模式匹配只需要修改匹配代码，而不需要在各个子类重新实现方法。</p><p>但是，如果你倾向于增加子类，而不是增加通用的处理方法，那么采用多态方法会更好；</p><p>原因是采用多态架构只需要建立一个子类，而重载方法这些繁琐工作 IDE 会帮你做好；</p><p>而模式匹配还需要在顶层代码中进行修改</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;模式匹配，是 Scala 相比 Java 在类型上的一个很好地改进；&lt;/p&gt;&lt;p&gt;通过引入模式匹配，消除了 Java 中常见的类型检测和强制转换(cast)；&lt;/p&gt;&lt;p&gt;拥有更高的安全性&lt;/p&gt;
    
    </summary>
    
      <category term="Scala" scheme="https://wafer.li/categories/Scala/"/>
    
    
      <category term="Scala" scheme="https://wafer.li/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>打字训练网站</title>
    <link href="https://wafer.li/Talk/%E6%89%93%E5%AD%97%E8%AE%AD%E7%BB%83%E7%BD%91%E7%AB%99/"/>
    <id>https://wafer.li/Talk/打字训练网站/</id>
    <published>2017-04-15T04:37:00.000Z</published>
    <updated>2017-04-15T14:32:18.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>买了新键盘之后就想试一试它的威力，所以就找了一个打字训练网站来打字；</p><p>在知乎上找了一圈，结果就找到了 <a href="http://www.keybr.com/practice" target="_blank" rel="noopener">这个</a>；</p><p>练了一圈的感受就是： <strong>左手好累啊！！！</strong></p><p>基本上单词表里面最长的 S 和 T 都在左手了，而我又习惯使用左手来按空格键；</p><p>结果就是我的左手现在累得不成样子了；</p><p>不过最后成绩也不怎么样，大概也就 50 多 wpm 吧，相信大家一定会比我打字快的。</p><p><img src="https://ww4.sinaimg.cn/large/006tNc79ly1fenqgox6a5j317a0jejtu.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;买了新键盘之后就想试一试它的威力，所以就找了一个打字训练网站来打字；&lt;/p&gt;
      
    
    </summary>
    
      <category term="杂谈" scheme="https://wafer.li/categories/Talk/"/>
    
    
      <category term="杂谈" scheme="https://wafer.li/tags/Talk/"/>
    
      <category term="打字" scheme="https://wafer.li/tags/Typing/"/>
    
      <category term="Typing training" scheme="https://wafer.li/tags/Typing-training/"/>
    
  </entry>
  
  <entry>
    <title>Realforce 87u</title>
    <link href="https://wafer.li/Buying/Realforce%2087u/"/>
    <id>https://wafer.li/Buying/Realforce 87u/</id>
    <published>2017-04-11T04:28:00.000Z</published>
    <updated>2018-01-08T05:35:57.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>最近终于下定决心来买这个键盘了。</p><p>主要说说使用感受吧</p><p>2018/1/8 更新部分内容</p><a id="more"></a><h2 id="1-手感"><a href="#1-手感" class="headerlink" title="1. 手感"></a>1. 手感</h2><p>我买的这个是静音版，手感介于红轴和茶轴之间，就是稍微软一点的茶轴，按起来有种噗噗的感觉；</p><p>显然，打击感是一点也没有了，不过真的有种揉胸的感觉。</p><p>不过这个键盘的优点在于：由于是分区压力，所以能极大地缓解小拇指的压力；</p><p>之前我用的 filco 青轴，最后有 40% 的概率用小拇指打不出 shift 按键；</p><p>这也是为什么我要买一个新键盘的原因。</p><h2 id="2-特色功能"><a href="#2-特色功能" class="headerlink" title="2. 特色功能"></a>2. 特色功能</h2><p>Realforce 87u 有个特色功能，就是把没有什么卵用的 Scroll Lock 变成了 NumLock；</p><p>也就是说，这个键盘有 <strong>小键盘</strong> 的功能！</p><p>这是我在 87 键盘上从来没有见到过的。</p><p>不过在 Mac 上，这个 NumLock 就失效了；</p><blockquote><p>2018/1/8 补充：<br><strong>可惜的是，自从升级到 High Sierra 之后下面的方法就不管用了</strong><br><strong>不过吧，反正我也不怎么用这个小键盘，先就这样吧。</strong></p></blockquote><p>需要使用 Karabiner 进行键位修改。</p><p>首先下载 Karabiner，这里有个小问题就是 <code>brew cask</code> 会报 <code>Operation not permitted</code> 的错误；</p><p>所以最好还是自己下载镜像安装为好。</p><p>随后点击 <code>Open private.xml</code>：</p><p><img src="https://ww1.sinaimg.cn/large/006tNbRwly1feindhtm6kj318g0zoagn.jpg" alt=""></p><p>然后加上一条自定义配置<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="[https://www.zhihu.com/question/39522431/answer/81753723](https://www.zhihu.com/question/39522431/answer/81753723)">[1]</span></a></sup>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">item</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Map Realforce Numlock to OSX Numlock function<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">identifier</span>&gt;</span>private.pc_numlock_to_mac_numlock<span class="tag">&lt;/<span class="name">identifier</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">autogen</span>&gt;</span>__KeyToKey__ KeyCode::KEYPAD_CLEAR, KeyCode::VK_IOHIKEYBOARD_TOGGLE_NUMLOCK<span class="tag">&lt;/<span class="name">autogen</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">item</span>&gt;</span></div></pre></td></tr></table></figure><p>最后再到 <code>Change Key</code> 启用就可以了。</p><p><img src="https://ww3.sinaimg.cn/large/006tNbRwly1feingd0pg8j30ts06qabi.jpg" alt=""></p><h2 id="3-缺点"><a href="#3-缺点" class="headerlink" title="3. 缺点"></a>3. 缺点</h2><p>目前遇到的缺点只有一个：</p><p>就是它的导线槽太紧了，几乎是死死卡住键盘的线缆；</p><p>结果我摆弄的时候需要用很大的力气才能把线弄出来，希望以后不要弄烂为好；</p><blockquote><p>小贴士：弄的时候长痛不如短痛，直接一个猛劲可以更快的减轻线缆的损伤</p></blockquote><p>其次就是居然不配理线用的尼龙扎带，差评！</p><h2 id="4-为什么不买-HHKB"><a href="#4-为什么不买-HHKB" class="headerlink" title="4. 为什么不买 HHKB"></a>4. 为什么不买 HHKB</h2><p>不喜欢 HHKB 的配列。</p><p>我就爱用 <code>Caps Lock</code> 🙃</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>如果你很喜欢用青轴，很享受用青轴的打击感，请直接买青轴，静电容不适合你；</p><p>如果你用青轴感觉到力不从心，但是钱不够，请买茶轴或者红轴；</p><p>如果你有点闲钱，而且比较有意向打造一个良好的打字环境，那么可以考虑买一个静电容；</p><p>最后来一张玉照：</p><p><img src="https://ww3.sinaimg.cn/large/006tNbRwly1feinxuuro5j31kw23ve83.jpg" alt=""></p><h2 id="6-补充"><a href="#6-补充" class="headerlink" title="6. 补充"></a>6. 补充</h2><p>上传一张 Switch 的说明书，说不定以后会用到。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fn953gfiazj31kw2t5h2v.jpg" alt=""></p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none;padding-left:0;margin-left:40px"><li id="fn:1"><span style="display:inline-block;vertical-align:top;padding-right:10px;margin-left:-40px">1.</span><span style="display:inline-block;vertical-align:top;margin-left:10px"><a href="https://www.zhihu.com/question/39522431/answer/81753723" target="_blank" rel="noopener">https://www.zhihu.com/question/39522431/answer/81753723</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近终于下定决心来买这个键盘了。&lt;/p&gt;&lt;p&gt;主要说说使用感受吧&lt;/p&gt;&lt;p&gt;2018/1/8 更新部分内容&lt;/p&gt;
    
    </summary>
    
      <category term="买买买" scheme="https://wafer.li/categories/Buying/"/>
    
    
      <category term="买买买" scheme="https://wafer.li/tags/Buying/"/>
    
      <category term="键盘" scheme="https://wafer.li/tags/Keyboard/"/>
    
      <category term="Realforce" scheme="https://wafer.li/tags/Realforce/"/>
    
  </entry>
  
  <entry>
    <title>Hexo Experience</title>
    <link href="https://wafer.li/Hexo/Hexo%20Experience/"/>
    <id>https://wafer.li/Hexo/Hexo Experience/</id>
    <published>2017-04-08T16:56:00.000Z</published>
    <updated>2017-04-09T05:57:11.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>这是我折腾 Hexo 博客框架的经验；</p><p>希望能给后来者以启迪。</p><a id="more"></a><h2 id="2-我所需要的功能"><a href="#2-我所需要的功能" class="headerlink" title="2. 我所需要的功能"></a>2. 我所需要的功能</h2><p>虽然，现今，网上已经很多教你如何一步一步地搭建 Hexo 博客，也有很多人踩过很多坑；</p><p>不过，对于我的一些要求，仍然有很多的方面未能解决。</p><p>我主要需要的功能一共有四个：</p><ol><li>数学公式渲染</li><li>PlantUML 图</li><li>TODO List</li><li>Footnotes</li></ol><h2 id="3-数学公式渲染"><a href="#3-数学公式渲染" class="headerlink" title="3. 数学公式渲染"></a>3. 数学公式渲染</h2><p>这个倒是有很多人发了很多博客，然后也解决了一些问题。</p><p>主要就是 <a href="https://www.npmjs.com/package/hexo-renderer-marked" target="_blank" rel="noopener"><code>hexo-renderer-marked</code></a> 中，把 MathJax 中的 <code>_</code> 解析渲染成了斜体；</p><p>这样，就造成了解析错误；</p><p>同时，对于多行的数学公式，也存在很多问题。</p><p>经过一番倒腾，我的最终决定是使用 <a href="https://www.npmjs.com/package/hexo-renderer-kramed" target="_blank" rel="noopener"><code>hexo-renderer-karmed</code></a> 代替原先官方自带的 <a href="https://www.npmjs.com/package/hexo-renderer-marked" target="_blank" rel="noopener"><code>hexo-renderer-marked</code></a></p><p>对于另外的渲染器，它们主要的缺点有：</p><ul><li><a href="https://www.npmjs.com/package/hexo-renderer-pandoc" target="_blank" rel="noopener"><code>hexo-renderer-pandoc</code></a> 过于沉重</li><li><a href="https://www.npmjs.com/package/hexo-renderer-markdown-it" target="_blank" rel="noopener"><code>hexo-renderer-markdown-it</code></a> 不支持 NexT 主题的 『Read More』</li></ul><p>所以，最后选择使用 <a href="https://www.npmjs.com/package/hexo-renderer-markdown-it" target="_blank" rel="noopener"><code>hexo-renderer-karmed</code></a>；</p><p>不过这个插件在某些时候也存在问题；</p><p>在<a href="http://xudongyang.coding.me/math-in-hexo/" target="_blank" rel="noopener">这里</a>有一个 workaround</p><h2 id="4-PlantUML"><a href="#4-PlantUML" class="headerlink" title="4. PlantUML"></a>4. PlantUML</h2><p>平时我主要使用的 UML 绘图工具就是这个；</p><p>主要是因为我用 Atom 上面的 <code>markdown-preview-enhanced</code> 能够实时展现 PlantUML 图。</p><p>Hexo 插件列表中，也存在一个 PlantUML 的插件，<code>hexo-tag-plantuml</code>；</p><p>不过这个是 <code>tag</code> 插件，如果使用这个的话，我就需要使用标签来定义 UML；</p><p>而不能使用 markdown 原生的 code fence；</p><p>此时，我的 <code>markdown-preview-enhanced</code> 也会不起作用；</p><p>所以就只能自造轮子：自己实现了一个 <code>filter</code> 插件，用来将 code fence 转换成 PlantUML 图。</p><p>插件源码在<a href="https://github.com/wafer-li/hexo-filter-plantuml" target="_blank" rel="noopener">这里</a></p><h2 id="5-TODO-List"><a href="#5-TODO-List" class="headerlink" title="5. TODO List"></a>5. TODO List</h2><p>这个是比较神奇的：</p><p>之前选择的 <code>kramed</code> 没有这个功能，而 <code>marked</code> 有这个功能；</p><p>不过幸好代码量不多，可以直接将 <a href="https://github.com/hexojs/hexo-renderer-marked/pull/32" target="_blank" rel="noopener">PR</a> 中的改动合并到 <code>kramed</code> 中。</p><h2 id="6-Footnotes"><a href="#6-Footnotes" class="headerlink" title="6. Footnotes"></a>6. Footnotes</h2><p>这个实际上是一个 Reference 的功能；</p><p>这个是目前最容易而且也没有坑的；</p><p>直接安装 <a href="https://www.npmjs.com/package/hexo-reference" target="_blank" rel="noopener"><code>hexo-reference</code></a> 插件即可。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://ijiaober.github.io/categories/hexo/" target="_blank" rel="noopener">Goon X 的 Hexo 合集</a></p><p><a href="http://2wildkids.com/2016/10/06/%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86Hexo%E5%92%8CMathJax%E7%9A%84%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">如何处理Hexo和MathJax的兼容问题</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h2&gt;&lt;p&gt;这是我折腾 Hexo 博客框架的经验；&lt;/p&gt;&lt;p&gt;希望能给后来者以启迪。&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="https://wafer.li/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://wafer.li/tags/Hexo/"/>
    
      <category term="Blog" scheme="https://wafer.li/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>Scala 泛型和变形</title>
    <link href="https://wafer.li/Scala/Scala%20%E6%B3%9B%E5%9E%8B%E5%92%8C%E5%8F%98%E5%BD%A2/"/>
    <id>https://wafer.li/Scala/Scala 泛型和变形/</id>
    <published>2017-04-07T15:00:00.000Z</published>
    <updated>2017-04-18T16:32:07.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>泛型是多态的一个重要组成部分，通过运行时确定的类型来加载对应的类代码；</p><p>作为一个面向对象语言，Scala 同样具有泛型功能。</p><a id="more"></a><h2 id="2-定义"><a href="#2-定义" class="headerlink" title="2. 定义"></a>2. 定义</h2><p>与 Java 不同，Scala 的泛型是使用方括号 <code>[]</code> 定义的：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span>[<span class="type">T</span>] </span>&#123; ... &#125;</div></pre></td></tr></table></figure><p>同样，在泛型方法的定义中，泛型参数的位置也和 Java 不一样：</p><p>Java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; listOf()</div></pre></td></tr></table></figure><p>Scala:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">listOf</span></span>[<span class="type">T</span>]()</div></pre></td></tr></table></figure><h2 id="3-上界和下界"><a href="#3-上界和下界" class="headerlink" title="3. 上界和下界"></a>3. 上界和下界</h2><p>这个方面，Scala 和 Java 有些许不同；</p><p>首先，在定义方面，Scala 使用两个特殊的符号表示上下界：</p><p><code>A &lt;: B</code> 表示 A 是 B 的子类，也就是 B 是 A 的上界；</p><p><code>A &gt;: B</code> 表示 A 是 B 的超类，也就是 B 是 A 的下界。</p><p>而 Java 使用 <code>extends</code> 关键字来说明。</p><p>其次，Scala 中，可以使用超类限定类型参数；</p><p>而 Java 只能使用 <code>extends</code> 即子类限定类型参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// Scala</div><div class="line">[U &gt;: T]</div><div class="line"></div><div class="line">// Java</div><div class="line">U super T // ERROR!</div></pre></td></tr></table></figure><h2 id="4-逆变和协变"><a href="#4-逆变和协变" class="headerlink" title="4. 逆变和协变"></a>4. 逆变和协变</h2><p>关于逆变和协变，Scala 相比于 Java 中的 <strong>使用声明</strong>，还可以在定义中指明协变和逆变。</p><h3 id="4-1-名词解释"><a href="#4-1-名词解释" class="headerlink" title="4.1 名词解释"></a>4.1 名词解释</h3><p>如果 <code>A &lt;: B</code> (A 是 B 的子类)，那么对于类 <code>C</code> 来说：</p><ol><li>$C[A] &lt;: C[B]$ =&gt; C 是协变(covariant)的</li><li>$C[A] &gt;: C[B]$ =&gt; C 是逆变(contravariant)的</li><li>$C[A]$ 和 $C[B]$ 没有继承关系 =&gt; C 是不变(nonvariant) 的</li></ol><p>对 Java 而言，<code>? extends T</code> 提供了协变特性；</p><p><code>? super T</code> 提供了逆变特性</p><h3 id="4-2-定义中指明可变性"><a href="#4-2-定义中指明可变性" class="headerlink" title="4.2 定义中指明可变性"></a>4.2 定义中指明可变性</h3><p>这是 Scala 和 Kotlin 中相对于 Java 的一个改进，可以在 <strong>类定义</strong> 中指明泛型可变性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// Scala</div><div class="line">class List[+T]</div><div class="line"></div><div class="line">// Kotlin</div><div class="line">class List&lt;out T&gt;</div></pre></td></tr></table></figure><p>此时，指明了 <code>List</code> 是 <strong>协变的</strong>，也就是说，<code>List[String]</code> 是 <code>List[Object]</code> 的子类。</p><p>同理，下面的写法指明了逆变性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// Scala</div><div class="line">class List[-T]</div><div class="line"></div><div class="line">// Kotlin</div><div class="line">class List&lt;in T&gt;</div></pre></td></tr></table></figure><p>当不使用 <code>+</code>、<code>-</code> 号修饰时，就是不变(nonvariant)的</p><h3 id="4-3-函数"><a href="#4-3-函数" class="headerlink" title="4.3 函数"></a>4.3 函数</h3><p>事实上，在 Scala 中，函数也是一个对象；</p><p><code>def</code> 语句声明的函数会被转化成一个 <code>FunctionN&lt;-T, +U&gt;</code> 类：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Function1</span>[-<span class="type">T</span>, +<span class="type">U</span>] </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(param: <span class="type">T</span>): <span class="type">U</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>通过 <code>apply</code> 函数来进行函数的调用。</p><p>我们可以看到，函数参数是逆变的，但是返回类型是协变的；</p><p>这是为什么呢？</p><p>实际上，这是里氏法则的应用：</p><p>如果 $A_2 &lt;: A_1$ 且 $B_1 &lt;: B_2$，那么对于 $A_1 \Rightarrow B_1$ 和 $A_2 \Rightarrow B_2$ 来说：</p><p>$A_1$ 所接受的范围比 $A_2$ 广，所以使用 $A_1$ 作为参数，可以接受 $A_2$；</p><p>$B_1$ 比 $B_2$ 要更加严格，所以返回 $B_1$ 就相当于肯定能返回 $B_2$；</p><p>此时，因为 $A_1 \Rightarrow B_1$ 的形参和返回值都满足 $A_2 \Rightarrow B_2$ 的要求；</p><p>我们就可以使用前者替代后者，也就是说，此时：</p><script type="math/tex;mode=display">A_1 \Rightarrow B_1 <: A_2 \Rightarrow B_2</script><p>那么说明， <strong>函数形参是逆变的，而返回值是协变的</strong></p><p>Scala 会自动检查函数的泛型变形，以满足上面的要求。</p><h3 id="4-4-协变的函数形参"><a href="#4-4-协变的函数形参" class="headerlink" title="4.4 协变的函数形参"></a>4.4 协变的函数形参</h3><p>函数上面的变形要求是为了保证数据的一致性；</p><p>如果你的函数不进行数据的更改操作，那么事实上是可以将形参声明为协变的；</p><p>不过，鉴于 Scala 的泛型检查，它禁止了这种方法的出现；</p><p>此时，我们可以使用泛型下界，来让我们的变形满足 Scala 的要求：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">concat</span></span>[<span class="type">U</span> &gt;: <span class="type">T</span>](elem: <span class="type">U</span>): <span class="type">List</span>[<span class="type">U</span>] = <span class="keyword">new</span> <span class="type">Cons</span>(elem, <span class="type">Empty</span>)</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;p&gt;泛型是多态的一个重要组成部分，通过运行时确定的类型来加载对应的类代码；&lt;/p&gt;&lt;p&gt;作为一个面向对象语言，Scala 同样具有泛型功能。&lt;/p&gt;
    
    </summary>
    
      <category term="Scala" scheme="https://wafer.li/categories/Scala/"/>
    
    
      <category term="Scala" scheme="https://wafer.li/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Java 集合框架</title>
    <link href="https://wafer.li/Java/Java%20%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    <id>https://wafer.li/Java/Java 集合框架/</id>
    <published>2017-04-02T15:00:00.000Z</published>
    <updated>2017-04-14T11:56:41.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>任何语言都会提供一套基础的数据结构的库；</p><p>Java 也不例外，而且提供了一个庞大的数据结构库，有时对于它们之间的选择让人很困惑。</p><p>这里就来简单说明一下 Java 的 Collection 和基本的 Collection 数据结构</p><a id="more"></a><h2 id="2-接口关系图"><a href="#2-接口关系图" class="headerlink" title="2. 接口关系图"></a>2. 接口关系图</h2><p>和现代的数据结构类库一样，Java 采用了 Collection 接口和实现相分离的策略。</p><p>通过这样，来做到使用一个统一的接口，对某种数据结构的不同实现进行多态调用。</p><p>基本的 <code>Collection</code> 接口继承关系如下：</p><p><img src="http://www.plantuml.com/plantuml/svg/RP1D2i8m48NtSufSe3TmKT2bBiGJXEQL1l9Jqyb2yF2cgP0XkXduFfZtXXatrecpTsG38yrwWZf7vp2nZO64VO05NUqcyPwH8VY2Ps6v7HF3x1dKujNfFGmrk7SrlfT7IM-Fgd-XLCQNMdixwQRNdmDtHsN8jUeMQw3WLtuf3rwYaMQsS8P615CU-G40"></p><p>需要注意的是，<code>Map</code> 并非 <code>Collection</code> 的子类，而是自成一派。</p><p>同时，这些接口都是 <strong>泛型接口</strong>，可以使用它们定义泛型方法。</p><h2 id="3-接口具体含义"><a href="#3-接口具体含义" class="headerlink" title="3. 接口具体含义"></a>3. 接口具体含义</h2><p>这些接口的具体含义如下：</p><ul><li><p><code>Collection</code></p><blockquote><p>Collection 类结构的根，一个 Collection 代表了一堆对象的集合体，对象通常被称作 <em>元素</em></p></blockquote></li><li><p><code>Set</code></p><blockquote><p>一个 <strong>不能拥有重复元素</strong> 的 Collection，类似数学意义上的集合</p></blockquote></li><li><p><code>List</code></p><blockquote><p>一个 <strong>有序的</strong> Collection，有时也被称作 <strong>序列</strong>(sequence)<br>一般来说，<code>List</code> 的用户对于 <code>List</code> 有着比较精确地控制<br>用户可以使用索引来进行元素的查找和插入操作</p></blockquote></li><li><p><code>Queue</code></p><blockquote><p>一个存储着即将进行处理的元素的 Collection<br>相比 Collection，它提供了特别的加入、删除和查找操作</p><p>比较特别的是，队列一般来说具有 <strong>先进先出</strong>(FIFO) 的插入和删除次序<br>队列的新元素位于队列末尾，旧元素位于队列头部</p></blockquote></li><li><p><code>Deque</code></p><blockquote><p>双端队列，在队列两头都可以进行插入和删除操作<br>同时，双端队列也同时支持 <strong>先进先出</strong>(FIFO) 和 <strong>后进先出</strong>(LIFO) 的插入和删除策略</p></blockquote></li><li><p><code>Map</code></p><blockquote><p>一个存储键值对的对象<br><code>Map</code> 不能包含重复键，每个键可以被映射到最多一个值上</p></blockquote></li><li><p><code>SortedSet</code></p><blockquote><p>一个它的元素按照 <strong>升序排列</strong> 的 <code>Set</code></p></blockquote></li><li><p><code>SortedMap</code></p><blockquote><p>一个它的键按照 <strong>升序排列</strong> 的 <code>Map</code></p></blockquote></li></ul><h2 id="4-Abstract-类"><a href="#4-Abstract-类" class="headerlink" title="4. Abstract 类"></a>4. Abstract 类</h2><p>集合框架中，除了接口和具体实现，还提供了一系列的 <code>Abstract*</code> 类；</p><p>它是 <code>Collection</code> 和 <code>Map</code> 以及其子接口的简单实现形式，利用泛型来提供了一些通用的方法；</p><p>比如 <code>contains()</code> 方法，就是利用了泛型的 <code>Iterator</code> 实现的。</p><p><code>Abstract</code> 类是用于进行具体集合类实现的，通过继承 <code>Abstract</code> 类，可以极大减轻</p><h2 id="5-视图"><a href="#5-视图" class="headerlink" title="5. 视图"></a>5. 视图</h2><p>在通常情况下，我们需要将一个具体的 <code>Collection</code> 或者 <code>Map</code> 对象转换成另一种集合框架内的具体对象进行操作；</p><p>所以，集合框架提供了一种很有用的视图技术；</p><p>视图(views) 指的就是返回一个实现了 <strong>其他接口</strong> 的 <strong>引用</strong>，通过这个引用，来进行 <strong>原有集合</strong> 的操作，这个对象引用就是视图。</p><h3 id="5-1-Array-asList"><a href="#5-1-Array-asList" class="headerlink" title="5.1 Array.asList()"></a>5.1 <code>Array.asList()</code></h3><p>不仅集合框架中存在包装器，<code>Array</code> 类中也存在可以包装成一个 <code>List</code> 的方法；</p><p>它返回一个 <code>List</code> 的视图，可以通过它来使用 <code>List</code> 中的访问方法（包括 <code>get</code> 和 <code>set</code>）对 <strong>原数组</strong> 进行访问和元素的修改；</p><p>但是，不能调用 <code>add()</code> 和 <code>remove()</code> 这种能够对数组大小产生影响的方法；</p><p>注意，视图对象始终是在 <strong>原对象</strong> 进行操作的。</p><blockquote><p>有趣的是，<code>asList()</code> 返回的也是 <code>ArrayList</code> 对象<br>不过，不是 <code>java.util.ArrayList</code>，而是 <code>java.util.Arrays.ArrayList</code>，是其自身的一个子类</p></blockquote><p>Java 5 之后，<code>asList()</code> 方法声明为了不定参数，可以直接传入元素进行转换操作。</p><h3 id="5-2-子范围"><a href="#5-2-子范围" class="headerlink" title="5.2 子范围"></a>5.2 子范围</h3><p>可以使用诸如 <code>subXXX()</code> 和 <code>headXXX()</code> 和 <code>tailXXX()</code> 方法返回 Collection 的一个子范围；</p><p>可以通过这个子范围视图对集合的一部分进行操作。</p><h3 id="5-3-不可变的视图"><a href="#5-3-不可变的视图" class="headerlink" title="5.3 不可变的视图"></a>5.3 不可变的视图</h3><p>通过 <code>unmodifiableXXX()</code> 可以获取一个不可修改的视图；</p><p>这个视图中的所有的更改器方法都会返回 <code>UnsupportedOperationException</code>；</p><p>当然，这不意味着其原始集合不能被更改，只是视图对象不能更改原有集合，但是通过原始集合的引用，同样可以更改原始的集合。</p><p>需要注意的是，<code>unmodifiableCollection()</code> 返回的集合是通过原始的 <code>Object.equals()</code> 方法进行相等性判断的；</p><p>也就是说，不能通过 <code>Collection</code> 视图进行相等性判定。</p><h3 id="5-4-同步视图"><a href="#5-4-同步视图" class="headerlink" title="5.4 同步视图"></a>5.4 同步视图</h3><p>集合框架还提供了一个同步视图，用来进行一系列的多线程同步工作。</p><p>通过 <code>synchronizedXXX()</code> 可以获取到一个线程安全的 <code>Collection</code> 或者 <code>Map</code>；</p><p>不过，这个线程安全仅限于一些基本的方法；</p><p>对于遍历方法，包括使用迭代器和 <code>Stream</code>，都需要 <strong>手动进行同步</strong></p><h3 id="5-5-检查视图"><a href="#5-5-检查视图" class="headerlink" title="5.5 检查视图"></a>5.5 检查视图</h3><p>在 Java 5 引入泛型之后，集合框架提供了一个检查视图；</p><p>它专门用于检查是否有其他类型的对象混入了集合之中。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ArrayList&lt;String&gt; strings = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">ArrayList a = strings;</div><div class="line">a.add(<span class="keyword">new</span> Date());</div></pre></td></tr></table></figure><p>由于使用了原始类型，编译器无法发现这一泛型错误。</p><p>使用检查视图，我们就可以发现这一错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; checkedStrings = Colllections.checkedList(strings, String.class);</div></pre></td></tr></table></figure><p>当发现类型不符合时，它会立即抛出一个 <code>ClassCastException</code>；</p><p>不过，它也有缺陷，它是依赖于虚拟机的泛型安全机制；</p><p>当向 <code>ArrayList&lt;Pair&lt;String&gt;&gt;</code> 中插入 <code>Pair&lt;Date&gt;</code> 时，就不能检测出这种错误。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-介绍&quot;&gt;&lt;a href=&quot;#1-介绍&quot; class=&quot;headerlink&quot; title=&quot;1. 介绍&quot;&gt;&lt;/a&gt;1. 介绍&lt;/h2&gt;&lt;p&gt;任何语言都会提供一套基础的数据结构的库；&lt;/p&gt;&lt;p&gt;Java 也不例外，而且提供了一个庞大的数据结构库，有时对于它们之间的选择让人很困惑。&lt;/p&gt;&lt;p&gt;这里就来简单说明一下 Java 的 Collection 和基本的 Collection 数据结构&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://wafer.li/categories/Java/"/>
    
    
      <category term="Java" scheme="https://wafer.li/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Scala 简介</title>
    <link href="https://wafer.li/Scala/Scala%20%E7%AE%80%E4%BB%8B/"/>
    <id>https://wafer.li/Scala/Scala 简介/</id>
    <published>2017-04-02T15:00:00.000Z</published>
    <updated>2017-04-14T11:56:41.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>Scala 是高层级的，函数式，基于 JVM，完美调用 Java 的编程语言。<br>其主要特点就是它是一门函数式语言。</p><p>语法上，Kotlin 借鉴了其大部分的语法，所以体现出和 Kotlin 非常相似的特征。</p><p>同时，由于基于 JVM，所以类型系统和 Java 没有多大区别。</p><a id="more"></a><h2 id="2-什么是函数式语言"><a href="#2-什么是函数式语言" class="headerlink" title="2. 什么是函数式语言"></a>2. 什么是函数式语言</h2><p>函数式语言的两大理念：</p><ol><li>函数也是值，可以作为参数，也可以保存在变量中，与其他类型同级</li><li>函数只应该接受参数输入，并输出返回值，不应该具有其他副作用</li></ol><h2 id="3-没有分号"><a href="#3-没有分号" class="headerlink" title="3. 没有分号"></a>3. 没有分号</h2><p>这里需要说的一个问题是，虽然 Scala 没有分号；</p><p>但是当你写长表达式的时候可能会有问题：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">someLongExpression</div><div class="line">+ someOtherExpression</div></pre></td></tr></table></figure><p>上面的语句会被隐式加上分号：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">someLongExpression;</div><div class="line">+ someOtherExpression</div></pre></td></tr></table></figure><p>这样显然是不符合我们的实际意图的，解决办法有两个：</p><ol><li><p>使用括号</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(someLongExpression</div><div class="line">    + someOtherLongExpression)</div></pre></td></tr></table></figure></li><li><p>将操作符放在行尾</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">someLongExpression +</div><div class="line">someOtherExpression</div></pre></td></tr></table></figure></li></ol><p>分号推断的规则为，除非以下情况，否则行尾将会被认为是一个分号：</p><ol><li>行尾由一个不能合法作为行尾的字符结束，如句点(<code>.</code>) 和中缀操作符 (<code>+</code>、<code>-</code>)</li><li>下一行开始于不能作为语句开始的字</li><li><p>行结束于括号(<code>()</code>) 和 方括号 (<code>[]</code>) 之中</p><blockquote><p>由于括号中不能容纳多个语句，所以，它之中的行不可能是一个逻辑行</p></blockquote></li></ol><h2 id="4-面向对象"><a href="#4-面向对象" class="headerlink" title="4. 面向对象"></a>4. 面向对象</h2><p>Scala 中所有东西都是 <strong>对象</strong>；</p><p>操作符实际上是对象的 <strong>方法</strong></p><h2 id="5-变量定义"><a href="#5-变量定义" class="headerlink" title="5. 变量定义"></a>5. 变量定义</h2><p>语法上和 Kotlin 无多大差别</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x: <span class="type">Int</span> = <span class="number">0</span></div></pre></td></tr></table></figure><h2 id="6-函数定义"><a href="#6-函数定义" class="headerlink" title="6. 函数定义"></a>6. 函数定义</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">max</span></span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</div><div class="line">    <span class="keyword">if</span> (x &gt; y) x</div><div class="line">    <span class="keyword">else</span> y</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>有趣的是，Scala 中，函数定义需要一个<strong>等号</strong>；</p><p>这意味着，函数实际上是一个 <strong>变量</strong>，而函数体实际上是一个 <strong>返回值的表达式</strong>。</p><p>同时，函数体 <strong>没有 <code>return</code></strong>，这主要是因为函数体是一个 <strong>表达式</strong>，而一个表达式理应返回其计算得到的值。</p><p>这正好体现了函数式编程的思想，函数是一个值，函数体是一个表达式。</p><h2 id="7-使用函数式风格"><a href="#7-使用函数式风格" class="headerlink" title="7. 使用函数式风格"></a>7. 使用函数式风格</h2><p>Scala 程序员在解决问题时，应该优先考虑函数式风格而非指令式风格。</p><p>简单的判断标准有：</p><ol><li><p>尽量使用 <code>val</code> 解决问题</p><blockquote><p>使用 <code>var</code> 会让你的 编码层级变低，而函数式编程的一个重要作用就是使你的视野聚焦在高层级中。</p></blockquote></li><li><p>尽量避免定义返回 <code>Unit</code> 的函数</p><blockquote><p>函数式编程一个理念就是函数体是表达式，而返回 <code>Unit</code> (Java 中的 <code>void</code>) 的函数一般来说都具有 <strong>副作用</strong> (即函数做了不是生成返回值的工作)</p></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;p&gt;Scala 是高层级的，函数式，基于 JVM，完美调用 Java 的编程语言。&lt;br&gt;其主要特点就是它是一门函数式语言。&lt;/p&gt;&lt;p&gt;语法上，Kotlin 借鉴了其大部分的语法，所以体现出和 Kotlin 非常相似的特征。&lt;/p&gt;&lt;p&gt;同时，由于基于 JVM，所以类型系统和 Java 没有多大区别。&lt;/p&gt;
    
    </summary>
    
      <category term="Scala" scheme="https://wafer.li/categories/Scala/"/>
    
    
      <category term="Scala" scheme="https://wafer.li/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Scala Hello World</title>
    <link href="https://wafer.li/Scala/Scala%20Hello%20World/"/>
    <id>https://wafer.li/Scala/Scala Hello World/</id>
    <published>2017-04-02T15:00:00.000Z</published>
    <updated>2017-04-08T13:58:25.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>Scala 既可以使用交互式命令行来编程，也可以将其写成一个独立的程序；</p><p>其中，关于构建独立程序的写法一共有两种。</p><a id="more"></a><h2 id="2-main-方法"><a href="#2-main-方法" class="headerlink" title="2. main() 方法"></a>2. <code>main()</code> 方法</h2><p>使用 <code>main()</code> 方法是通常各种语言的程序入口，Scala 也不例外：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</div><div class="line">    println(<span class="string">"Hello, World!"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="3-使用-Application-特质"><a href="#3-使用-Application-特质" class="headerlink" title="3. 使用 Application 特质"></a>3. 使用 <code>Application</code> 特质</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Hello</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</div><div class="line">    println(<span class="string">"Hello, World!"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h2&gt;&lt;p&gt;Scala 既可以使用交互式命令行来编程，也可以将其写成一个独立的程序；&lt;/p&gt;&lt;p&gt;其中，关于构建独立程序的写法一共有两种。&lt;/p&gt;
    
    </summary>
    
      <category term="Scala" scheme="https://wafer.li/categories/Scala/"/>
    
    
      <category term="Scala" scheme="https://wafer.li/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Java 集合框架 Collection</title>
    <link href="https://wafer.li/Java/Java%20%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%20Collection/"/>
    <id>https://wafer.li/Java/Java 集合框架 Collection/</id>
    <published>2017-04-02T15:00:00.000Z</published>
    <updated>2017-04-14T11:56:41.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p><code>Collection</code> 接口是 Java 集合框架最基本的接口；</p><p>它提供了基本的元素操作方法和遍历使用的迭代器；</p><p>同时，它还提供了关于 <code>Collection</code> 的批量操作方法。</p><a id="more"></a><h2 id="2-基本操作"><a href="#2-基本操作" class="headerlink" title="2. 基本操作"></a>2. 基本操作</h2><p>基本的元素操作包括 <code>add()</code> 和 <code>remove()</code>，同时也包括 <code>size()</code> 和 <code>isEmpty()</code> 等一系列的集合基本操作。</p><p>其中 <code>add()</code> 和 <code>remove()</code> 的返回值是 <code>boolean</code>；</p><p>这个布尔值用于表示增加和删除是否成功。（是否对集合本身进行了操作）</p><h2 id="3-遍历操作"><a href="#3-遍历操作" class="headerlink" title="3. 遍历操作"></a>3. 遍历操作</h2><p>Java 的 Collection 遍历操作有三种：</p><ol><li>使用迭代器 <code>Iterator</code></li><li>使用 <em>for each</em> 循环</li><li>使用 <code>Stream</code> 的聚合操作(Java 8)</li></ol><p>实际上，使用 <em>for each</em> 循环和使用迭代器是一样的；</p><p><em>for each</em> 可以应用于任何实现了 <code>Iterable</code> 接口的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> ineterface Iterable&lt;E&gt; &#123;</div><div class="line">    <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><em>for each</em> 实际上就是应用它返回的迭代器进行遍历操作。</p><p>关于 <code>Stream</code> 用单独的一篇文章介绍，这里主要解析迭代器的工作。</p><h2 id="4-迭代器的遍历"><a href="#4-迭代器的遍历" class="headerlink" title="4. 迭代器的遍历"></a>4. 迭代器的遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其中，<code>next()</code> 方法返回下一个元素，<code>hasNext()</code> 方法用于检测是否到达了集合末尾。</p><p>当到达了集合末尾时，调用 <code>next()</code> 会抛出 <code>NoSuchElementException</code>，所以，正确的写法是在循环时使用 <code>hasNext()</code> 作为判断条件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(iter.hasNext()) &#123;</div><div class="line">    element = iter.next();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其中，<code>Collection</code> 接口已经扩展(extends)了 <code>Iterable</code> 接口，所以自带 <code>iterator()</code> 方法。</p><p>元素被访问的顺序取决于集合类的具体实现。</p><p>比较特别的是，Java 中的迭代器和 C++ 中的迭代器不一样；</p><p>C++ 中的迭代器是基于索引的，可以不执行查找操作就将迭代器进行移动；</p><p>相反，Java 中的迭代器更类似于 <code>read()</code> 方法，迭代器的查找操作和移动操作紧密相连；</p><p>Java 中的迭代器更类似于是 <strong>位于两个元素之间</strong>，调用 <code>next()</code> 将越过一个元素，并返回这个元素的引用。</p><h2 id="5-迭代器的删除"><a href="#5-迭代器的删除" class="headerlink" title="5. 迭代器的删除"></a>5. 迭代器的删除</h2><p>比较特别的是，<code>Iterator</code> 接口还提供了一个 <code>remove()</code> 方法；</p><p>它会删除 <strong>上次</strong> 调用 <code>next()</code> 的元素；</p><p>也就是说，如果你想删除某个位置上的元素，你的迭代器就必须 <strong>先越过</strong> 这个元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Iterator&lt;String&gt; it = c.iterator();</div><div class="line"></div><div class="line">iter.next();    <span class="comment">//skip over the first</span></div><div class="line">iter.remove();  <span class="comment">// delete the first</span></div></pre></td></tr></table></figure><p>需要注意的是，<code>next()</code> 和 <code>remove()</code> 是具有依赖性的；</p><p><strong>不能连续调用两次 <code>remove()</code></strong>，否则，将会抛出 <code>IllegalStateException</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iter.remove();</div><div class="line">iter.remove();</div></pre></td></tr></table></figure><p>必须先调用 <code>next()</code> 来越过将要删除的元素。</p><h2 id="6-批量操作"><a href="#6-批量操作" class="headerlink" title="6. 批量操作"></a>6. 批量操作</h2><p>Collection 同时提供了一套批量操作方法，用于对另一个集合进行操作，主要的方法有：</p><ol><li><p><code>containsAll()</code></p><blockquote><p>判断另一集合是否为本集合的子集<br>（本集合是否完全包含了另一集合）</p></blockquote></li><li><p><code>addAll()</code></p><blockquote><p>将另一集合的所有元素加入到本集合中</p></blockquote></li><li><p><code>removeAll()</code></p><blockquote><p>将本集合中含有的 另一集合中的所有元素 从本集合中删除</p></blockquote></li><li><p><code>retainAll()</code></p><blockquote><p>将本集合中 <strong>不属于</strong> 另一集合的所有元素从本集合中删除<br>即，将本集合改造成两个集合的 <strong>交集</strong></p></blockquote></li><li><p><code>clear()</code></p><blockquote><p>删除本集合中的所有元素</p></blockquote></li></ol><h2 id="7-和数组的转换操作"><a href="#7-和数组的转换操作" class="headerlink" title="7. 和数组的转换操作"></a>7. 和数组的转换操作</h2><p><code>Collection</code> 存在一个 <code>toArray()</code> 方法；</p><p>但是，比较坑爹的是，这个方法仅仅只返回一个 <code>Object[]</code>；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Object[] a = c.toArray();</div></pre></td></tr></table></figure><p>这显然没有什么卵用，因为 <code>Object[]</code> 是 <strong>新构建的</strong>，它不能强制转换成更为具体的数组。</p><p>所以，我们需要采用另一个 <code>toArray(T[] a)</code> 方法；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 写法一</span></div><div class="line">String[] stringArray = c.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</div></pre></td></tr></table></figure><p>实际上，我们可以直接向 <code>toArray()</code> 提供一个足够大的数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 写法二</span></div><div class="line">String[] stringArray = c.toArray(<span class="keyword">new</span> String[c.size()]);</div></pre></td></tr></table></figure><p>那么这两种写法有什么区别呢？</p><p>根据 JDK 文档，当数组参数的空间不够大时，它会自动重新构建一个足够大的数组进行元素转存；</p><p>当数组空间足够大时，<code>toArray()</code> 就不自己构建数组了，而是直接将元素储存到数组中。</p><p>这样看来，写法一好像没有什么必要，毕竟都要创建数组，不如直接创建了事，何必要多出一个无用的数组呢？</p><p>实际上，写法二具有线程安全问题；</p><p>即使你使用线程安全的 <code>Collection</code>，但是当有元素在 <code>size()</code> 和 <code>toArray()</code> 之间被删除了，那么最终生成的数组就会包含 <code>null</code>。</p><p>而，写法一就可以直接避免这个问题。</p><blockquote><p>线程安全的 <code>Collection</code> 只保证每个方法是线程安全的，当你调用两个以上的方法联合使用时，就不具备线程安全了。</p></blockquote><p>Reference: <a href="http://stackoverflow.com/questions/3293946/the-easiest-way-to-transform-collection-to-array#comment66730178_3293970" target="_blank" rel="noopener">The easiest way to transform collection to array?</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Collection&lt;/code&gt; 接口是 Java 集合框架最基本的接口；&lt;/p&gt;&lt;p&gt;它提供了基本的元素操作方法和遍历使用的迭代器；&lt;/p&gt;&lt;p&gt;同时，它还提供了关于 &lt;code&gt;Collection&lt;/code&gt; 的批量操作方法。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://wafer.li/categories/Java/"/>
    
    
      <category term="Java" scheme="https://wafer.li/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Scala 类和对象基础</title>
    <link href="https://wafer.li/Scala/Scala%20%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/"/>
    <id>https://wafer.li/Scala/Scala 类和对象基础/</id>
    <published>2017-04-02T15:00:00.000Z</published>
    <updated>2017-04-14T11:56:41.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>Scala 除了是一门函数式语言外，还同时具有面向对象的特征；</p><p>在 Scala 中，一样具有类和对象以及多态的支持。</p><a id="more"></a><h2 id="2-构造器"><a href="#2-构造器" class="headerlink" title="2. 构造器"></a>2. 构造器</h2><p>类具有一个默认的 primary 构造器，它的参数直接位于 <code>class</code> 头中；</p><p>而且，更加神奇的是，<code>class</code> 中可以直接执行另外的函数；</p><p>也就是说， <strong>整个类</strong> 都是 primary 构造器。</p><p>对于多个构造器，我们采用如下的声明来实现：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">val name:<span class="type">String</span>, val age: <span class="type">Int</span></span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(name: <span class="type">String</span>) = <span class="keyword">this</span>(name, <span class="number">17</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>通过直接定义 <code>this</code> 来定义一个新的构造器</p><h2 id="3-定义和创建"><a href="#3-定义和创建" class="headerlink" title="3. 定义和创建"></a>3. 定义和创建</h2><p>和 Java 一样，Scala 中，类使用 <code>class</code> 关键字进行定义：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChecksumAccumulator</span> </span>&#123;</div><div class="line">    <span class="comment">// class body</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>不过和 Java 不同的，对象的构建，类没有参数，则不需要括号：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="type">ChecksumAccumulator</span></div></pre></td></tr></table></figure><h2 id="4-字段和方法"><a href="#4-字段和方法" class="headerlink" title="4. 字段和方法"></a>4. 字段和方法</h2><p>类中，字段使用 <code>val</code> 和 <code>var</code> 定义，方法使用 <code>def</code> 定义。</p><p>注意 <code>def</code> 同样要使用等于号 <code>=</code></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChecksumAccumulator</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkSum</span></span>(): <span class="type">Int</span> = &#123;</div><div class="line">        <span class="keyword">return</span> ~(sum + <span class="number">0XFF</span>) + <span class="number">1</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其中，如果方法需要有副作用，则将其返回值声明为 <code>Unit</code></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(b: <span class="type">Int</span>): <span class="type">Unit</span> = &#123;</div><div class="line">    sum += b</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>此时，方法会忽略函数体最后的值类型，转而将其转换为 <code>Unit</code></p><p>如果需要返回 <code>Unit</code>，我们也可以直接省略等于号，使用 Java 中常用的方法声明形式：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(b: <span class="type">Int</span>) &#123;</div><div class="line">    sum += b</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果一个函数或者方法的定义没有等于号，那么默认其返回值类型为 <code>Unit</code>。</p><p>如果需要函数或者方法来推断返回值类型，则需要加上等于号</p><h2 id="5-Getter-和-Setter"><a href="#5-Getter-和-Setter" class="headerlink" title="5. Getter 和 Setter"></a>5. Getter 和 Setter</h2><p>很遗憾，Scala 的类成员是字段形式的，所以，不能像 Kotlin 那样采用语法糖式的 getter 和 setter 的写法；</p><p>相比 Java，Scala 在定义字段时，会自动生成字段的 getter 和 setter，他们的命名为：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">x</span></span>:<span class="type">T</span>                      <span class="comment">// getter</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">x_=</span> </span>: (y: <span class="type">T</span>): <span class="type">Unit</span>       <span class="comment">// setter</span></div></pre></td></tr></table></figure><p>注意，方法名为 <code>x</code> 和 <code>x_=</code></p><p>那么如何提供自定义的 getter 和 setter 呢？</p><p>我们只能采用后备字段，同时，将我们自定义的 getter 和 setter 满足上面的命名公约：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">private var _name: <span class="type">String</span></span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span> </span>= _name</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name_=</span> </span>(thatName: <span class="type">String</span>): <span class="type">Unit</span> = &#123;</div><div class="line">        _name = thatName</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样，我们就能够像使用属性一样使用 <code>name</code> 了。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> p = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">"hehe"</span>)</div><div class="line"></div><div class="line">p.name = <span class="string">"nihao"</span></div></pre></td></tr></table></figure><h2 id="6-可见性简述"><a href="#6-可见性简述" class="headerlink" title="6. 可见性简述"></a>6. 可见性简述</h2><p>Scala 中，默认的可见性是 <code>public</code>；</p><p>其余的可见性修饰符和 Java 一致。</p><h2 id="7-伴生对象"><a href="#7-伴生对象" class="headerlink" title="7. 伴生对象"></a>7. 伴生对象</h2><p>Scala 没有静态成员，但是具有伴生对象(companion object)，是对象(object) 的一种。</p><p>对象是一个 <strong>单例</strong>，当对象和类在同一个文件中定义，具有同样的名称时，称对象是类的伴生对象。</p><p>对象不带参数，不能通过 <code>new</code> 关键字进行构建。</p><p>方法的调用形式和 Java 的静态方法调用相同。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">ChecksumAccumulator</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">val</span> cache = <span class="type">Map</span>[<span class="type">String</span>, <span class="type">Int</span>]()</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate</span></span>(s: <span class="type">String</span>): <span class="type">Int</span> =</div><div class="line">    <span class="keyword">if</span> (cache.contains(s))</div><div class="line">        cache(s)</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">val</span> acc = <span class="keyword">new</span> <span class="type">ChecksumAccumulator</span></div><div class="line">        <span class="keyword">for</span> (c &lt;- s)</div><div class="line">            acc.add(c.toByte)</div><div class="line">        <span class="keyword">val</span> cs = acc.checksum()</div><div class="line">        cache += (s -&gt; cs)</div><div class="line">        cs</div><div class="line">     &#125;</div></pre></td></tr></table></figure><p>没有伴生类的对象称为 <strong>孤立对象</strong>，实际上就是一个简单的单例。</p><h2 id="8-类的解析过程"><a href="#8-类的解析过程" class="headerlink" title="8. 类的解析过程"></a>8. 类的解析过程</h2><p>Scala 采用代换模型对表达式进行解析，那么它是如何解析类的定义和声明调用的呢？</p><p>对此，有如下的几个步骤：</p><ol><li><p>将 <code>new</code> 关键字当成普通方法进行代换，最终为值</p></li><li><p>解析类定义中的方法形参</p></li><li><p>解析构造器形参</p></li><li><p>将 <code>this</code> 关键字替换成 <code>new</code> 的表达式</p></li><li><p>将上述解析到的所有值进行代入，函数解析为字面量</p></li><li><p>继续代换，最终得到结果</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h2&gt;&lt;p&gt;Scala 除了是一门函数式语言外，还同时具有面向对象的特征；&lt;/p&gt;&lt;p&gt;在 Scala 中，一样具有类和对象以及多态的支持。&lt;/p&gt;
    
    </summary>
    
      <category term="Scala" scheme="https://wafer.li/categories/Scala/"/>
    
    
      <category term="Scala" scheme="https://wafer.li/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Scala 函数式特征</title>
    <link href="https://wafer.li/Scala/Scala%20%E5%87%BD%E6%95%B0%E5%BC%8F%E7%89%B9%E5%BE%81/"/>
    <id>https://wafer.li/Scala/Scala 函数式特征/</id>
    <published>2017-03-31T15:00:00.000Z</published>
    <updated>2017-04-18T16:32:07.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="1-函数类型"><a href="#1-函数类型" class="headerlink" title="1. 函数类型"></a>1. 函数类型</h2><p>函数类型是函数式语言的特征之一；</p><p>其原因在于，函数是语言中的一等公民，可以作为变量，而变量是具有类型的。</p><p>Scala 的函数类型定义如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">f: <span class="type">Int</span>, <span class="type">Int</span> =&gt; <span class="type">Int</span></div></pre></td></tr></table></figure><p>使用箭头将参数类型和返回值类型相间隔；</p><p>上面的例子表示函数 <code>f</code> 接受两个 <code>Int</code> 参数，返回值类型为 <code>Int</code></p><a id="more"></a><h2 id="2-高阶函数"><a href="#2-高阶函数" class="headerlink" title="2. 高阶函数"></a>2. 高阶函数</h2><p>高阶函数指的是接受 函数作为参数 的函数，它的参数是函数类型。</p><p>Scala 中的高阶函数如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(f: <span class="type">Int</span> =&gt; <span class="type">Int</span>, a: <span class="type">Int</span>, b: <span class="type">Int</span>) =</div><div class="line">    <span class="keyword">if</span>(a &gt; b) <span class="number">0</span></div><div class="line">    <span class="keyword">else</span> f(a) + sum(a + <span class="number">1</span>, b)</div></pre></td></tr></table></figure><p>其中，<code>f</code> 是函数类型的参数，它接受一个 <code>Int</code> 作为参数，返回值是一个 <code>Int</code>；</p><p>上面的例子如下数学公式的求法：</p><script type="math/tex;mode=display">\sum_a^b{f(a)}</script><h2 id="3-匿名函数-函数字面量-lambda"><a href="#3-匿名函数-函数字面量-lambda" class="headerlink" title="3. 匿名函数(函数字面量, lambda)"></a>3. 匿名函数(函数字面量, lambda)</h2><p>作为语言的基本类型，如字符串，我们可以使用字面量表示它，如：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> s = <span class="string">"abc"</span></div><div class="line">println(s)</div></pre></td></tr></table></figure><p>上面可以直接写成</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">println(<span class="string">"abc"</span>)</div></pre></td></tr></table></figure><p>在 Scala 中，函数也具有这种特性，我们可以直接定义一个函数字面量：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> f = (x: <span class="type">Int</span>) =&gt; x * x</div><div class="line">sum(f, <span class="number">1</span>, <span class="number">3</span>)</div></pre></td></tr></table></figure><p>如上，<code>f</code> 是一个函数，具有参数 <code>x</code>，返回 <code>x</code> 的平方</p><p>也可以将字面量直接传入</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sum(x =&gt; x * x, <span class="number">1</span>, <span class="number">3</span>)</div></pre></td></tr></table></figure><blockquote><p>大部分情况都不需要显式指定参数的类型，编译器会进行自动推断；<br>同时，无法在函数字面量中显式指定函数的返回值类型<br>只能通过定义函数变量的类型来进行显示指定</p></blockquote><p>实际上，Scala 中的匿名函数就是其他语言中的 <strong>lambda</strong> 表达式；</p><p>就函数式上来说，Scala 提供了一种更轻便的语法</p><h2 id="4-柯里化"><a href="#4-柯里化" class="headerlink" title="4. 柯里化"></a>4. 柯里化</h2><h3 id="4-1-定义"><a href="#4-1-定义" class="headerlink" title="4.1 定义"></a>4.1 定义</h3><p>柯里化是函数式范式的一个特有现象；</p><p>它指的是，一个函数，通过接受部分参数，可以返回接受剩余参数的 <strong>嵌套函数</strong>；</p><p>事实上，对于一个函数</p><script type="math/tex;mode=display">def \ f(arg_1)\ldots(arg_n) = E</script><p>当 $n \gt 1$ 时，以下的写法和上面是等价的：</p><script type="math/tex;mode=display">def \ f(arg_1)\ldots(arg_n) = \{def \ g(arg_n) = E; \ g\}</script><p>所以，我们可以通过编写嵌套的接受部分参数的函数，并返回它，来达到柯里化的目的；</p><p>实际上，这个过程就叫做柯里化。</p><script type="math/tex;mode=display">\begin{align}f(arg_1)(arg_2)\ldots(arg_n) \\&= arg_1 \Rightarrow \{f(arg_2)\ldots(arg_n)\} \\&= arg_1 \Rightarrow \{arg_2 \Rightarrow \{f(arg_3)\ldots(arg_n)\}\} \\&= \cdots \\&= arg_1 \Rightarrow arg_2 \Rightarrow arg_3 \Rightarrow \ldots \Rightarrow f\end{align}</script><h3 id="4-2-显式柯里化"><a href="#4-2-显式柯里化" class="headerlink" title="4.2 显式柯里化"></a>4.2 显式柯里化</h3><p><code>sum</code> 函数可以使用如下的方法进行重写：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(f: <span class="type">Int</span> =&gt; <span class="type">Int</span>): (<span class="type">Int</span>, <span class="type">Int</span>) =&gt; <span class="type">Int</span> = &#123;</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumF</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>) = &#123;</div><div class="line">        <span class="keyword">if</span>(a &gt; b) <span class="number">0</span></div><div class="line">        <span class="keyword">else</span> f(a) + sumF(a + <span class="number">1</span>, b)</div><div class="line">    &#125;</div><div class="line">    sumF</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面的写法被称作 <strong>显式柯里化</strong>，就是将一个接受多个参数的函数通过显式编写一个内部的嵌套函数，并返回这个函数来达到柯里化。</p><p>在调用时，我们可以直接如下调用：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sum(x =&gt; x * x) (<span class="number">1</span>, <span class="number">10</span>) <span class="comment">// 1^2 + 2^2 + ... + 10^2</span></div></pre></td></tr></table></figure><p>第一个括号，调用了外部函数，返回值是内部的 <code>sumF</code> 函数；</p><p>这使得我们可以 <strong>继续使用括号</strong> 进行 <code>sumF</code> 的调用</p><h3 id="4-3-隐式柯里化"><a href="#4-3-隐式柯里化" class="headerlink" title="4.3 隐式柯里化"></a>4.3 隐式柯里化</h3><p>许多函数式编程语言都提供柯里化的语法糖，这被称作 <strong>隐式柯里化</strong>；</p><p>Scala 也提供了这样的语法糖：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(f: <span class="type">Int</span> =&gt; <span class="type">Int</span>)(a: <span class="type">Int</span>, b: <span class="type">Int</span>) =</div><div class="line">    <span class="keyword">if</span> (a &gt; b) <span class="number">0</span></div><div class="line">    <span class="keyword">else</span> f(a) + sum(f)(a + <span class="number">1</span>, b)</div></pre></td></tr></table></figure><p>通过使用两个括号，就可以直接定义最内部的函数体，而不需要再定义一个内部的嵌套函数；</p><p>这可以让我们像进行柯里化函数调用一样，定义柯里化函数</p><h3 id="4-4-柯里化的目的"><a href="#4-4-柯里化的目的" class="headerlink" title="4.4 柯里化的目的"></a>4.4 柯里化的目的</h3><p>柯里化相比我们定义一个多参数函数来说，要稍显复杂；</p><p>那么为什么不直接定义一个多参数函数呢？</p><p>实际上，使用柯里化的目的在于可以动态确定参数；</p><p>当函数的某些参数不确定时，我们可以先保存一个存根；</p><p>剩余的参数确定之后，可以通过存根直接调用剩下的参数。</p><p>柯里化的另一个用处类似建造者模式(Builder Pattern)，可以通过柯里化来减少参数和函数重载的爆炸。</p><h2 id="5-部分应用-partially-application"><a href="#5-部分应用-partially-application" class="headerlink" title="5. 部分应用(partially application)"></a>5. 部分应用(partially application)</h2><p>部分应用指的是， <strong>固定</strong> 函数的某些参数，可以获取一个接受剩下参数的函数；</p><p>有点类似于在运行时给予函数默认值。</p><p>Scala 的部分应用写法如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>, c: <span class="type">Int</span>) = a + b + c</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">addA5</span> </span>= add(<span class="number">5</span>, _:<span class="type">Int</span>, _:<span class="type">Int</span>)</div><div class="line"></div><div class="line">addA5(<span class="number">2</span>, <span class="number">3</span>) <span class="comment">// 5 + 2 + 3</span></div></pre></td></tr></table></figure><p>可以看到，我们通过将参数 <code>a</code> 的值固定为 <code>5</code> 得到了一个新的函数；</p><p>它接受 <code>b</code> 和 <code>c</code>，返回 <code>5 + b + c</code></p><h2 id="6-柯里化和部分应用的区别"><a href="#6-柯里化和部分应用的区别" class="headerlink" title="6. 柯里化和部分应用的区别"></a>6. 柯里化和部分应用的区别</h2><p>这两个概念经常被混淆，但是实际上有着一些差别：</p><ol><li>柯里化指的是将多参数函数 <strong>分解为</strong> 多个单参数（组）函数的特性</li><li>部分应用指的是通过 <strong>固定</strong> 某个参数，得到接受剩余参数函数的特性</li></ol><p>虽然它们调用的效果都是返回一个函数，但是，两者一次调用返回的函数具有显著的不同：</p><ol><li><p>柯里化返回的函数只接受一个参数（组）</p><blockquote><p>由于返回的是层层嵌套的函数，所以会出现函数的连续调用<br><code>add(1)(1)(1)(1)(1)</code> 中，<br>对于一个 <code>(1)</code>，返回的函数是接受另一个 <code>1</code>，同时将剩下的内部嵌套闭包返回</p></blockquote></li><li><p>部分应用返回的函数可以接受多个参数</p><blockquote><p>相比柯里化，部分应用返回的函数可以直接接受多个参数，如<br><code>add_1(1,1,1,1)</code><br>固定了第一个 <code>1</code> 之后，剩下的 <code>1</code> 可以直接传入，而不需要连续调用</p></blockquote></li></ol><p>柯里化通过将函数分解嵌套来减少函数的参数；</p><p>函数的部分应用通过给予参数默认值来减少函数的参数。</p><p>柯里化函数的调用是函数的连续调用，而函数的部分应用是函数的一次调用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-函数类型&quot;&gt;&lt;a href=&quot;#1-函数类型&quot; class=&quot;headerlink&quot; title=&quot;1. 函数类型&quot;&gt;&lt;/a&gt;1. 函数类型&lt;/h2&gt;&lt;p&gt;函数类型是函数式语言的特征之一；&lt;/p&gt;&lt;p&gt;其原因在于，函数是语言中的一等公民，可以作为变量，而变量是具有类型的。&lt;/p&gt;&lt;p&gt;Scala 的函数类型定义如下：&lt;/p&gt;&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;f: &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt; =&amp;gt; &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;使用箭头将参数类型和返回值类型相间隔；&lt;/p&gt;&lt;p&gt;上面的例子表示函数 &lt;code&gt;f&lt;/code&gt; 接受两个 &lt;code&gt;Int&lt;/code&gt; 参数，返回值类型为 &lt;code&gt;Int&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Scala" scheme="https://wafer.li/categories/Scala/"/>
    
    
      <category term="Scala" scheme="https://wafer.li/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>设计阶段</title>
    <link href="https://wafer.li/Reviews/TSPi/%E8%AE%BE%E8%AE%A1%E9%98%B6%E6%AE%B5/"/>
    <id>https://wafer.li/Reviews/TSPi/设计阶段/</id>
    <published>2017-03-26T15:00:00.000Z</published>
    <updated>2017-04-17T08:26:54.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="1-HLD-作业"><a href="#1-HLD-作业" class="headerlink" title="1. HLD(作业)"></a>1. HLD(作业)</h2><p>设计阶段要完成高层设计，出 SDS，软件设计规格说明（体系结构文档）</p><p>包含：</p><ol><li>软件层次架构设计</li><li><p>功能模块设计</p><blockquote><p>要根据需求分析书来</p></blockquote></li><li><p>数据库设计</p><blockquote><p>就是数据库设计，包括 E-R 图和数据库表设计</p></blockquote></li><li>接口和界面设计</li></ol><a id="more"></a><h2 id="2-设计标准"><a href="#2-设计标准" class="headerlink" title="2. 设计标准"></a>2. 设计标准</h2><ol><li><p>Naming Conventions</p><blockquote><p>命名公约，各项命名的规定</p></blockquote></li><li><p>Interface formats</p><blockquote><p>内部的 API 接口设计和外部的 UI 设计<br>界面设计线图（界面区域划分）</p></blockquote></li><li><p>System and Error Messages</p><blockquote><p>就是 LOG 和 Exception 界面</p></blockquote></li><li><p>Defect Standars</p><blockquote><p>缺陷标准，使用 PSPi 的就行</p></blockquote></li><li><p>LOC counting</p><blockquote><p>只计算新增的和修改过的代码</p></blockquote></li><li><p>Design Representation Standards</p><blockquote><p>就是 SDS 的内容</p></blockquote></li></ol><h2 id="3-设计复用库"><a href="#3-设计复用库" class="headerlink" title="3. 设计复用库"></a>3. 设计复用库</h2><ol><li><p>复用的接口标准</p></li><li><p>复用的文档标准</p></li><li><p>复用部分的质量标准</p></li><li><p>应用复用库的技术支持</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-HLD-作业&quot;&gt;&lt;a href=&quot;#1-HLD-作业&quot; class=&quot;headerlink&quot; title=&quot;1. HLD(作业)&quot;&gt;&lt;/a&gt;1. HLD(作业)&lt;/h2&gt;&lt;p&gt;设计阶段要完成高层设计，出 SDS，软件设计规格说明（体系结构文档）&lt;/p&gt;&lt;p&gt;包含：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;软件层次架构设计&lt;/li&gt;&lt;li&gt;&lt;p&gt;功能模块设计&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;要根据需求分析书来&lt;/p&gt;&lt;/blockquote&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;数据库设计&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;就是数据库设计，包括 E-R 图和数据库表设计&lt;/p&gt;&lt;/blockquote&gt;&lt;/li&gt;&lt;li&gt;接口和界面设计&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="复习" scheme="https://wafer.li/categories/%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="SPI" scheme="https://wafer.li/categories/%E5%A4%8D%E4%B9%A0/SPI/"/>
    
    
      <category term="复习" scheme="https://wafer.li/tags/%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="SPI" scheme="https://wafer.li/tags/SPI/"/>
    
      <category term="TSPI" scheme="https://wafer.li/tags/TSPI/"/>
    
  </entry>
  
  <entry>
    <title>实现阶段</title>
    <link href="https://wafer.li/Reviews/TSPi/%E5%AE%9E%E7%8E%B0%E9%98%B6%E6%AE%B5/"/>
    <id>https://wafer.li/Reviews/TSPi/实现阶段/</id>
    <published>2017-03-26T15:00:00.000Z</published>
    <updated>2017-04-17T08:26:54.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="1-实现标准"><a href="#1-实现标准" class="headerlink" title="1. 实现标准"></a>1. 实现标准</h2><p>扩展了设计标准</p><ol><li><p>Standards Review</p><blockquote><p>审查了世界标准</p></blockquote></li><li><p>Naming, interfae and message standards</p></li><li><p>Coding Standards</p><ol><li><blockquote><p>编码规范</p></blockquote></li></ol></li><li>Size Standards</li></ol><a id="more"></a><h2 id="2-表格"><a href="#2-表格" class="headerlink" title="2.  表格"></a>2. 表格</h2><ol><li>INS</li><li>LOGT</li><li>LOGD</li></ol><h2 id="3-策略"><a href="#3-策略" class="headerlink" title="3. 策略"></a>3. 策略</h2><ol><li>复查</li><li>复用</li><li>测试</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-实现标准&quot;&gt;&lt;a href=&quot;#1-实现标准&quot; class=&quot;headerlink&quot; title=&quot;1. 实现标准&quot;&gt;&lt;/a&gt;1. 实现标准&lt;/h2&gt;&lt;p&gt;扩展了设计标准&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;Standards Review&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;审查了世界标准&lt;/p&gt;&lt;/blockquote&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Naming, interfae and message standards&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Coding Standards&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;blockquote&gt;&lt;p&gt;编码规范&lt;/p&gt;&lt;/blockquote&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;li&gt;Size Standards&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="复习" scheme="https://wafer.li/categories/%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="SPI" scheme="https://wafer.li/categories/%E5%A4%8D%E4%B9%A0/SPI/"/>
    
    
      <category term="复习" scheme="https://wafer.li/tags/%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="SPI" scheme="https://wafer.li/tags/SPI/"/>
    
      <category term="TSPI" scheme="https://wafer.li/tags/TSPI/"/>
    
  </entry>
  
  <entry>
    <title>命令模式</title>
    <link href="https://wafer.li/DesignPattern/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    <id>https://wafer.li/DesignPattern/命令模式/</id>
    <published>2017-03-24T15:00:00.000Z</published>
    <updated>2017-04-09T04:39:49.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>命令模式将『请求』封装成对象，以便使用不同的请求，队列或者日志系统。</p><p>命令模式也可以支持可撤销和回滚操作。</p><p>命令模式通过将请求进行封装，成功地将客户和具体的低层组件进行解耦；</p><p>客户只需要知道要加载命令，而不需要知道如何进行命令的具体执行操作。</p><a id="more"></a><h2 id="2-类图结构"><a href="#2-类图结构" class="headerlink" title="2. 类图结构"></a>2. 类图结构</h2><p><img src="http://www.plantuml.com/plantuml/svg/PL4nRiCm3Dpv2euf2kS16Oe0dhhs1uf4rq8bCP1e8q7YlrUk5TjGkUbul3jIvoGgok0TQATImjPP2WBbzHb6_g683y1SxvX8MlPU1NDuW-d5-Y9DTjpHb1RBOQ7O81GxfGdBvCfwg4kIcBaJqetq89Gd_hM6O7XlrdBGaOHgjLfYcrjMmgRvM9FkiKeGuBNqqbp0shLfdbiJ0WjXjD-z87UruEbKelq5kmuNPpMERCqMkImnLom9Z-iDPtG2ogQp3K1l3I7vgzpHa_HiqXxgBBcCd3C_V-el"></p><p>可以看到，<code>Client</code> 处于最高层，它不需要知道 <code>Command</code> 的执行过程；</p><p>这就达到了客户和低层组件的解耦目的。</p><h2 id="3-封装请求调用者"><a href="#3-封装请求调用者" class="headerlink" title="3. 封装请求调用者"></a>3. 封装请求调用者</h2><p>一个很重要的地方就是我们的请求接收者 <code>Receiver</code> 和我们的命令对象 <code>Command</code> 是组合关系</p><p>也就是说，<code>Command</code> 具有一个接收者的内部对象；</p><p>否则，它无法真正地成为一个可以执行的命令。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Receiver receiver;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteCommand</span><span class="params">(Receiver receiver)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.receiver = receiver;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</div><div class="line">        receiver.action();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="4-支持撤销和回滚"><a href="#4-支持撤销和回滚" class="headerlink" title="4. 支持撤销和回滚"></a>4. 支持撤销和回滚</h2><p>通常的命令都会具有可撤销的属性要求；</p><p>那么我们如何实现这个可撤销的需求呢？</p><p>撤销实际上就是返回到命令执行前的一个状态中；</p><p>所以在实际的命令对象类中，我们通过记住 <strong>上一个</strong> 命令时的状态，就能实现撤销功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CeilingFanHighCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</div><div class="line">    CeilingFan ceilingFan;</div><div class="line">    <span class="keyword">int</span> prevSpeed;  <span class="comment">// 前一个命令后风扇的转速</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CeilingFanHighCommand</span><span class="params">(CeilingFan ceilingFan)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.ceilingFan = ceilingFan;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</div><div class="line">        prevSpeed = ceilingFan.getSpeed();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (prevSpeed == CeilingFan.HIGH) &#123;</div><div class="line">            ceilingFan.high();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (prevSpeed == CeilingFan.MEDIUM) &#123;</div><div class="line">            ceilingFan.medium();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (prevSpeed == CeilingFan.LOW) &#123;</div><div class="line">            ceilingFan.low();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (prevSpeed == CeilingFan.OFF) &#123;</div><div class="line">            ceilingFan.off();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="5-使用空对象替代-null"><a href="#5-使用空对象替代-null" class="headerlink" title="5. 使用空对象替代 null"></a>5. 使用空对象替代 <code>null</code></h2><p>对于命令模式来说，它的客户类还是有一些细微的要求；</p><p>我们可以使用一个队列或者数组来代表需要执行的命令插槽；</p><p>当插槽没有加载命令时候，我们普通的做法是使用一个 <code>null</code> 来进行替代；</p><p>但是，此时我们就需要对命令对象进行空检测：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onButtonWasPushed</span><span class="params">(<span class="keyword">int</span> slot)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (onCommand[slot] != <span class="keyword">null</span>) &#123;</div><div class="line">        onCommand[slot].execute();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>对此，我们可以使用一个 <code>NoCommand</code> 对象，它是一个命令对象，只不过什么都不做；</p><p>这样，即使插槽没有加载命令，我们也可以直接使用 <code>NoCommand</code> 来替代，这样就不需要进行空检测了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Command noCommand = <span class="keyword">new</span> NoCommand();</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</div><div class="line">    onCommands[i] = noCommand;</div><div class="line">    offCommands[i] = noCommand;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="6-宏命令"><a href="#6-宏命令" class="headerlink" title="6. 宏命令"></a>6. 宏命令</h2><p>命令模式的一个最大的优点就是能使用宏命令；</p><p>也就是一次调用，执行多个命令；</p><p>实际上，我们只需要将命令对象中包装的接收者变成命令对象数组即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> clas MacroCommand implements Command &#123;</div><div class="line">    Command[] commands;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MacroCommand</span><span class="params">(Command[] commands)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.commands = commands;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; commands.length; i++) &#123;</div><div class="line">            commands[i].execute();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="7-队列请求"><a href="#7-队列请求" class="headerlink" title="7. 队列请求"></a>7. 队列请求</h2><p>除此之外，命令模式还可以使用于工作队列；</p><p>也就是说我们可以构建一个接受命令对象的队列，它只是按照顺序进行命令的执行操作；</p><p>当线程可用时，它就会将命令分配给线程，然后执行 <code>execute()</code>；</p><p>队列并不需要关心命令究竟是什么，是如何完成的，只需要对命令进行调度即可。</p><h2 id="8-日志和恢复"><a href="#8-日志和恢复" class="headerlink" title="8. 日志和恢复"></a>8. 日志和恢复</h2><p>除了队列以外，我们另一个应用范围就是日志系统和崩溃恢复；</p><p>为了完成这个功能，我们可以在命令接口中添加 <code>store()</code> 和 <code>load()</code> 方法；</p><p>当调用者调用命令时候，同时调用 <code>store()</code> 将命令对象序列化到服务器中进行存储；</p><p>当崩溃发生，需要恢复时，我们就可以将存储服务器中的命令对象进行反序列化，然后调用 <code>load()</code> 方法；</p><h2 id="9-优缺点"><a href="#9-优缺点" class="headerlink" title="9. 优缺点"></a>9. 优缺点</h2><p>命令模式的优点非常明显，就是可以完全实现客户类和低层组件的解耦；</p><p>高层的调用者不需要知道命令执行的具体细节，只需要调用接口的方法就可以执行命令的调用。</p><p>但是缺点是它需要创建不同的命令对象来进行不同的命令接收者的包装；</p><p>这就会让我们的代码中出现很多的小型类。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;p&gt;命令模式将『请求』封装成对象，以便使用不同的请求，队列或者日志系统。&lt;/p&gt;&lt;p&gt;命令模式也可以支持可撤销和回滚操作。&lt;/p&gt;&lt;p&gt;命令模式通过将请求进行封装，成功地将客户和具体的低层组件进行解耦；&lt;/p&gt;&lt;p&gt;客户只需要知道要加载命令，而不需要知道如何进行命令的具体执行操作。&lt;/p&gt;
    
    </summary>
    
      <category term="DesignPattern" scheme="https://wafer.li/categories/DesignPattern/"/>
    
    
      <category term="DesignPattern" scheme="https://wafer.li/tags/DesignPattern/"/>
    
  </entry>
  
  <entry>
    <title>Scala 函数解析</title>
    <link href="https://wafer.li/Scala/Scala%20%E5%87%BD%E6%95%B0%E8%A7%A3%E6%9E%90/"/>
    <id>https://wafer.li/Scala/Scala 函数解析/</id>
    <published>2017-03-21T15:00:00.000Z</published>
    <updated>2017-04-14T11:56:41.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="1-代换模型"><a href="#1-代换模型" class="headerlink" title="1. 代换模型"></a>1. 代换模型</h2><p>Scala 使用代换模型对函数和表达式进行解析工作；</p><p>所谓的代换模型就是类似平常算术的过程；</p><p>从左到右地将函数和表达式一步一步转换，最终转换成值。</p><p>例如：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="number">2</span> * <span class="number">2</span>) + (<span class="number">4</span> * <span class="number">5</span>)</div></pre></td></tr></table></figure><a id="more"></a><p>对于上面的式子 Scala 是如何解析的呢？</p><p>我们从左到右地解析，首先，我们解析 <code>(2 * 2)</code> 的内容，将其替换成值 <code>4</code>；</p><p>此时，式子变为：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">4</span> + (<span class="number">4</span> * <span class="number">5</span>)</div></pre></td></tr></table></figure><p>由于有括号，和乘法的算术等级较高，所以我们接下来对 <code>(4 * 5)</code> 进行解析；</p><p>此时，式子变为：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">4</span> + <span class="number">20</span></div></pre></td></tr></table></figure><p>此时，我们计算上面的值，最后得到 24。</p><p>可以看到，Scala 的解析是符合我们通常的算术解析规律的。</p><h2 id="2-代换模型的缺陷"><a href="#2-代换模型的缺陷" class="headerlink" title="2. 代换模型的缺陷"></a>2. 代换模型的缺陷</h2><p>使用代换模型最重要的一个要求就是，我们的表达式最终 <strong>能够</strong> 规约到一个 <strong>值</strong>；</p><p>如果它最终不能够规约到一个值(无限循环，Non-Terminate)；</p><p>或者表达式对其外部的变量产生了影响(副作用)；</p><p>都会对代换模型造成污染。</p><h2 id="3-副作用"><a href="#3-副作用" class="headerlink" title="3. 副作用"></a>3. 副作用</h2><p>所谓的副作用就是指的是，函数和表达式的执行过程修改了外部的变量。</p><p>例如，<code>c++</code> 这个表达式就具有很明显的副作用；</p><p>因为我们不能够直接将这个表达式规约为一个值；</p><p>在执行的过程中，我们需要对 <code>c</code> 这个外部传入的变量进行修改；</p><p>这就让这个表达式显得不够纯粹，这时候我们就说它具有 <strong>副作用</strong></p><h2 id="4-不能终结的解析"><a href="#4-不能终结的解析" class="headerlink" title="4. 不能终结的解析"></a>4. 不能终结的解析</h2><p>所谓的不能终结的解析就是指的一个函数返回它自身；</p><p>例如：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop</span></span>(x: <span class="type">Int</span>) = loop</div></pre></td></tr></table></figure><p>这个函数的解析永远也不会完成，这是因为我们如果使用代换模型对其进行解析的话，会发现，它的解析结果一直是其自身；</p><p>所以，对它的解析会一直进行下去，无法完成。</p><h2 id="5-参数解析"><a href="#5-参数解析" class="headerlink" title="5. 参数解析"></a>5. 参数解析</h2><p>Scala 有两种参数解析方式，不像其他的指令性语言只有一种解析方式；</p><p>其中的一种叫传值调用(call-by-value)，另一种叫传名调用(call-by-name)。</p><h3 id="5-1-传值调用-call-by-value"><a href="#5-1-传值调用-call-by-value" class="headerlink" title="5.1 传值调用(call-by-value)"></a>5.1 传值调用(call-by-value)</h3><p>这是 Scala 的默认的参数解析方式，也是其他指令性语言常用的参数解析方式。</p><p>主要的解析步骤如下：</p><ol><li>将传入参数的表达式解析为值</li><li>将函数使用函数体进行替换</li><li>将函数的形参替换为第一步中得到的实参</li></ol><p>例如：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span></span>(x: <span class="type">Int</span>) = x * x</div><div class="line"></div><div class="line">square(<span class="number">2</span> + <span class="number">2</span>)</div></pre></td></tr></table></figure><p>对于上面的代码，解析步骤如下：</p><ol><li>将 <code>2 + 2</code> 进行计算，得到它的值 <code>4</code></li><li>将 <code>square</code> 使用它的函数体进行替换，得到 <code>x * x</code></li><li>将 <code>x</code> 代换为 <code>4</code></li><li>计算出结果 <code>16</code></li></ol><h3 id="5-2-传名调用-call-by-name"><a href="#5-2-传名调用-call-by-name" class="headerlink" title="5.2 传名调用(call-by-name)"></a>5.2 传名调用(call-by-name)</h3><p>这是 Scala 的另一种参数解析方式，也是其他指令性语言不具备的。</p><p>只要在定义参数时，使用 <code>=&gt;</code> 就可以定义传名调用的参数</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span></span>(x: =&gt; <span class="type">Int</span>) = x * x</div></pre></td></tr></table></figure><p>主要的解析步骤如下：</p><ol><li>将函数名替换为函数体</li><li>直接将参数的表达式代入形参</li><li>对得到的表达式进行解析和计算，得出结果</li></ol><p>还是使用上面的例子，解析步骤如下：</p><ol><li>将 <code>square</code> 替换为 <code>x * x</code></li><li>将 <code>2 + 2</code> 代入 <code>x</code> 中</li><li>对得到的式子 <code>(2 + 2) * (2 + 2)</code> 进行代换模型的计算</li><li>得到结果 <code>16</code></li></ol><h3 id="5-3-区别"><a href="#5-3-区别" class="headerlink" title="5.3 区别"></a>5.3 区别</h3><p>那么这两种计算结果有什么区别呢？</p><p>首先，传名调用具有懒加载的功能，直到参数 <strong>被使用</strong> 的时候，才进行参数表达式的解析；</p><p>例如：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">first</span></span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>) = x</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">first</span></span>(x: =&gt; <span class="type">Int</span>, y: =&gt; <span class="type">Int</span>) = x</div><div class="line"></div><div class="line">first(<span class="number">2</span> * <span class="number">2</span>, <span class="number">4</span> * <span class="number">4</span>)</div></pre></td></tr></table></figure><p>此时，我们忽略了第二个参数，对于传名调用来说，它不需要解析 <code>y</code> 这个参数，只需要将它传入函数体即可；</p><p>而对于传值调用，则需要先解析出 <code>x</code> 和 <code>y</code> 的值，即使 <code>y</code> 的值不会在函数体内使用到。</p><p>其次，传名调用可以避免无限循环问题；</p><p>对于上面的例子来说，我们可以这么调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">first(1, loop)</div></pre></td></tr></table></figure><p>对于传名调用来说，由于它是直接传入函数体，然后，函数体并没有使用 <code>y</code> 这个参数；</p><p>此时，我们就避免了对 <code>loop</code> 的解析工作；</p><p>但是对于传值调用则不然，我们还是要对 <code>loop</code> 进行解析，从而出现无限循环问题。</p><h3 id="5-4-默认传值调用的原因"><a href="#5-4-默认传值调用的原因" class="headerlink" title="5.4 默认传值调用的原因"></a>5.4 默认传值调用的原因</h3><p>既然传名调用具有那么多的好处，但是为什么还要默认使用传值调用呢？</p><p>这是因为传值调用在具体实践过程中，比传名调用的执行要快；</p><p>其次，由于 Scala 并不是纯函数式语言，实际上，它的函数还是允许有副作用的；</p><p>并且同时还要支持和 Java 的互调用，而 Java 是指令式语言，采用传值调用显然会更好些。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-代换模型&quot;&gt;&lt;a href=&quot;#1-代换模型&quot; class=&quot;headerlink&quot; title=&quot;1. 代换模型&quot;&gt;&lt;/a&gt;1. 代换模型&lt;/h2&gt;&lt;p&gt;Scala 使用代换模型对函数和表达式进行解析工作；&lt;/p&gt;&lt;p&gt;所谓的代换模型就是类似平常算术的过程；&lt;/p&gt;&lt;p&gt;从左到右地将函数和表达式一步一步转换，最终转换成值。&lt;/p&gt;&lt;p&gt;例如：&lt;/p&gt;&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; * &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) + (&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt; * &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Scala" scheme="https://wafer.li/categories/Scala/"/>
    
    
      <category term="Scala" scheme="https://wafer.li/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>装饰者模式(Decorator Pattern)</title>
    <link href="https://wafer.li/DesignPattern/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F(Decorator%20Pattern)/"/>
    <id>https://wafer.li/DesignPattern/装饰者模式(Decorator Pattern)/</id>
    <published>2017-03-19T15:00:00.000Z</published>
    <updated>2017-04-14T11:56:41.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>装饰者模式 <strong>动态的</strong> 将责任附加到对象上。</p><p>若要扩展功能，装饰者提供了比继承更有弹性的解决方案</p><a id="more"></a><h2 id="2-新的设计原则"><a href="#2-新的设计原则" class="headerlink" title="2. 新的设计原则"></a>2. 新的设计原则</h2><p><strong>类应当对扩展开放，对修改关闭</strong></p><p>这乍看上去很矛盾，如何做到“既开放又关闭” 呢？</p><p>实际上，我们可以采用 <strong>组合</strong> 和 <strong>委托</strong> 来达到扩展的目的；</p><p>而 <strong>避免因为扩展而需要修改代码</strong></p><blockquote><p>Bug 总是在修改、新增代码时引入的；<br>如果能够尽量减少对代码的反复更改，那么就可以更有效的减少和避免 Bug</p></blockquote><p>装饰者模式就很好的体现了 “开放——关闭” 原则。</p><h2 id="3-原理"><a href="#3-原理" class="headerlink" title="3. 原理"></a>3. 原理</h2><p>使用不同的 <strong>装饰者对象</strong> 来对 <strong>主体对象</strong> 进行装饰；</p><p><img src="http://i48.tinypic.com/2jabxva.jpg" alt=""></p><p>通过 <strong>委托</strong> 来进行组合工作。</p><p><img src="http://i50.tinypic.com/2zrg968.jpg" alt=""></p><p>这里有一个很重要的地方就是，为什么能实现上面图示的 <strong>包装</strong> 和 <strong>方法委托</strong></p><p>其使用到的技巧就是， <strong>装饰者对象实际上也是主体对象</strong>，即它们有相同的超类。</p><p>如果不具备相同超类的话，最多只能做到一层包装，而无法做到动态的，多层包装。</p><p>注意，这里采用相同的超类，实际上只是为了做到 <strong>类型匹配</strong>，而装饰者并没有从超类中继承它的 <strong>行为</strong>。</p><blockquote><p>继承的原罪在于， <strong>在运行时，行为需要改变！</strong> 如果行为从继承中得到，那么它在编译时就会被确定，也就是所谓的 <strong>与具体实现绑定</strong>。</p><p>但是，如果<strong>行为不从继承中得到</strong>，那么继承反而成了优点，因为继承可以实现多态，为我们的动态扩展提供合适的条件</p></blockquote><h2 id="4-特点"><a href="#4-特点" class="headerlink" title="4. 特点"></a>4. 特点</h2><ol><li>装饰者和被装饰对象有 <strong>相同的超类型</strong></li><li>可以使用一个或者 <strong>多个</strong> 装饰者来包装对象</li><li>由于有相同的超类型，所以在需要被装饰对象的场合时，可以使用装饰过后的对象来替代</li><li><strong>装饰者可以在所委托被装饰者的行为之前、之后，加上自己的行为，以达到特定的目的</strong></li><li>对象可以在任何时候被装饰，可以在运行时，动态地、不限量地对对象进行装饰</li></ol><h2 id="5-UML-图解"><a href="#5-UML-图解" class="headerlink" title="5. UML 图解"></a>5. UML 图解</h2><p><img src="http://ww2.sinaimg.cn/large/65e4f1e6jw1faice8oa2nj20bq0aqwfr.jpg" alt=""></p><p>可以看到，装饰者和主体对象有一个 <strong>共同的超类</strong></p><p>同时， <code>Decorator</code> 和 <code>Component</code> 都是 <strong>抽象类</strong></p><p>对于实际的装饰者，他们都包含了一个 <code>Component</code> 实例，这就是被其装饰的对象，通过多态来进行方法委托。</p><p>图中的 <code>wrappedObject</code> 需要从外部获得，一般来说，是通过 <strong>构造函数</strong> 传入的。</p><h2 id="6-例子图解"><a href="#6-例子图解" class="headerlink" title="6. 例子图解"></a>6. 例子图解</h2><p><img src="https://ww1.sinaimg.cn/large/006tKfTcly1fdsfoe6vu5j30nn0amgm6.jpg" alt=""></p><h2 id="7-真实的装饰者模式——Java-IO"><a href="#7-真实的装饰者模式——Java-IO" class="headerlink" title="7. 真实的装饰者模式——Java IO"></a>7. 真实的装饰者模式——Java IO</h2><p>Java IO 库中大量使用了装饰者模式，这也就是为什么会出现如下的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">InputStream in =</div><div class="line">    <span class="keyword">new</span> BufferdInpuStream(<span class="keyword">new</span> FileInputSteram());</div></pre></td></tr></table></figure><p>可以看到 <code>FileInputSteram</code> 是被装饰的主体对象，而 <code>BufferdInpuStream</code> 是装饰对象。</p><h2 id="8-缺陷"><a href="#8-缺陷" class="headerlink" title="8. 缺陷"></a>8. 缺陷</h2><p>装饰者对象的缺陷很明显，就是会 <strong>增加大量的小对象</strong>。</p><p>同时，由于装饰者模式是通过 <strong>层层委托</strong> 来实现扩展的；</p><p>所以，当装饰者需要改变的时候，就需要将改变应用到 <strong>所有的装饰者</strong>；</p><p>此时，当装饰者数量较多时，更改难度大。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;p&gt;装饰者模式 &lt;strong&gt;动态的&lt;/strong&gt; 将责任附加到对象上。&lt;/p&gt;&lt;p&gt;若要扩展功能，装饰者提供了比继承更有弹性的解决方案&lt;/p&gt;
    
    </summary>
    
      <category term="DesignPattern" scheme="https://wafer.li/categories/DesignPattern/"/>
    
    
      <category term="DesignPattern" scheme="https://wafer.li/tags/DesignPattern/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 使用 Gradle</title>
    <link href="https://wafer.li/Kotlin/Kotlin%20%E4%BD%BF%E7%94%A8%20Gradle/"/>
    <id>https://wafer.li/Kotlin/Kotlin 使用 Gradle/</id>
    <published>2017-03-19T15:00:00.000Z</published>
    <updated>2017-04-14T11:56:41.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>一般来说，IntilliJ 会自动的给我们配置 Kotlin 的 Gradle 设置；</p><p>但是，有时候我们也想自己进行一些自定义的 Gradle 配置；</p><p>下面就来总结几个常用的配置方法</p><a id="more"></a><h2 id="2-去除-src-中的-java-目录"><a href="#2-去除-src-中的-java-目录" class="headerlink" title="2. 去除 src 中的 java 目录"></a>2. 去除 <code>src</code> 中的 <code>java</code> 目录</h2><p>虽然说 Kotlin 经常和 Java 混着写，但是，有时候我们想写一个纯 Kotlin 程序的时候，却发现 <code>src</code> 目录中一直存在着一个 <code>java</code> 目录；</p><p>这着实激起了我的强迫症，解决方法如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sourceSets &#123;</div><div class="line">    main.java.srcDirs = [<span class="string">'src/main/kotlin'</span>]</div><div class="line">    test.java.srcDirs = [<span class="string">'src/test/kotlin'</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这是 gradle java 插件中常用的指定源文件位置的方法；</p><p>不过需要注意的是，即使我们使用的是 kotlin 插件，也要使用 <code>main.java</code>；</p><p>而不能使用 <code>main.kotlin</code></p><p>这应该是因为 kotlin 插件继承了 java 插件的源文件位置设定的结果。</p><h2 id="2-指定字节码版本"><a href="#2-指定字节码版本" class="headerlink" title="2. 指定字节码版本"></a>2. 指定字节码版本</h2><p>有时候我们想使用一些高级的语言特性，不想为低级的 JVM 编写代码；</p><p>这个时候就需要指定字节码版本；</p><p>在 java 插件中，我们可以通过 <code>sourceCompatibility</code> 和 <code>targetCompatibility</code> 来解决这个问题；</p><p>不过在 Kotlin 中，我们还有对应的 JVM 版本和语言和 API 版本可以设定（注意，仅在 Kotlin 1.1 之后可以使用）；</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">compileKotlin &#123;</div><div class="line">    sourceCompatibility = JavaVersion.VERSION_1_8</div><div class="line">    targetCompatibility = JavaVersion.VERSION_1_8</div><div class="line"></div><div class="line">    kotlinOptions &#123;</div><div class="line">        jvmTarget = <span class="string">"1.8"</span></div><div class="line">        apiVersion = <span class="string">"1.1"</span></div><div class="line">        languageVersion = <span class="string">"1.1"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>注意一定要在 <code>compileKotiln</code> 中，因为这个是编译 Kotlin 时候的选项。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;p&gt;一般来说，IntilliJ 会自动的给我们配置 Kotlin 的 Gradle 设置；&lt;/p&gt;&lt;p&gt;但是，有时候我们也想自己进行一些自定义的 Gradle 配置；&lt;/p&gt;&lt;p&gt;下面就来总结几个常用的配置方法&lt;/p&gt;
    
    </summary>
    
      <category term="Kotlin" scheme="https://wafer.li/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="https://wafer.li/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 空安全</title>
    <link href="https://wafer.li/Kotlin/Kotlin%20%E7%A9%BA%E5%AE%89%E5%85%A8/"/>
    <id>https://wafer.li/Kotlin/Kotlin 空安全/</id>
    <published>2017-03-16T15:00:00.000Z</published>
    <updated>2017-04-14T11:56:41.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>Kotlin 对于 Java 的一个很大的改进在于，Kotlin 的类型系统目标在于要<strong>消除 <code>NullPointerException</code></strong>或者 NPE。</p><p>所以 Kotlin 提供了一个健壮的 Null 检查系统。</p><a id="more"></a><h2 id="2-产生-NPE-的原因"><a href="#2-产生-NPE-的原因" class="headerlink" title="2. 产生 NPE 的原因"></a>2. 产生 NPE 的原因</h2><p>可能产生 NPE 的原因如下：</p><ul><li>显式调用 <code>throw NullPointerException()</code></li><li>使用 <code>!!</code> 操作符</li><li>Java 代码造成的</li><li>一些前后矛盾的初始化（在构造函数中没有初始化的 <code>this</code> 在其他地方使用）</li></ul><h2 id="3-Kotlin-类型系统"><a href="#3-Kotlin-类型系统" class="headerlink" title="3. Kotlin 类型系统"></a>3. Kotlin 类型系统</h2><p>在 Kotlin 中，类型系统将变量引用分成了<strong>两种类型</strong>：可以为 <code>null</code> 的类型（nullable），和不能为 <code>null</code> 的类型（non-null）</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a: String = <span class="string">"abc"</span></div><div class="line">a = <span class="literal">null</span> <span class="comment">// compilation error</span></div></pre></td></tr></table></figure><p>在类型后添加一个问号(<code>?</code>)来表明它是可以为空的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> b: String? = <span class="string">"abc"</span></div><div class="line">b = <span class="literal">null</span> <span class="comment">// ok</span></div></pre></td></tr></table></figure><p>此时，对于 <code>a</code>，由于它不会产生 NPE，你可以安全的访问它的成员。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> l = a.length</div></pre></td></tr></table></figure><p>但是对于 <code>b</code>，由于它可能为空，所以直接访问它，编译器会报错</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> l = b.length <span class="comment">// error: variable 'b' can be null</span></div></pre></td></tr></table></figure><p>但是我们依旧需要访问 <code>b</code> 啊！</p><h2 id="4-访问可能为空变量的方法"><a href="#4-访问可能为空变量的方法" class="headerlink" title="4. 访问可能为空变量的方法"></a>4. 访问可能为空变量的方法</h2><p>下面就介绍几种方法来进行 <code>b</code> 的安全访问。</p><h3 id="4-1-显式检查"><a href="#4-1-显式检查" class="headerlink" title="4.1 显式检查"></a>4.1 显式检查</h3><p>首先你可以直接对 <code>b</code> 进行空检查</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> l = <span class="keyword">if</span> (b != <span class="literal">null</span>) b.length <span class="keyword">else</span> <span class="number">-1</span></div></pre></td></tr></table></figure><p>由于 Kotlin 具有智能造型特性，还可以直接在 <code>if</code> 语句中访问 <code>b</code> 的成员。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (b != <span class="literal">null</span> &amp;&amp; b.length &gt; <span class="number">0</span>)</div><div class="line">  print(<span class="string">"String of length <span class="subst">$&#123;b.length&#125;</span>"</span>)</div><div class="line"><span class="keyword">else</span></div><div class="line">  print(<span class="string">"Empty string"</span>)</div></pre></td></tr></table></figure><p>当然，这只适用于当 <code>b</code> 符合智能造型条件的情景，否则，<code>b</code> 有可能在检查之后再次变为空。</p><h3 id="4-2-使用安全访问"><a href="#4-2-使用安全访问" class="headerlink" title="4.2 使用安全访问"></a>4.2 使用安全访问</h3><p>第二个方法是采用安全访问操作符(<code>?.</code>)，即在点号(<code>.</code>)前加一个问号(<code>?</code>)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">b?.length</div></pre></td></tr></table></figure><p>这个表达式当 <code>b</code> 不为空时返回 <code>b.length</code>；<br>当 <code>b</code> 为空时，返回 <code>null</code>。</p><p>表达式的返回结果是 <code>Int?</code></p><p>安全访问在链式操作中很有用。<br>比如说，<code>bob</code> 是一个 <code>Employee</code>，他有可能被派往一个 <code>Department</code>，这个部门也许会存在一个主管。<br>那么我们通过以下调用链来获取 <code>bob</code> 所在部门主管的名字。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bob?.department?.head?.name</div></pre></td></tr></table></figure><p>当调用链上的任何一个值为 <code>null</code> 时，表达式的返回值都为 <code>null</code>。</p><p>如果你想对集合中的非空元素进行某种操作，可以结合安全访问和 <code>let()</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> listWithNulls: List&lt;String?&gt; = listOf(<span class="string">"A"</span>, <span class="literal">null</span>)</div><div class="line"><span class="keyword">for</span> (item <span class="keyword">in</span> listWithNulls) &#123;</div><div class="line">     item?.let &#123; println(it) &#125; <span class="comment">// prints A and ignores null</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p><code>let</code> 操作接受一个 lambda 表达式，并返回 lambda 表达式的值。<a href="https://github.com/JetBrains/kotlin/blob/1.0.3/libraries/stdlib/src/kotlin/util/Standard.kt#L55" target="_blank" rel="noopener">源代码</a></p></blockquote><h3 id="4-3-Elvis-表达式"><a href="#4-3-Elvis-表达式" class="headerlink" title="4.3 Elvis 表达式"></a>4.3 Elvis 表达式</h3><p>如果对于一个引用 <code>r</code>，我们需要：<br>当 <code>r</code> 不为空时，使用它；否则我们就使用一个其他的值(<code>x</code>)</p><p>我们可以使用如下的语句：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> l: <span class="built_in">Int</span> = <span class="keyword">if</span> (b != <span class="literal">null</span>) b.length <span class="keyword">else</span> <span class="number">-1</span></div></pre></td></tr></table></figure><p>一个更为简单的方法是使用 Elvis 表达式(<code>?:</code>)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> l = b?.length ?: <span class="number">-1</span></div></pre></td></tr></table></figure><p>如果在 <code>?:</code> 的左边的值不为空，那么 Elvis 操作符就返回这个值，否则就返回右边的值。</p><p>与 Java 中的条件操作符不同的是，只有当 <code>?:</code> 的左边的值<strong>为空</strong>时，才会执行右边的语句；<br>所以这个操作符不能像条件操作符一样执行一般的判断。</p><blockquote><p>想要实现条件操作符的功能，请使用单行的 <code>if-else</code> 表达式。</p></blockquote><h3 id="4-4-操作符"><a href="#4-4-操作符" class="headerlink" title="4.4 !! 操作符"></a>4.4 <code>!!</code> 操作符</h3><p>第三个方法是给 NPE 爱好者们使用的，我们可以使用 <code>b!!</code>，使用它来进行调用，结果就会和 Java 一样，会抛出 NPE。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> l = b!!.length</div></pre></td></tr></table></figure><p>也就是说，如果你需要 NPE，就使用这个操作符。</p><h2 id="5-安全的造型"><a href="#5-安全的造型" class="headerlink" title="5. 安全的造型"></a>5. 安全的造型</h2><p>一般的造型 <code>as</code> 在对象不相符的时候，会产生一个 <code>ClassCastException</code>。</p><p>一个更好的选择是使用 <code>as?</code>，一种更为安全的造型，当造型失败时，将会返回 <code>null</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> aInt: <span class="built_in">Int</span>? = a <span class="keyword">as</span>? <span class="built_in">Int</span>  <span class="comment">// return null if failure</span></div></pre></td></tr></table></figure><h2 id="6-空类型的集合"><a href="#6-空类型的集合" class="headerlink" title="6. 空类型的集合"></a>6. 空类型的集合</h2><p>如果你拥有一个可空类型的集合，想要过滤出非空类型。只需要写如下语句：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> nullableList: List&lt;<span class="built_in">Int</span>?&gt; = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="literal">null</span>, <span class="number">4</span>)</div><div class="line"><span class="keyword">val</span> intList: List&lt;<span class="built_in">Int</span>&gt; = nullableList.filterNotNull() <span class="comment">// non-null</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;p&gt;Kotlin 对于 Java 的一个很大的改进在于，Kotlin 的类型系统目标在于要&lt;strong&gt;消除 &lt;code&gt;NullPointerException&lt;/code&gt;&lt;/strong&gt;或者 NPE。&lt;/p&gt;&lt;p&gt;所以 Kotlin 提供了一个健壮的 Null 检查系统。&lt;/p&gt;
    
    </summary>
    
      <category term="Kotlin" scheme="https://wafer.li/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="https://wafer.li/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 基本类型</title>
    <link href="https://wafer.li/Kotlin/Kotlin%20%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"/>
    <id>https://wafer.li/Kotlin/Kotlin 基本类型/</id>
    <published>2017-03-16T15:00:00.000Z</published>
    <updated>2017-04-09T04:39:49.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><strong>Kotlin 中，任何事物都是对象。</strong></p><h2 id="1-数字类型"><a href="#1-数字类型" class="headerlink" title="1. 数字类型"></a>1. 数字类型</h2><p>Kotlin 中的数字类型有 <code>Double</code>、<code>Float</code>、<code>Long</code>、<code>Int</code>、<code>Short</code>、<code>Byte</code></p><a id="more"></a><h3 id="1-1-位宽"><a href="#1-1-位宽" class="headerlink" title="1.1 位宽"></a>1.1 位宽</h3><div class="table-container"><table><thead><tr><th style="text-align:center">Type</th><th style="text-align:center">BitWidth</th></tr></thead><tbody><tr><td style="text-align:center">Double</td><td style="text-align:center">64</td></tr><tr><td style="text-align:center">Float</td><td style="text-align:center">32</td></tr><tr><td style="text-align:center">Long</td><td style="text-align:center">64</td></tr><tr><td style="text-align:center">Int</td><td style="text-align:center">32</td></tr><tr><td style="text-align:center">Short</td><td style="text-align:center">16</td></tr><tr><td style="text-align:center">Byte</td><td style="text-align:center">8</td></tr></tbody></table></div><blockquote><p>注意，在 Kotlin 中，<strong>字符不是一种数字类型</strong></p></blockquote><h3 id="1-2-字面常量"><a href="#1-2-字面常量" class="headerlink" title="1.2 字面常量"></a>1.2 字面常量</h3><p>数字类型可以有多种字面表示形式。</p><ol><li>整数</li></ol><ul><li>十进制数字 <code>123</code><ul><li><code>Long</code> 类型通过加 <code>L</code> 后缀实现: <code>123L</code></li></ul></li><li>十六进制 <code>0x0F</code></li><li>二进制 <code>0b00001011</code></li></ul><ol><li>浮点数<ul><li>默认为 <code>Double</code> 类型: <code>123.5</code>, <code>123.5e10</code></li><li>使用 <code>f</code> 或者 <code>F</code> 后缀来表示 <code>Float</code>: <code>123.5f</code></li></ul></li></ol><h3 id="1-3-表示法"><a href="#1-3-表示法" class="headerlink" title="1.3 表示法"></a>1.3 表示法</h3><p>Kotlin 中，任何数字都会被<strong>自动装箱</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> a: <span class="built_in">Int</span> = <span class="number">10000</span></div><div class="line">print(a === a) <span class="comment">// true</span></div><div class="line"><span class="keyword">val</span> boxedA: <span class="built_in">Int</span>? = a <span class="comment">// 在类型后加 ? 表示一个 Nullable 对象</span></div><div class="line"><span class="keyword">val</span> anotherBoxedA: <span class="built_in">Int</span>? = a</div><div class="line">print(boxedA === anotherBoxedA) <span class="comment">// false</span></div><div class="line">print(boxedA == anotherBoxedA) <span class="comment">// true</span></div></pre></td></tr></table></figure><blockquote><p>上面是一个很好的例子，由于所有的数字都会被自动装箱，所以 <strong><code>boxedA</code> 与 <code>anotherBoxedA</code> 不一致</strong>。<br>但是由于两者均指向 <code>a</code>，所以保持了相等性。</p><p>这里的 <code>Int</code> 与 Java 的 <code>Integer</code> 相同</p></blockquote><h3 id="1-4-转换"><a href="#1-4-转换" class="headerlink" title="1.4 转换"></a>1.4 转换</h3><p>Kotlin 的原则之一就是尽量让事务明显化。<br>所以，Kotlin <strong>禁止隐式转换</strong>，就算是隐式向上转换也是不允许的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> a: <span class="built_in">Int</span>? = <span class="number">1</span></div><div class="line"><span class="keyword">val</span> b: <span class="built_in">Long</span>? = a</div><div class="line">print(a == b) <span class="comment">// false</span></div></pre></td></tr></table></figure><blockquote><p>由于 <code>Int</code> 不是 <code>Long</code> 的子类，而且禁止隐式转换，所以即使 <code>b</code> 指向了 <code>a</code>，它们也不相等。</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> b: <span class="built_in">Byte</span> = <span class="number">1</span> <span class="comment">// OK</span></div><div class="line"><span class="keyword">val</span> i: <span class="built_in">Int</span> = b <span class="comment">// ERROR</span></div></pre></td></tr></table></figure><blockquote><p>字面值会经编译器静态检查赋值给整数形式的变量，但是由于禁止隐式转换，第二个语句会产生 ERROR。</p></blockquote><p>需要转换时，应采用内置的转换方法</p><ul><li><code>toByte()</code></li><li><code>toShort()</code></li><li><code>toInt()</code></li><li><code>toLong()</code></li><li><code>toFloat()</code></li><li><code>toDouble()</code></li><li><code>toChar()</code></li></ul><h3 id="1-5-位运算符"><a href="#1-5-位运算符" class="headerlink" title="1.5 位运算符"></a>1.5 位运算符</h3><p>Kotlin 支持全套 Java 的普通数字运算符。<br>但关于位运算符则稍有不同，Kotlin 采用<strong>单词型</strong>而非 Java 的<strong>符号型</strong>位运算符。</p><p>下面是 Kotlin 的位运算符列表</p><ul><li><code>shl(bits)</code> =&gt; 位左移，相当于 Java 的 <code>&lt;&lt;</code></li><li><code>shr(bits)</code> =&gt; 位右移，相当于 Java 的 <code>&gt;&gt;</code></li><li><code>ushr(bits)</code> =&gt; 无符号数右移，相当于 Java 的 <code>&gt;&gt;&gt;</code></li><li><code>and(bits)</code> =&gt; 按位取与操作，相当于 Java 的 <code>&amp;</code></li><li><code>or(bits)</code> =&gt; 按位取或操作，相当于 Java 的 <code>|</code></li><li><code>xor(bits)</code> =&gt; 按位取异或操作，相当于 Java 的 <code>^</code></li><li><code>inv()</code> =&gt; 按位取反操作，相当于 Java 的 <code>~</code></li></ul><h2 id="2-字符类型"><a href="#2-字符类型" class="headerlink" title="2. 字符类型"></a>2. 字符类型</h2><p>字符类型使用 <code>Char</code> 来表示，<strong>字符不是数字</strong>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">check</span><span class="params">(c: <span class="type">Char</span>)</span></span> &#123;</div><div class="line">    <span class="keyword">if</span> (c == <span class="number">1</span>) <span class="comment">// ERROR</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>字符使用单引号括起来<code>&#39;1&#39;</code>，反斜杠 <code>\</code> 表示转义，转义字符和 Java 相同。</p><p>和数字类型一样，字符类型也被自动装箱，保持相等性，而不保持一致性。</p><h2 id="3-布尔类型"><a href="#3-布尔类型" class="headerlink" title="3. 布尔类型"></a>3. 布尔类型</h2><p>使用 <code>Boolean</code> 来表示布尔类型，布尔类型有两个值，<code>true</code> 和 <code>false</code>。</p><p>内置的逻辑布尔操作与 Java 相同。</p><h2 id="4-数组"><a href="#4-数组" class="headerlink" title="4. 数组"></a>4. 数组</h2><p>使用 <code>Array</code> 表示数组，这是一个泛型类，类似于 Java 中的 <code>ArrayList&lt;T&gt;</code>，但并不完全相同。</p><p>数组是 <strong>invariant</strong> 的，也就是说不能把 <code>Array&lt;String&gt;</code> 的数组赋予 <code>Array&lt;Any&gt;</code> 的实例，这会产生一个<strong>runtime failure</strong></p><blockquote><p>Kotlin 同样拥有 <code>List</code> 和 <code>ArrayList</code> 类型，在 JVM 上，<code>Array</code> 会被替换成 Java array。</p><p>所以，事实上 <code>Array</code> 只是</p></blockquote><h3 id="4-1-创建数组"><a href="#4-1-创建数组" class="headerlink" title="4.1 创建数组"></a>4.1 创建数组</h3><p>使用 <code>arrayOf()</code> 创建数组。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> array = arrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</div><div class="line"><span class="keyword">val</span> nullArray = arrayOfNulls(<span class="number">5</span>) <span class="comment">// Array with 5 null elements</span></div></pre></td></tr></table></figure><blockquote><p>注意变量具有自动推断功能，类似 C++ 中的 <code>auto</code></p></blockquote><p>也可以使用 <code>Array()</code> 创建数组。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Crates an Array&lt;String&gt; with values</span></div><div class="line"><span class="comment">// ["0", "1", "4", "9", "16"]</span></div><div class="line"><span class="keyword">val</span> asc = Array(<span class="number">5</span>, &#123;i -&gt; (i * i).toString()&#125;)</div></pre></td></tr></table></figure><p>Kotlin 内置了一些特定的数组类型，如 <code>IntArray</code>, <code>ByteArray</code> 等。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> x: IntArray = intArrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</div></pre></td></tr></table></figure><h3 id="4-2-访问数组"><a href="#4-2-访问数组" class="headerlink" title="4.2 访问数组"></a>4.2 访问数组</h3><p><code>Array</code> 内置了 <code>get()</code> 和 <code>set()</code> 方法和 <code>size</code> 属性。<br>但是也支持使用方括号进行访问的操作 <code>[]</code></p><h3 id="4-3-多维数组"><a href="#4-3-多维数组" class="headerlink" title="4.3 多维数组"></a>4.3 多维数组</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> int2d: Array&lt;IntArray&gt;</div><div class="line">int2d = arrayOf(intArrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), intArrayOf(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>), intArrayOf(<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>))</div></pre></td></tr></table></figure><h2 id="5-字符串"><a href="#5-字符串" class="headerlink" title="5. 字符串"></a>5. 字符串</h2><p>使用 <code>String</code> 来表示字符串。与 Java 一样，字符串是一个不可变对象。</p><h3 id="5-1-相对-Java-增加的新特性"><a href="#5-1-相对-Java-增加的新特性" class="headerlink" title="5.1 相对 Java 增加的新特性"></a>5.1 相对 Java 增加的新特性</h3><p>与 Java 不同的是，Kotlin 支持使用方括号 <code>[]</code> 来获取字符串中的字符，同时也支持对字符串字符进行遍历。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (c <span class="keyword">in</span> str) &#123;</div><div class="line">    println(c)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="5-2-raw-string"><a href="#5-2-raw-string" class="headerlink" title="5.2 raw string"></a>5.2 raw string</h3><p>此外，Kotlin 还吸收了 Python 的多行字符串特性，使用三个双引号来表示一个 <strong>raw string</strong>，raw string 不接受转义，其中任何的字符都是字面字符。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> rawString = <span class="string">"""</span></div><div class="line"><span class="string">    This is a raw string.</span></div><div class="line"><span class="string">    \n and \t will be displayed as</span></div><div class="line"><span class="string">    its literal stirng.</span></div><div class="line"><span class="string">"""</span></div></pre></td></tr></table></figure><h3 id="5-3-字符串模板"><a href="#5-3-字符串模板" class="headerlink" title="5.3 字符串模板"></a>5.3 字符串模板</h3><p>Kotlin 字符串具有模板功能，使用 <code>$</code> 来指定参数<br>例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> i = <span class="number">10</span></div><div class="line"><span class="keyword">val</span> s = <span class="string">"i = <span class="variable">$i</span>"</span> <span class="comment">// evaluates to "i = 10"</span></div></pre></td></tr></table></figure><p>也可以使用花括号 <code>{}</code> 来获取<strong>对象的属性</strong>填充到字符串中。<br>例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> s = <span class="string">"abc"</span></div><div class="line"><span class="keyword">val</span> str = <span class="string">"<span class="variable">$s</span>.lenth is <span class="subst">$&#123;s.lenth&#125;</span>"</span> <span class="comment">//  evaluates to "abc.length is 3"</span></div></pre></td></tr></table></figure><p>需要注意的是，字符串的模板功能不仅可以在普通字符串中使用，同时<strong>也可以在 raw string 中使用。</strong></p><p>此时，如果需要表示 <code>$</code> 美元符号，必须使用以下表达式：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> price = <span class="string">"""</span></div><div class="line"><span class="string"><span class="subst">$&#123;<span class="string">'$'</span>&#125;</span>9.99</span></div><div class="line"><span class="string">"""</span></div></pre></td></tr></table></figure><blockquote><p>这里使用双引号<code>${&quot;$&quot;}</code>也是可以的，模板引用一个字面量时，结果就是它本身。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Kotlin 中，任何事物都是对象。&lt;/strong&gt;&lt;/p&gt;&lt;h2 id=&quot;1-数字类型&quot;&gt;&lt;a href=&quot;#1-数字类型&quot; class=&quot;headerlink&quot; title=&quot;1. 数字类型&quot;&gt;&lt;/a&gt;1. 数字类型&lt;/h2&gt;&lt;p&gt;Kotlin 中的数字类型有 &lt;code&gt;Double&lt;/code&gt;、&lt;code&gt;Float&lt;/code&gt;、&lt;code&gt;Long&lt;/code&gt;、&lt;code&gt;Int&lt;/code&gt;、&lt;code&gt;Short&lt;/code&gt;、&lt;code&gt;Byte&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Kotlin" scheme="https://wafer.li/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="https://wafer.li/tags/Kotlin/"/>
    
  </entry>
  
</feed>
