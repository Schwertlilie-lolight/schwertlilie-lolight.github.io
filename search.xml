<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[解决 Travis CI 总是更新旧博客的问题]]></title>
    <url>%2FHexo%2F%E8%A7%A3%E5%86%B3%20Travis%20CI%20%E6%80%BB%E6%98%AF%E6%9B%B4%E6%96%B0%E6%97%A7%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[本文着重介绍一下如何解决 Travis CI 在进行自动集成的时候，总是会更新旧博客的问题。之前有想过要把这篇文章合并到上一篇里面，不过这个问题比较隐蔽，而且较难解决，最后还是新开一篇文章来详细讲一下该怎么做，防止以后有人再被这个问题困扰。1. 初级症状——master 的 commit 只有两个在经过上一篇文章的折腾之后，Travis CI 总算是能够正常执行脚本并提交到 GitHub 上进行；不过，如果你查看 master 的 commit 情况就会发现，你原本满满当当的页面构建历史突然就只有两个了。博客最重要的就是积累，现在一个构建你的博客就变成新博客了，简直不能忍。这个问题的原因在于你的博客目录下没有之前 deploy 会生成的 .deploy_git 这个目录；这个目录实际上也就是你的 master 分支，在没有这个目录的情况下，hexo-deploy-git 插件会自动生成 .deploy_git，并将 public 复制到这个目录下；然后插件会进行 force push！这就是你的 commit 历史会丢失的原因！解决方法也很简单，首先你需要在本地进行一次 deploy，来恢复你的 commit 历史然后，只需要在每次构建的时候都 clone 一下这个目录，这样你的历史就不会丢失了。往 .travis.yml 加入如下脚本即可：12before_install: - git clone --branch=master &#123;your_blog_repo_git_url&#125; .deploy_git2. 高级症状——旧博客总是被更新这个症状是本文的重点，也是本文最终要解决的问题。症状的具体表现在于，博客的更新时间总是最新的；就连你没有更新过的旧博客也一样！如图所示，图片中的更新时间全部都一样，按常理来说这是不可能的。这到底是什么原因呢？2.1 症状原因经过一番查询之后，我查到了这篇博文；里面提到，Hexo 并不识别文章的更新时间，而是将这个更新时间交给了系统进行；实际上 Hexo 的文章更改时间就是 markdown 文件的 最后修改时间；到这里，原因已经很明显了：由于 Travis CI 在构建的时候，总是 重新 clone repo，这就造成了 所有文件的最后修改时间都是最新的 clone 时间；实际上，这并不是 Travis CI 的问题，而是 git 的问题，git 由于分布式的原因，并不会保留文件的最后修改时间；不过，作为一个博客系统来说，我们可以采用 git 的最后 commit 时间来替代，这样子就能恢复文件的修改时间了。2.2 解决办法解决方案清楚之后我就开始寻找相关的实现，不过网上现有的一步到位修改文件 last modified time 的实现都不能解决 non-ASCII 的问题；所谓 non-ASCII 的问题就是当你的文件名含有中文或者其他的字符的时候，脚本就会炸掉，执行不下去。最后面还是毛主席说得好，自己动手丰衣足食，在参照了这个 StackOverflow 的答案之后，我编写了下面的脚本，终于解决了 non-ASCII 文件名的问题：123456789101112131415161718192021222324# -*- coding: utf-8 -*-import subprocessimport osimport shlexif __name__ != '__main__': raise ImportError("%s should not be used as a module." % __name__)# 'git ls-files -z | xargs -0 -n1 -I&#123;&#125; -- git log -1 --format="%ct &#123;&#125;" &#123;&#125; | sort'git_ls_cmd = 'git ls-files -z'xargs_cmd = 'xargs -0 -n1 -I&#123;&#125; -- git log -1 --format="%ct &#123;&#125;" &#123;&#125;'sort_cmd = 'sort'work_dir = os.getcwd()git_ls_result = subprocess.Popen(shlex.split(git_ls_cmd), stdout=subprocess.PIPE)xargs_result = subprocess.Popen(shlex.split(xargs_cmd), stdin=git_ls_result.stdout, stdout=subprocess.PIPE)result = subprocess.check_output('sort', stdin=xargs_result.stdout)timestamp_file_list = [tuple(it.split(' ', 1)) for it in result.decode('utf-8').split('\n')][:-1]for timestamp, file_path in timestamp_file_list: os.utime(os.path.join(work_dir, file_path), (int(timestamp), int(timestamp)))你也可以在这个 gist里面获取其代码；在你把 repo 克隆下来，进行了 user.name 和 user.email 的配置之后，用 python3 执行一下这个脚本，就能恢复文件的最后修改时间。相关的 .travis.yml 配置：1234567before_install: # Git Config - git config --global user.name "your_user_name" - git config --global user.email "your_email"# Restore last modified time - chmod +x git_reset_mtime.py - python3 ./git_reset_mtime.py特别注意！必须使用 python3 执行，本脚本目前最低支持到 python 3.4之所以是 3.4 是因为 Travis CI 的 python3 的最新版本就只到 3.4；不能采用 3.5 之后才能使用的 subprocess.run()2.3 Clone Depth 导致的问题在经过上面的一番折腾之后，你会发现一个奇怪的现象：在本地测试脚本完全成功，但是把脚本放到 Travis CI 去运行却不行， 最多只能恢复几天前的修改时间。在查看了一下 Travis CI 的 log 之后，我发现：Travis CI 默认会采用 --depth=50 这个参数，也就是说，它之后克隆 前 50 个 commit；而我们的脚本需要完整的 git 历史记录才能正确的恢复文件的修改时间；所以，我们还需要取消 Travis CI 的默认 depth 参数，让它克隆我们完整的 git 仓库:12git: depth: false3. 最终的 Travis CI 脚本这里给出我最终测试成功的 Travis CI 脚本给大家参考：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475dist: trustysudo: requiredaddons: ssh_known_hosts: - github.com - git.coding.net apt: packages: - nasmenv: global: - ATOM_WRITER_PATCH_URL=https://raw.githubusercontent.com/wafer-li/hexo-generator-atom-markdown-writer-meta/9f8ab23d42a60a9fa7ef8eed161f216a7716d14d/lib/generator.js - ATOM_WRITER_DIR=node_modules/hexo-generator-atom-markdown-writer-meta/ - TZ=Asia/Tokyolanguage: node_jsnode_js: nodebranches: only: - sourcegit: depth: false submodules: falsecache: apt: true directories: - node_modulesbefore_install: # Git Config - sed -i 's/git@github.com:/https:\/\/github.com\//' .gitmodules - git config --global user.name "wafer-li" - git config --global user.email "omyshokami@gmail.com" # Restore last modified time - "git ls-files -z | while read -d '' path; do touch -d \"$(git log -1 --format=\"@%ct\" \"$path\")\" \"$path\"; done" # Submodules - git submodule update --recursive --remote --init # Deploy history - git clone --branch=master --single-branch https://github.com/wafer-li/wafer-li.github.io.git .deploy_git # SSH Setup - openssl aes-256-cbc -K $encrypted_XXXXXXXXX_key -iv $encrypted_XXXXXXXXX_iv -in blog_deploy_key.enc -out blog_deploy_key -d - eval "$(ssh-agent -s)" - chmod 600 ./blog_deploy_key - ssh-add ./blog_deploy_keyinstall: npm installbefore_script: # Patch atom writer generator - curl $ATOM_WRITER_PATCH_URL &gt;| $&#123;ATOM_WRITER_DIR&#125;/lib/generator.js ## Theme Dependencies - cd themes/next-reloaded # canvas-nest - git clone https://github.com/theme-next/theme-next-canvas-nest source/lib/canvas-nest # fancybox3 - git clone https://github.com/theme-next/theme-next-fancybox3 source/lib/fancybox # reading_progress - git clone https://github.com/theme-next/theme-next-reading-progress source/lib/reading_progress - cd ../..script: - hexo clean - hexo g -d --config source/_data/next.yml4. 参考资料从 Git 提交历史中「恢复」文件修改时间How to retrieve the last modification date of all files in a git repositorygit-tools/git-restore-mtime at master · MestreLion/git-tools]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Trivas CI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 集成 Travis CI 自动部署博文]]></title>
    <url>%2FHexo%2FHexo%20%E9%9B%86%E6%88%90%20Travis%20CI%20%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%8D%9A%E6%96%87%2F</url>
    <content type="text"><![CDATA[这个想法是我在折腾 Hexo Next 6.0 的时候发现的，有位仁兄在 Next 的新 repo 问如何处理 CI 问题，受到他的启发，我就开始折腾使用 Travis CI 进行博客的自动部署了。1. 为什么要用 CI 来部署博客遇到一项新技术，一个好习惯就是问一下自己 为什么要用这个新技术，它带来了什么好处，解决了什么问题？否则就会陷入为了使用新技术而使用新技术的陷阱之中。那么为什么要用 CI 来部署呢？好处是显而易见的：在未采用 CI 的时候，编写完博客总需要自己手动 hexo g -d，这种工作是重复性的、枯燥的，那么就应当尽量寻找让重复性的工作进行自动化的方法；在使用 CI 之后，我只需要执行 git push，将博客的 markdown source 推到远端仓库，剩下的静态页面构建过程就由 CI 接手进行，而不需要我手动打字，而且还占用我的 CPU。这虽然方便，但是不禁会有人担心：如果每 push 一次就会自己构建，博客会不会因为 push 上去了一些不好的东西而搞炸了？其实这种担心是多余的，只需要在进行了大面积更改的时候先在本地查看一下，如果没有问题就再 push 就行了，这时候虽然需要本地生成，但是你不可能整天重构你的博客，所以 CI 的效率提升还是存在的。2. Travis CI 的配置流程本博客采用 Travis CI 作为持续集成工具，下面就介绍一下基本的配置流程。由于 Travis CI 比较流行，注册和关联 repo 这种操作就不介绍了。2.1 获取相关权限在配置和使用 Travis CI 之前，我们首先要做的就是为 Travis CI 获取其所需要的权限。当然，获取所需要的权限有很多种方法，这里推荐两种，分别为 Access Token和 Deploy Key这两种各有好处，Deploy Key 的好处在于安全性比较高，Access Token 的好处是较为灵活。下面每种都写了推荐使用的 repo，你可以根据你的 repo 的实际情况来选择。2.1.1 使用 Depoly Key 进行部署本方法适用于大多数的公有博客仓库同时，仓库内不具备私有的子模块建议首选Deploy Key 是一个 SSH Key，区别于个人 SSH Key 的是，它仅对配置了它的仓库有效；也就是说，如果应用使用了 Deploy Key，那么应用的权限就仅限于 repo 之中，准确的来说，是仅限于 repo 的 文件读写权限。这就给 Deploy Key 带来了很高的安全度，即使 Key 泄漏了，威胁到的也只是设置了它的仓库，而不会威胁帐号本身。使用了 SSH Key 也就意味着我们是使用 SSH 和 GitHub 进行连接，那么对 SSH 的配置是必不可少的；2.1.1.1 密钥生成首先我们要生成一对公钥和私钥，这个在很多地方都有操作介绍了，这里就不多讲。1ssh-keygen -t rsa -b 4096 -C "email" -f key_file -N ''接着，到 repo 的 Settings 里面创建一个 Deploy Key，把公钥的内容粘贴进去。如果是 coding.net 的话，是配置在 部署公钥 之中。然后我们把公钥删掉，避免你误把它加入了 git 中。1rm -f key_file.pub2.1.1.2 使用 Travis 命令行程序进行加密密钥显然是不能给别人看的，因此，我们就要把密钥通过 travis 程序加密。首先，我们要安装 travis1gem install travis如果你的 ruby 版本太旧，可能还需要先升级一下。最好在你的 repo 目录下执行 travis 命令方便 travis 自动识别仓库。然后，我们通过 travis 来登录：1travis login这是为了让 travis 自动将加密好的东西上传到 Settings 的环境变量中，这样就不用我们配置 .travis.yml 文件了。接着，我们对文件进行加密：1travis encrypt key_file随后，我们把生成的 .enc 文件加入 git 中，并把私钥删掉。12rm -f key_filegit add key_file.enc2.1.1.3 配置 Known Hosts 和 SSH接下来，我们就进行 SSH 的相关配置；首先需要配置的是 Known Hosts，否则 CI 就会卡在问你是否要继续那里。然后，我们使用 openssl 把之前加密的文件解压成私钥，最后把私钥配置上就行了。1234567891011addons: ssh_known_hosts: - github.com - git.coding.netbefore_install: # SSH Setup - openssl aes-256-cbc -K $encrypted_693585a97b8c_key -iv $encrypted_693585a97b8c_iv -in blog_deploy_key.enc -out blog_deploy_key -d - eval "$(ssh-agent -s)" - chmod 600 ./blog_deploy_key - ssh-add ./blog_deploy_key2.1.2 获取 Access Token本方法适用于具有私有 Submodule 的仓库的情况GitHub 获取 Access Token 的步骤如下：12Settings -&gt; Developer settings -&gt; Personal access token-&gt; Generate new token接着就进入创建 Access Token 的页面了，对于一个博客的 CI 来说，我们需要的权限比较少，我尝试了一下只需要 public_repo 的权限即可；为了尽量保证我们 GitHub 帐号的安全，能少给权限就少给。然后我们选择生成，此时会返回到 Personal access token 的页面，并显示我们刚才生成的 access token。需要注意的是，这个 access token 只会在这一个页面显示一次，切记要复制下来，否则就只能 重新生成。然后我们到博客 repo 的 Travis CI 设置页面中新建一个环境变量，将这个 Access Token 粘贴到环境变量的 value 中。这里要注意一定要关掉 Display in log 的选项，否则你的 Access Token 就泄漏了。2.2 只构建含有 .travis.yml 文件的分支对于本博客而言，我采用单 repo 双分支管理，即一个 source 分支保存原始的 markdown 文件，另一个 master 分支保存用于部署的 HTML。对于这种情况，我们就 必须要 在 Travis CI 的 repo 设置页面 中勾选 只构建含有 .travis.yml 文件的分支；由于 Travis CI 会侦听 commit 事件进行自动构建，而对于 master 上的 commit，是不含有 .travis.yml 文件也不需要构建的。为了防止 Travis CI 构建 master 分支，我们就必须要勾选这个选项。有些教程提到使用123branches: only: - source也可以起到只构建 source 的功能；不过在我这里这种方法行不通，最后还是使用了只构建含有 .travis,yml 文件的方法。2.3 .travis.yml 文件的基本配置本博客使用的 Hexo 框架是采用 Node.js 技术编写的，所以可以直接套用 Node.js 的 Travis CI 流程。下面是一些基本的 Node.js .travis.yml 的配置12345678910111213141516171819202122232425262728# 环境变量，注意一个 item 就会构建一次# 所以一次构建中需要多个环境变量的，也要写到一行里env: - ENV_1=xxxxxx ENV_2=yyyyyylanguage: node_js # 构建的编程语言node_js: node # Node.js 的版本，node 表示最新版# 缓存的目录# Node.js 项目一般缓存 node_modules# 用于加快构建速度cache: directories: - "node_modules"# 在 install 阶段之前执行的命令before_install:# Install 阶段，在这里是 npm installinstall: npm install# 在 script 之前执行的命令before_script:# Script 阶段，执行 hexo 相关命令script: - hexo clean - hexo g -d --config source/_data/next.yml在拥有 .travis.yml 文件后，每次 commit 之后 Travis CI 就会读取这个文件用来进行自动化构建工作3. 相关的坑当然，Travis CI 的配置不可能这么一帆风顺，还存在着非常多的坑。下面就来介绍一下我所遇到的坑，希望给大家以前车之鉴。3.1 Git Submodule 的坑如果你的 GitHub 使用了两步验证，那么你平时肯定是使用 ssh 的地址进行 git 的相关操作；但是对于 Travis CI 的虚拟机来说，它不具备你的 SSH key，当然也就不能使用 ssh 地址进行 clone 和 push。特别是对于 git submodule，由于 Travis CI 自己可以处理 https 地址的 submodule，但是如果采用 ssh 方式，它根本就无法 clone 下来。此时，我们就需要自己手动管理 git submodule，在 .travis.yml 中增加如下选项：12345git: submodules: falsebefore_install: - sed -i 's/git@github.com:/https:\/\/github.com\//' .gitmodules上面的 sed 命令就是将 ssh 地址替换成 https 地址的。不过，对于后面的部署阶段，由于要 push 到自己的仓库，所以 deploy 的地址需要修改为 https://&lt;username&gt;:&lt;ACCESS_TOKEN&gt;@github.com/&lt;username&gt;/repo.git所以，如果使用 hexo-deploy 插件的话，还需要以下的命令：12before_script: - sed i "s/git@github.com:/https:\/\/yourusername:$&#123;ACCESS_TOKEN&#125;@github.com\//" you_config_file.yml把上面的 yourusername 和 your_config_file.yml 作出相应修改即可。3.2 安装某些额外程序包如果你使用 hexo-all-minifier 来进行 HTML 的相关文件压缩，那么你就需要额外安装一个系统程序包 nasm。Travis CI 对此推出了 addons 选项来方便你配置：1234addons: apt: packages: - nasm这个问题比较难暴露，我查看了很久的 log，最后在 npm install 的 log 里面发现了某个依赖没办法安装；最后才发现是缺了一个系统的程序包。3.3 Patch 某些 Hexo 插件有时候你使用的 Hexo 插件有些问题，虽然有人提出了 PR，但是久久没有合并；在本地生成的时代，你需要自己手动 patch 这个插件，然而我们现在使用 CI，当然不可能由你进去复制粘贴。这时候，我们可以使用 curl 把 patch 文件下载下来，并覆写相关文件。通过下面的命令可以进行覆写操作：1curl &#123;raw-path-file-url&#125; &gt;| &#123;problem_file&#125;其中 &gt;| 符号可以使后面的文件清空，类似于文件操作的 w 选项。3.4 安装 Hexo Next 主题的插件Hexo Next 在 6.0 之后，把一些原本在 source/lib 中的 js 文件移到了新的 repo 中，以减少 next 本身 repo 的复杂度。但是由于 Next 把 source/lib 这个路径 ignore 了，所以我们要手动将插件 clone 到 source/lib 里面。在使用 CI 时，我们需要在 hexo g -d 之前将插件装好：12345678910before_script: ## Theme Dependencies - cd themes/next-reloaded # canvas-nest - git clone https://github.com/theme-next/theme-next-canvas-nest source/lib/canvas-nest # fancybox3 - git clone https://github.com/theme-next/theme-next-fancybox3 source/lib/fancybox # reading_progress - git clone https://github.com/theme-next/theme-next-reading-progress source/lib/reading_progress - cd ../..这里需要注意一下当前工作路径的问题，记得切换回原目录。3.5 时区问题Travis CI 好像默认使用的是美国的时区，这样就会让你的 master commit 历史变得很乱。所以，我们有必要让 Travis CI 和你的本机时区进行统一这个配置比较简单，通过设置 TZ 环境变量即可。123env: global: - TZ=Asia/Tokyo别吐槽我为什么用日本时区，玩游戏需要。这里需要多说一点的是，如果只有 env，如：123env: - ENV1=xxxx - ENV2=yyyy此时，Travis CI 就会进行 两次 构建，分别采用 ENV1 和 ENV2而对于 global 的环境变量，就会采取所有的环境变量，只构建一次。4. 总结经过一段时间的奋战，Travis CI 的集成终于做好了；虽然花费了点时间，不过在折腾的过程中还接触了一下 Travis CI 的配置流程，想必还是有些收获的；要不人们总说折腾博客比写博客有趣呢？]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Trivas CI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Solidity 基础知识和概述]]></title>
    <url>%2FSolidity%2F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%92%8C%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[Solidity 是运行于以太坊(Ethereum) 区块链上的智能合约语言，它是图灵完备的，意味着可以用它写一些任意复杂度的程序并运行于区块链中。1. 区块链基础知识区块链加密货币的技术基础，本文属于 Solidity，对此不过多介绍，可能在以后会在其他文章进行介绍。1.1 交易区块链形象的来说就是一个全球共享的交易数据库，这意味着每个人都可以访问这个数据库并发起更改，这个更改就是 交易。区块链对交易有单一性保证，也就是当你的交易正在提交到数据库的时候，其他的交易不能影响你的交易。同时，区块链对交易有完成保证，意思就是一个交易，要不就 全部完成，要不就 都不完成。不会出现一方余额变动，而另一方却不变的情况。其次，一个交易总是由发起方进行密码学方面的签名(signed)，这也就保证交易的来源方的可信赖性。只有拥有对应的密钥键值对，才能从账户中转钱。1.2 区块交易数据库都有一个需要处理的基本问题：如果两个交易都想清空一个账户的余额怎么办？这在比特币的术语中叫做 “doble-spend attack”，也就是交易之间出现了冲突。区块链对此作出的回答是， 你不需要担心这种问题。区块链会对交易的顺序作出选择，此时，这些交易会被捆绑进一个 区块 中，当两个交易出现冲突的时候，排在后面的交易就会被抛弃而不会进入区块中。这些区块在时间上呈现出一种线性的形状，因而我们将这些区块所构成的系统，也就是上面的交易数据库称为 区块链而区块链中所应用的交易选择机制，也就是交易的公证机制，我们称其为 挖矿之所以称其为挖矿，原因在于新的包含 你所承认的交易 的区块是通过一系列的计算得到的，这个新区块的生成很类似从一堆数据中把金子挖出来的过程。区块计算成功后，区块链系统会给予挖矿者奖励，在比特币系统中是赠与比特币，以太币系统则是奖励以太币。当然，一个区块也有可能会被退回(reverted)，不过是仅当这个区块位于区块链的头部的时候；当越来越多的区块被加到区块链的头部之后，你所计算出的区块被退回的可能性就会越来越低。2. 以太坊虚拟机(EVM)以太坊虚拟机(Ethereum Virtual Machine) 是以太坊合约(contract)的运行环境，也即 Solidity 的运行环境。和普通的虚拟机不同的是，EVM 不是一个沙盒系统，而是 完全独立的运行在 EVM 中的合约不能访问互联网、文件系统或者其他的进程，只能和运行于 EVM 的其他合约进行交互。EVM 中有如下概念：2.1 账户(Accounts)EVM 中有着两种账户：一种称为外来账户(External owned Accounts)，是使用公私有的键值对控制访问的，也就是真实人类控制的帐号。另一种称为合约账户(Contract Accounts)，是含有代码的合约控制的帐号，代码被存储在合约中。账户通过地址来进行标识；外部账户的地址通过其 public key 来确定；合约账户的地址是在其被创建的时候确定的，通过它的创建者(即交易的发送者)的地址和从创建者地址发送的交易数量来确定。EVM 对于这两种账户都是平等对待的，不管它存不存储着代码。每个账户都有着一个持久化的 key-value mapping(类似 HashMap)。key 和 value 分别是 256bit words 和 256bit words。这个 mapping 被称为 storage同时，每个账户都具有 以太币 的余额(balance)，可以通过发送以太币的交易来修改。两种账户的对比外部账户(External Accounts)具有以太币余额可以发送交易(可以发送或者触发合约代码)使用键值对来控制不储存有代码合约账户(Contract Accounts)具有以太币余额储存有代码其代码的执行通过交易或者其他合约发送的信息来触发当其代码执行时，可以：执行任意复杂度的操作(图灵完备)修改其自身的持久性存储(storage)调用其他合约2.2 交易(Transactions)交易是一个账户发给另一个帐号的消息，交易可以包含二进制的数据(称为它的负载)，和以太币如果目标账户具有代码，那么这个代码就会被执行，并且交易会提供其负载充当代码的输入数据。如果目标账户是 零账户(zero-account)(它的账户的地址是 0)，那么，该交易就会创建一个 新的合约。上面已经说过，合约的地址是通过发送者的地址来确定的。此时，交易的负载就会充当合约的构建参数，此时，EVM 开始执行构造函数，进行合约的构建，其结果即合约的代码，被存入合约账户中。也就是说，不需要传入合约本身的代码即可完成合约的构建2.3 汽油(Gas)汽油是以太坊用于衡量执行交易的工作量的单位。由于发起交易有可能导致合约的执行，代码执行就需要 CS 领域中的时间与空间，即需要矿工的算力来作为支撑。为了保证网络中的算力不被大规模消耗和锁死，以太坊中的每一个交易都需要消耗汽油来完成，即交易的 手续费。之所以称之为 汽油，是因为这个“手续费”是需要事先从交易发起者的账户中扣除掉，与该交易绑定，很类似一个汽车加油的过程。唯一不同的是，交易的发起者可以自定义汽油的价格也就是说，交易发起者通过事先从账户中扣除一定量的 以太，作为充入的汽油；$充入的以太费用 = 汽油量 * 自定义的汽油价格$，汽油量实际上是通过充入的以太费用倒推得到的。这也就类似于一个加油的过程。然后，矿工开始处理交易，并按照一定的规则 不断消耗汽油当计算完成时，区块被生成，并加入区块链中，矿工得到所消耗的汽油的以太费用作为交易的手续费；同时， 多余的汽油会被退还回交易发起者的账户。但是，如果汽油耗尽，交易还未处理完成的话，那么矿工就会 回退所有修改，并将该交易作为 失败的交易 加入到区块链中，同时， 收取所有的汽油费用，不退换给发起者。2.4 存储, 内存和栈2.4.1 存储(Storage)每一个帐号都会具有一个 256bit -&gt; 256 bit 的键值对，这个键值对被称作 storage在合约中进行 storage 的遍历和枚举是不可能的，而且在 storage的读写操作都是相对昂贵的。即通常用于存储一些持久化的数据，所以称作 storage事实上 storage 的读写是十分昂贵的，它需要 20000 gas 进行一次初始化，需要 5000 gas 来进行数据的修改，同时还需要 200 gas 进行一个 word 的读取。为什么需要这么贵呢？是因为存储在 storage 的数据是永久保存在区块链中的，需要真实的存储开销。2.4.2 内存(Memory)第二个存储类型是 memory，就像内存一样，memory 仅在合约运行中有效，当合约运行完成时，内存就会被清空重置。内存是线性的并被字节编码；对于读取操作来说，只能一次性读取 256bit 的数据，即一个 word;而对于写入操作来说，可以写入 8bit 或者 256bit。当你读写超过了一个 word 的时候，内存以 word(256bit) 的级别扩大；当然，随着内存的扩大，就要相应收取 gas 作为费用。需要注意的是，内存每扩大一个数量级，都是平方级别的，所以不要过多使用内存，否则会消耗很多 gas。相比 storage 来说，memory 的处理开销就便宜很多。它只需要 3 gas 来读写数据，如果内存扩大了那么就收取一些扩容费用的 gas。一般来说，内存就是通常的工作用地，基本的，不需要永久存储的东西都可以放到内存中。2.4.3 栈(Stack)EVM 不像传统的计算机是一个以寄存器为主的机器，而是以栈为主的机器，所有的计算都在一个被称作 stack 的空间中进行。这个栈具有 1024 个元素的容量，而且包含着一些 word。对于栈的访问仅限于前 16 个元素；在前 16 个元素中，你可以将任意一个复制到顶部，或者将任意一个元素和顶部的元素做交换。其他的操作则是提取顶部元素(可以不止提取一个)进行计算并将结果压入栈中。当然，你也可以将栈中的元素移到内存和存储中，不过对于比前 16 个更深一点的元素就不能访问到了，除非你将前 16 个元素移除。通常，这个栈中的元素不会使用到，就像函数栈一样由编译器或者解释器来操作。2.5 指令集EVM 的指令集比较简短，所有的指令都是对基本数据类型和 256bit 的字的操作，包含了一般的算术运算、位运算、逻辑运算和比较运算等，同时还可以进行条件跳转和非条件跳转。同时，合约还可以访问它所在区块的一些信息比如说区块的编号和区块的时间戳。2.6 信息调用(Message Calls)合约可以通过 信息调用 来调用其他的合约或者给一个非合约账户发送以太币。信息调用和交易类似，都具备一个发送者，目标者，数据负载，以太币，汽油和返回的数据。事实上，每一个交易都是由 top-level 的信息调用组成的，top-level 的信息调用可以创建其他信息调用。合约可以决定通过信息调用所传递的 gas 数量，如果一个 out-of-gas exception 发生的话，调用栈中就会压入一个 error value 来标识异常的发生。此时，只有通过该调用传送的 gas 会被消耗掉。同时，发起信息调用的合约会手动引起一个异常，以保证异常栈的呈现。上面也说过，被调用的合约会收到一个新鲜的 memory 实例，并可以访问随调用传来的数据负载；此时，系统会提供一个额外的空间用于存储这种数据负载，叫做 calldata当合约代码执行完毕后，它可以将数据返回，而返回的数据会存储在调用者的内存中。调用的深度被限制在 1024，所以对于一些比较复杂的操作，使用循环会比使用递归要好。2.7 委托调用(Delegatecall)/调用代码(Callcode)和库委托调用是一种特别的信息调用，它可以将调用者的上下文暴露给被调用者。下面举一个简单的例子：1234567891011121314151617contract D &#123; unit public n; address public sender; function delegatecallSetN(address _e, unit _n) &#123; _e.delegatecall(byte4(sha3(&quot;setN(unit256)&quot;)), _n) &#125;&#125;contract E &#123; unit public n; address public sender; funciton setN(unit _n) &#123; n = _n; sender = msg.sender; &#125;&#125;当一个合约 C 调用 D 的方法时，是 D 的 sender 被设置成了 C ，而不是 E 的方法被设置。这就是 delegatecall 和普通调用的区别，它相当于将其他合约的函数引入到了当前合约的作用域中。引入这种调用之后，我们就可以在合约中动态调用函数，这也为我们实现 Solidity 的函数库提供了途径。不过需要提醒的是，这个 delegatecall 方法是相当低级的方法， 如果不做深入开发可以不管它2.8 日志EVM 也提供从底层直至区块层级的日志功能，用这些功能来实现 事件系统但是，合约在它被创建之后就不能访问日志数据，不过日志数据可以从区块链的外部被访问。一些日志数据被存储在布隆过滤器(bloom filter)中，所以一些轻量级的客户端也可以访问部分的区块链日志。2.9 合约创建合约除了通过信息调用来创建以外，还可以通过一个特别的指令来创建。指令创建和普通的信息调用创建的区别在于，在指令创建完毕之后，创建者可以获取到新合约的地址。2.10 自毁想要去除区块链中的代码的唯一途径就是通过合约的自毁。当合约调用析构指令(selfdestruct) 时，合约账户中剩余的以太币会被发往制定的目标，然后，合约的 storage 和代码就会从区块链中删除。即使合约代码中不包含 selfdestruct 指令，它也可以通过调用 delegatecall 或者 callcode 指令来执行以太坊客户端似乎还未实现旧合约和旧代码的删除功能。存储节点可以自行选择是否删除合约。当期，外部账户是无法被删除的。]]></content>
      <categories>
        <category>Solidity</category>
      </categories>
      <tags>
        <tag>Solidity</tag>
        <tag>Ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[近月少女的礼仪 2.1 感想]]></title>
    <url>%2FTalk%2F%E8%BF%91%E6%9C%88%E5%B0%91%E5%A5%B3%E7%9A%84%E7%A4%BC%E4%BB%AA%202.1%20%E6%84%9F%E6%83%B3%2F</url>
    <content type="text"><![CDATA[最近这部 FD 发售之后就忍不住玩了一下；会结合本篇《近月少女的礼仪 2》(月に寄りそう乙女の作法２) 来谈一谈感想；内有剧透，慎点1. 介绍此次发售的 FD 主要包含两条线路：艾斯特线和春心线，不过春心线是打酱油的，就没玩。同时收录了前传《近月少女的礼仪0》，讲述大藏衣远学生时代的故事。2. 内容和感想艾斯特是本篇的女主角，在此 FD 中是着重描写的对象；在取得菲丽展最优秀奖之后，两人回老家拜访父母（这基本属于固定流程了），随后回到学院展开第二年的学习生活的事。对于本篇的评价中，多有『矛盾冲突不足』的批评；相比前作《近月少女的礼仪 1》中暗流涌动的家族纷争，《近月 2》因为主角生长在优渥的环境中，因而在设定背景中缺失了磨炼的土壤，虽有才能，但是远远不及其父母闪耀。在 FD 中此问题进一步暴露，由于取得了最优秀奖，班上的设计天才贾斯子开始认真对待设计的作业和考试，因而我们的主角小两口接连落败。于是他们终于发现（实际上在本篇结尾也有体现），自己的才能只不过是人家的一个小指头；于是一个问题就出现了， 自己无论如何努力，都比不过天才；小两口对此询问了很多的人，包括在公寓的邻居们，还直接向自己的父母求助；不过露娜的回复真的比较令人伤心：「自己从来没有在才能上碰过壁，请随便努力一下吧」说实话，玩到这里的时候我是比较揪心的，明明自己也拥有耀眼的才能，但是，却只能这样任由其被更耀眼的光芒掩盖吗？不过，幸好我们现在是主角小两口，经过和现任校长商量之后（顺便把校长洗白了），决定组成设计师组合『eS』一同向天才挑战！不过，既然组成了设计师组合，那么提交设计的时候，就必须放弃一人，另外一人要尽力对设计图做出点检和修正。于是很顺理成章的就过渡到是否要放弃自己的恋人身份，以女仆的身份来面对自己的主人兼恋人。这个选项可以说是整个近月系列中最为重要和必有的选项为什么是『必有』？因为这是个伪娘游戏啊！但是，这个选项第一次承担了 END 分支的作用，而不只是单纯的 CG 回收。如果选择了恋人，那么最后，就因为小两口要决出胜负，而双双输给天才贾斯子；不过即使输给了天才，小两口还是双双获得了二等奖，还是没有决出胜负（笑）如果选择了女仆，那么因为艾斯特的设计得到了完善，那么就能够战胜贾斯子。这里是最让我惊艳的，如果你不选择被 gang，那么就达不成完美结局。（看起来官方也很懂玩家的心嘛）也许在经过这一次的经历后，我们的才华大少爷才理解并践行了父亲一直以来对他的忠告：「能为谁派上用场是很了不起的事」原本由于露娜的原因，我第一次选的时候仍然想让他去和自己的恋人竞争；毕竟是樱小路露娜的儿子啊，怎么会输给他人，肯定是心性还不够成熟。不过玩到最后，果然我们的主角还是「朝日的女儿」啊（笑）。3. 亮点贾斯子和梅宫的百合剧《梅宫理论及其周边》（笑）才华的泳装我们的才华大小姐越来越漂亮了才华走 T 台的衣服真的好像他妈，差点认错了艾斯特的姐姐走 T 台和妹妹抢就算了，还要和妹妹抢男朋友……4. 缺憾最大的缺憾当然还是前作主要人物露娜和游星 没有登场估计官方还想再捞一笔，毕竟有很多人都期待这两个前作的最主要人物登场；毕竟父亲（朝日娘）看到自己儿子女装侍奉另一个主人，想起来就十分有趣！5. 和一代的比较当然，整体剧情的矛盾和跌宕比不上一代是公认的；不过，《近月 2》仍不失为一部十分优秀的作品，其中，我们的大少爷（小姐）的复杂性格和追求成功的方式可能更为现实，而不像露娜一样过于虚幻。虽说如此，如果要做 《近月 3》的话，剧情安排上势必要起波澜（比如说大藏前家主身亡，衣远独力难支，家族重新陷入动荡和纷争），否则 3 只能是当做炒冷饭作品而已，这样只会砸烂近月的金字招牌。]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
        <tag>Galgame</tag>
        <tag>月に寄りそう乙女の作法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再谈单例模式]]></title>
    <url>%2FDesignPattern%2F%E5%86%8D%E8%B0%88%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[之前提到枚举实现是单例的最佳实现，这毋庸置疑；不过，对比枚举和静态内部类，好像它们的区别就在于防止了反射攻击；那么，都『攻击』了，为啥偏偏没事去改你的单例呢？直接获取更有意思的信息不是更好吗？1. 『反射攻击』不是攻击这里所提到的『反射攻击』的概念，实际上并不是信息安全领域的 『攻击』 的概念；而是， 通过反射的合理利用，可以令单例失效；那么在日常开发中，最常遇到的反射攻击就是 对象的序列化。当单例需要实现序列化的时候，反序列化过程实际上就是使用 反射 来生成了新的实例。那么在序列化和反序列化的过程中，单例模式就被破坏掉了。这时，有人提出可以利用 readResolve() 方法来防止这种事情的发生；而实际上， 单纯利用 readResolve() 也并不能防止单例被破坏；《Effective Java 第二版》在 77 条提出：如果依赖 readResolve() 方法来进行实例控制，带有对象引用类型的所有实例域都必须声明为 transient 的。否则，那种破釜沉舟式的攻击者，就有可能在 readResolve() 方法运行之前，保护指向反序列化对象的引用。此时，枚举类型就派上用场了，枚举为了防止这种事情的发生，单独实现了一套序列化和反序列化的机制；大体就是利用 valueOf() 来进行反序列化，而不是使用普通的序列化机制；同时，也禁止声明 readResolve() 和 readObject() 这类方法。2. Kotlin 单例是懒加载的下面是 Kotlin 单例的反编译 Java 代码1234567891011public final class Test &#123; public static final Test INSTANCE; private Test() &#123; INSTANCE = (Test)this; &#125; static &#123; new Test(); &#125;&#125;虽然它和所谓的饿汉式 Java 单例很类似，但是在实际使用中，它是 懒加载 的。为什么呢？原因就在于 JVM 类的加载时机；JVM Specification 中在 准备阶段 中提出：explicit initializers for static fields are executed as part of initialization (§5.5), not preparation.所以，上面的 INSTANCE 的实例化，即 static 块是在类加载的 初始化阶段 进行的；而对于初始化阶段，JVM Specification 强制规定了有且仅有 5 种情况 可以触发初始化阶段；而这 5 种情况，都是你真正使用到类的实例的时候才会出现的；根据这 5 种情况，再结合 Kotlin object 的单例语法和使用，可以得出有且仅有 2 种情况会导致 object 单例提前进行初始化：反射调用类中其他的静态变量对于反射，一个很典型的应用场景就是使用 classpath scanner 进行注解扫描；不过，JB 的工程师提出，classpath scanner 并不需要反射来实现注解扫描[1]；于是我随便找了一个 classpath scanner: fast-classpath-scanner；经过使用之后，发现即使打印出了单例的信息，但是 JVM 只加载了 main 方法的类，而并没有加载单例。相关的结果在 这个 gist 中。单例的名字叫 Test，而 main() 方法类的名字叫 SingletonTest对于第二种情况，在 Kotlin 中是不存在的。为什么呢？因为对于 Kotlin object 中，声明值的方法只有 var val 和 const val 三种；对于前两种，虽然反编译出来的代码指明这样的确定义了两个静态的值；var 的情况：val 的情况：但是，当你使用的时候，却是通过 INSTANCE 来引用的。这样无论如何都会导致单例的实例化。而使用 const val 的确得到了一个 public static 的值；但是，当你使用的时候，编译器会自动替换为 字面量，不会导致单例加载；所以，综上所述，Kotlin 中 object 单例是懒加载的。1.https://discuss.kotlinlang.org/t/kotlin-singleton-implementation/2853/6?u=omysho ↩]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
      <tags>
        <tag>DesignPattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Retrofit2 + Rxjava2]]></title>
    <url>%2FAndroid%2FRetrofit%2FRetrofit2%20%2B%20Rxjava2%2F</url>
    <content type="text"><![CDATA[Retrofit 和 Rxjava 结合应该算得上是 Rxjava 在 Android 应用得最广泛的一个方面了。这里就来讲讲关于这两个库具体组合的用法。1. 添加依赖具体需要添加的依赖库有： Retrofit2、Rxjava2、RxAndroid2、Gson 、Rtrofit2 到 Rxjava2 的转换器、Retrofit2 到 Gson 的转换器123456789// Retrofitcompile 'com.squareup.retrofit2:retrofit:2.2.0'compile group: 'com.squareup.retrofit2', name: 'converter-gson', version: '2.2.0'compile group: 'com.squareup.retrofit2', name: 'adapter-rxjava2', version: '2.2.0'// Rx*compile 'io.reactivex.rxjava2:rxjava:2.1.0'compile 'io.reactivex.rxjava2:rxandroid:2.0.1'compile 'io.reactivex.rxjava2:rxkotlin:2.0.1-RC1'其中，Gson 是 JSON 解析库，也可以使用 Jackson 替代；上面的 rxkotlin 是 Rxjava 的 Kotlin 轻量支持库；如果不使用 Kotlin 可以无视。2. 构建 API使用 Retrofit 的第一步当然就是构建 API 接口；不过既然我们使用的是 Rxjava2，那么，这个 API 接口当然就稍微有点不一样：123456interface TrendingApi &#123; @GET("&#123;language&#125;") fun getTrending(@Path("language") language: String = ".", @Query("since") since: String) : Observable&lt;ResponseBody&gt;&#125;可以看到，我们 API 返回的是一个 Observable&lt;T&gt; 对象，而非通常的 Call&lt;T&gt; 对象。对于这个 Observable，假设我们的 Body 对象为 T，那么 Observable 一共有以下的几种可能情况：Observable&lt;T&gt;Observable&lt;Response&lt;T&gt;&gt;Observable&lt;Result&lt;T&gt;&gt;前两个自然不用说，第三个 Result 是 Response&lt;T&gt; 和 Throwable 的包装对象；也就是说，如果使用 Result 的话，我们可以在 onNext() 中同时处理正常情况和异常情况。所谓的异常情况指的是抛出了 Exception3. 三种 Observable 的区别那么这三种 Observable 究竟有什么区别呢？我们来看看具体 adapter-rxjava2 的源码：123456789101112Observable&lt;Response&lt;R&gt;&gt; responseObservable = isAsync ? new CallEnqueueObservable&lt;&gt;(call) : new CallExecuteObservable&lt;&gt;(call); Observable&lt;?&gt; observable; if (isResult) &#123; observable = new ResultObservable&lt;&gt;(responseObservable); &#125; else if (isBody) &#123; observable = new BodyObservable&lt;&gt;(responseObservable); &#125; else &#123; observable = responseObservable; &#125;从这段代码可以看到，默认的情况就是 Observable&lt;Response&lt;T&gt;&gt;；而这个默认的 Observable 是通过执行 CallEnqueueObservable 或者 CallExecuteObservable 得到的。然后再通过判断 Observable 的包装状态，对上面得到的 Observable&lt;Response&lt;T&gt;&gt; 进行转换。3.1 Observable&lt;T&gt;首先来看我们的 BodyObservable：123@Override protected void subscribeActual(Observer&lt;? super T&gt; observer) &#123; upstream.subscribe(new BodyObserver&lt;T&gt;(observer));&#125;可以看到，在 subscribeActual() 中，对我们传入的 observer 封装了一层外壳 BodyObserver；然后将其传入上层的 subscribe 中，以启动网络请求。这层外壳正是这个 Adapter 的关键所在，通过使用另一个对象，来处理不同的网络情况，然后再委派到我们真正传入的 observer12345678910111213141516171819202122232425262728293031323334353637383940414243444546private static class BodyObserver&lt;R&gt; implements Observer&lt;Response&lt;R&gt;&gt; &#123; private final Observer&lt;? super R&gt; observer; private boolean terminated; BodyObserver(Observer&lt;? super R&gt; observer) &#123; this.observer = observer; &#125; @Override public void onSubscribe(Disposable disposable) &#123; observer.onSubscribe(disposable); &#125; @Override public void onNext(Response&lt;R&gt; response) &#123; if (response.isSuccessful()) &#123; observer.onNext(response.body()); &#125; else &#123; terminated = true; Throwable t = new HttpException(response); try &#123; observer.onError(t); &#125; catch (Throwable inner) &#123; Exceptions.throwIfFatal(inner); RxJavaPlugins.onError(new CompositeException(t, inner)); &#125; &#125; &#125; @Override public void onComplete() &#123; if (!terminated) &#123; observer.onComplete(); &#125; &#125; @Override public void onError(Throwable throwable) &#123; if (!terminated) &#123; observer.onError(throwable); &#125; else &#123; // This should never happen! onNext handles and forwards errors automatically. Throwable broken = new AssertionError( "This should never happen! Report as a bug with the full stacktrace."); //noinspection UnnecessaryInitCause Two-arg AssertionError constructor is 1.7+ only. broken.initCause(throwable); RxJavaPlugins.onError(broken); &#125; &#125;&#125;可以看到，其实这层壳处理的并不是我们的 Body 对象，而是之前使用 Call 调用时返回的 Response 对象。我们重点来看看 onNext()：1234567891011121314@Override public void onNext(Response&lt;R&gt; response) &#123; if (response.isSuccessful()) &#123; observer.onNext(response.body()); &#125; else &#123; terminated = true; Throwable t = new HttpException(response); try &#123; observer.onError(t); &#125; catch (Throwable inner) &#123; Exceptions.throwIfFatal(inner); RxJavaPlugins.onError(new CompositeException(t, inner)); &#125; &#125;&#125;可以看到，当成功访问并响应的时候(2xx)，结果返回给了我们的 onNext() ；而当成功访问但不成功响应的时候(4xx/5xx)，返回的结果通过 HttpException 的包装，然后返回给了我们的 onError() 方法。而当这个壳子中出现 onError() 时，意味着可能出现了断网的情况，或者其他异常；此时也是通过 onError() 返回到我们的观察者中。结论：2xx 结果通过 onNext() 返回4xx/5xx 结果通过 onError() 返回断网和其他异常情况也通过 onError() 返回3.2 Observable&lt;Result&lt;T&gt;&gt;Result 是 adapter-rxjava2 新增的包装类，包装了 error 和 response ；关于它具体如何工作的，我们来看看它的源码：首先是 Result 类，下面的是 ResultObservable 使用到的静态工厂方法和 Result 的构造函数：1234567891011121314151617public static &lt;T&gt; Result&lt;T&gt; error(Throwable error) &#123; if (error == null) throw new NullPointerException("error == null"); return new Result&lt;&gt;(null, error);&#125;public static &lt;T&gt; Result&lt;T&gt; response(Response&lt;T&gt; response) &#123; if (response == null) throw new NullPointerException("response == null"); return new Result&lt;&gt;(response, null);&#125;private final Response&lt;T&gt; response;private final Throwable error;private Result(Response&lt;T&gt; response, Throwable error) &#123; this.response = response; this.error = error;&#125;可以看到，error 和 response 是不共戴天的关系，符合 Retrofit 的设计。下面我们来看看具体的 ResultObservable 的包装类：1234567891011121314151617181920212223242526272829303132333435 private static class ResultObserver&lt;R&gt; implements Observer&lt;Response&lt;R&gt;&gt; &#123; private final Observer&lt;? super Result&lt;R&gt;&gt; observer; ResultObserver(Observer&lt;? super Result&lt;R&gt;&gt; observer) &#123; this.observer = observer; &#125; @Override public void onSubscribe(Disposable disposable) &#123; observer.onSubscribe(disposable); &#125; @Override public void onNext(Response&lt;R&gt; response) &#123; observer.onNext(Result.response(response)); &#125; @Override public void onError(Throwable throwable) &#123; try &#123; observer.onNext(Result.&lt;R&gt;error(throwable)); &#125; catch (Throwable t) &#123; try &#123; observer.onError(t); &#125; catch (Throwable inner) &#123; Exceptions.throwIfFatal(inner); RxJavaPlugins.onError(new CompositeException(t, inner)); &#125; return; &#125; observer.onComplete(); &#125; @Override public void onComplete() &#123; observer.onComplete(); &#125; &#125;&#125;可以看到，这回，重点在 onError 方法；通过重载 onError 并使用 Result 的静态工厂；让我们的 observer 也能通过 onNext 获取到具体的 Throwable；也就是说，我们可以在 onNext() 处理网络错误。而当更严重的错误发生时，onError() 才会被调用结论：网络异常和正常的网络内容都通过 onNext() 进行处理。3.3 Observable&lt;Response&lt;T&gt;&gt; 的获取那么作为关键的 Observable&lt;Response&lt;T&gt;&gt; 对象是从哪里获取的呢？让我们将目光转向在开头的两个 Call 开头的 Observable；很容易知道，一个对应了 Retrofit 的 call.execute()；而另外一个对应了 call.enqueue()为了简便，我们只看 execute() 部分的源码：下面就是关键的 subscribeActual 方法：1234567891011121314151617181920212223242526272829@Override protected void subscribeActual(Observer&lt;? super Response&lt;T&gt;&gt; observer) &#123; // Since Call is a one-shot type, clone it for each new observer. Call&lt;T&gt; call = originalCall.clone(); observer.onSubscribe(new CallDisposable(call)); boolean terminated = false; try &#123; Response&lt;T&gt; response = call.execute(); if (!call.isCanceled()) &#123; observer.onNext(response); &#125; if (!call.isCanceled()) &#123; terminated = true; observer.onComplete(); &#125; &#125; catch (Throwable t) &#123; Exceptions.throwIfFatal(t); if (terminated) &#123; RxJavaPlugins.onError(t); &#125; else if (!call.isCanceled()) &#123; try &#123; observer.onError(t); &#125; catch (Throwable inner) &#123; Exceptions.throwIfFatal(inner); RxJavaPlugins.onError(new CompositeException(t, inner)); &#125; &#125; &#125;&#125;可以看到，通过调用 call.execute() 获取 Response 对象；然后将获取到的 Response 对象进行传递，就实现了一个 Observable 的功能。3.4 原理和结论通过以上的源码解读，我们得出了 adapter-rxjava2 的具体原理：首先通过 CallExecuteObservable 获取到 Observable&lt;Response&lt;T&gt;&gt; 对象；然后根据不同的 Observable 类型对这个对象进行变换，最后传出，得到了我们需要的 Observable；在调用 Observable.subscribe(observer) 时；首先是最外层的 subscribeActual() 被调用；然后被层层传递，直到 CallExecuteObservable 的 subscribeActual() 调用 call.execute()；然后将 Response 向下进行层层传递，完成了整个订阅流程。结论：只有最后 subscribe() 调用，才会触发网络请求在此之前可以先保留 Observable 对象；直到需要的时候再进行调用Observable&lt;T&gt; 的 2xx 结果在 onNext() 调用，4xx/5xx 结果在 onError() 调用Observable&lt;Result&lt;T&gt;&gt; 的 error 和 response 都在 onNext() 调用4. 创建 Retrofit 实例当我们的 API 创建好之后，我们就可以开始创建 Retrofit 实例；为了能够使用 Rxjava，必须给 Retrofit 加上 CallAdapterFactory：12345private val retrofitBuilder: Retrofit.Builder = Retrofit.Builder() .baseUrl(BASE_URL) .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .addConverterFactory(GsonConverterFactory.create(gson))这里来说一下有关 RxJava2CallAdapterFactory 的几个 create() 的区别；这个工厂一共有三个静态构造方法：create()createAsync()createScheduler(scheduler)第一个是产生一个同步的 Adapter，相当于调用 call.execute()；同时，也不对 call.execute() 的线程进行提前控制。第二个是产生一个异步的 Adapter，相当于调用 call.enqueue()；此时，Observable 的 subscribeOn() 方法失效第三个是指定一个 Scheduler，让 Adapter 产生的 Observable 一开始就 subscribeOn 到那个线程上。5. 调用网络 API终于，我们可以开始对构建起来的 API 进行调用了，调用的方法和 Rxjava 的普通使用无异；下面给出一个基本的例子：12345ApiManager.createTrendingService(TrendingApi::class) .getTrending(since) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(observer);这里，让我们的网络请求在 io() 线程上发生；然后在 Android 的主线程进行回调；需要注意的是，我们需要使用 AndroidSchedulers 来进行主线程的指定。特别需要注意的是，observeOn() 是可以多次指定的如果你需要对结果进行变换操作请务必将 observeOn() 紧挨在 subscribe() 进行设置否则就会在主线程进行请求的变换操作6. 取消请求讲了这么多都是在讲发起请求，那么该如何取消请求呢？没有了 Call 对象，我们该如何取消已经发出去的请求呢？实际上 adapter-rxjava2 已经考虑到了这一点。在 CallExecuteObservable 中，它向 observer 的 onSubscribe() 传入了一个 CallDisposable 对象；通过这个 CallDisposable，当我们取消订阅时，就会自动地将请求取消。123456789101112131415private static final class CallDisposable implements Disposable &#123; private final Call&lt;?&gt; call; CallDisposable(Call&lt;?&gt; call) &#123; this.call = call; &#125; @Override public void dispose() &#123; call.cancel(); &#125; @Override public boolean isDisposed() &#123; return call.isCanceled(); &#125; &#125;所以，只要在 onSubscribe() 中获取到 Disposable 对象；通过调用 dispose() 就能取消请求。7. 其他adapter-rxjava2 除了支持 Observable 以外，还支持了 Flowable、Single 和 Maybe 等对象；由于原理都是类似的，在这里就不详细展开了。不过，请务必注意 Flowable 和 Observable 的区别。]]></content>
      <categories>
        <category>Android</category>
        <category>Retrofit</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Rxjava2</tag>
        <tag>Retrofit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rxjava2 坑点详解]]></title>
    <url>%2FRxjava%2FRxjava2%20%E5%9D%91%E7%82%B9%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Rxjava，是一个响应式的(Reactive)，基于观察者模式的异步框架。除此之外，还有其他的 RxScala 和 RxSwift 等。说起来现在已经 2017 年了，应该没有什么 Java 工程师不知道什么是 Rxjava 了吧网上关于 Rxjava 的文章已经非常多了， 如果你没有了解过 Rxjava；那么请直接到文章最后看一些资料和教程；这里就主要来讲讲一些 Rxjava2 的坑点。1. Observable 和 FlowableRxjava2 新增了一个 Flowable，看起来 API 调用和 Observable 类似，而且官方的 README 上都是 Flowable 的示例教程；那么很自然的就会联想到 Flowable 是 Obserable 的替代用品；它们的 API 调用没有什么区别；如果你这么想那就是 大错特错！它们俩存在一个很大的区别就是关于背压问题的处理。1.1 什么是背压(backpressure)在异步任务中，经常会出现一种情况：生产者生产产品过快，而消费者消费速率不同；如果不做处理，那么接收端就会被发送端淹没，或者发送端堆积一大堆事件无法处理，最终导致内存爆炸。在计算机网络中，对于这种情况的最简单处理就是采用停等模型，直到收到接收端的回报之后，才发送下一个数据。而背压，指的就是这样一种处理策略：通过将默认的被动接受事件的模式变成 主动请求事件 ，从而避免接收端处理不及而被淹没或者 OOM 的问题。1.2 关于背压的不同处理那么两者具体的区别就是：Flowable 是有背压策略的，需要主动请求事件发送而 Observable 是没有背压策略的，事件会自动发送，多了就会 OOM1.3 具体的例子Observable：12345678910111213141516171819202122Observable.just(1, 2, 3, 4, 5) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; // Disposable 用来取消订阅 &#125; @Override public void onNext(Integer value) &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onComplete() &#123; &#125; &#125;)Observable 对应的是 Observer；这个写法是没有背压控制的，如果事件过多会 OOMFlowable：123456789101112131415161718192021222324252627Flowable.just(1, 2, 3, 4, 5).subscribe(new Subscriber&lt;Integer&gt;() &#123; Subscription sub; //当订阅后，会首先调用这个方法，其实就相当于onStart()， //传入的Subscription s参数可以用于请求数据或者取消订阅 @Override public void onSubscribe(Subscription s) &#123; Log.w("TAG","onsubscribe start"); sub=s; sub.request(1); Log.w("TAG","onsubscribe end"); &#125; @Override public void onNext(Integer o) &#123; Log.w("TAG","onNext---&gt;"+o); sub.request(1); &#125; @Override public void onError(Throwable t) &#123; t.printStackTrace(); &#125; @Override public void onComplete() &#123; Log.w("TAG","onComplete"); &#125;&#125;);Flowable 对应的是 Subscriber可以看到，在具体的回调方法中，我们需要使用 request() 来指示上游的数据传输。否则， 数据是不会自动传输的。还有一个有趣的地方在于上面代码的输出结果：12345678onsubscribe startonNext---&gt;0onNext---&gt;1onNext---&gt;2...onNext---&gt;10onCompleteonsubscribe end可以看到，onNext 在 onSubscribe 方法 并没有执行完毕 就开始调用了。具体来说，是在 request() 之后，onNext 方法就立即被执行了；不过在实践中也不一定是这样的结果所以千万要注意，在 request() 之前就要将所有的初始化工作做好。2. 线程调度能够对线程进行自由调度是 Rxjava 的一大优势；但是，由于 Rxjava 的 API 是流式调用，所以很可能会出现线程调度的坑。具体来说，Rxjava 通过 subscribeOn() 和 observeOn() 来实现对线程的调度；其中，subscribeOn() 指定的是数据的生产线程；observeOn() 指定的是数据的消费线程。但是，一个很重要的区别在于：subscribeOn() 只能指定一次如果多次指定，则以第一次为准observeOn() 可以指定多次每指定一次，其之后流式操作所在的线程就会是指定的线程举个例子：1234567891011121314Observable.just(getFilePath()) //指定在新线程中创建被观察者 .subscribeOn(Schedulers.newThread()) //将接下来执行的线程环境指定为io线程 .observeOn(Schedulers.io()) //map就处在io线程 .map(mMapOperater) //将后面执行的线程环境切换为主线程， //但是这一句依然执行在io线程 .observeOn(AndroidSchedulers.mainThread()) //指定线程无效，但这句代码本身执行在主线程 .subscribeOn(Schedulers.io()) //执行在主线程 .subscribe(mSubscriber)3. 参考资料给 Android 开发者的 RxJava 详解关于RxJava最友好的文章关于RxJava最友好的文章（进阶）关于RxJava最友好的文章——背压（Backpressure）关于 RxJava 最友好的文章—— RxJava 2.0 全新来袭]]></content>
      <categories>
        <category>Rxjava</category>
      </categories>
      <tags>
        <tag>Rxjava2</tag>
        <tag>Rxjava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin Scoping 函数]]></title>
    <url>%2FKotlin%2FKotlin%20Scoping%20%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[在 Kotlin 的 Standard.kt 中提供了一些特殊的高阶函数；它们被称作 Scoping 函数，此类函数通过使用一个函数 block，将你需要对某对象进行的一系列操作限制在 lambda 作用域内；这样，对于该对象操作的代码就不会泄露到外层作用域，使得代码更为干净整洁。例如：123DbConnection.getConnection().let &#123; connection -&gt;&#125;// connection is no longer visible here可以看到，对于 connection 的操作就仅局限于 let 的 lambda 区域，而在 lambda 区域外是不可见的；这就可以保证对 connection 的操作，不会影响到接下来的作用域。1. let1.1 定义1public inline fun &lt;T, R&gt; T.let(f: (T) -&gt; R): R = f(this)1.2 例子12val s = "hoge".let &#123; it.toUpperCase() &#125;println(s) //=&gt; HOGE从定义之中我们可以看到，let 是所有类型都具有的扩展函数；它的 lambda 的参数就是 let 的调用者。1.3 主要用途let 的主要用途在 Kotlin 的 Idioms 中有介绍；主要就是用于在对象 nullable 的时候，对对象进行操作；123data?.let &#123; ... // execute this block if not null&#125;当 data 为 null 时，let 就不执行，而直接返回 null；否则就执行 let 的 lambda。此时，它与 Java Optional 的以下三个函数的功能类似：mapflatMapifPresent可以看到，let 实际上就相当于集合中的 map，作用就是进行元素的变换功能；注意，不能在 let 中调用 it 的修改方法；否则，就会对原有对象进行改变。2. with2.1 定义1public inline fun &lt;T, R&gt; with(receiver: T, f: T.() -&gt; R): R = receiver.f()2.2 例子123456val w = Window()with(w) &#123; setWidth(100) setHeight(200) setBackground(RED)&#125;和 let 不同，with 并不是扩展函数；它的第一个参数，是任意类型的对象，如上面的 x；需要注意的是它的 lambda 部分，它的 lambda 要求接收者（调用者）必须是第一个参数的类型；也就是说，我们可以在它的 lambda 中调用第一个参数的方法；正如上面的例子，其中的几个 set 方法都隐含了调用者是 w2.3 主要用途由于指定了接收者类型，所以 with 函数主要用于对复杂对象的一系列配置操作。如上面的设置 Window 的宽度和高度，以及背景颜色等。可以看到，with 的调用 会改变传入的对象实际上，这里也可以使用 let 函数进行这种操作；不过由于 let 函数是将对象当做 参数 传入，所以如果要获得和 with 一样的效果，就必须在前面加 it：所以，let 并不适合这里所说的这个用途，利用 let 进行元素变换即可。3. run3.1 定义1public inline fun &lt;T, R&gt; T.run(f: T.() -&gt; R): R = f()3.2 例子12val s = "hoge".run &#123; toUpperCase() &#125;println(s) //=&gt; HOGE可以看到，run 实际上就是 let 和 with 的结合；可以让 with 不需要指定 receiver 参数就进行对象内部属性的配置；同时，run 也是一个扩展函数，可以通过任何的类进行调用。3.3 主要用途作为 let 和 with 的合体方法，那么最主要的用途当然还是进行某个对象的配置。需要注意的是，run 也会对对象进行改变。4. apply4.1 定义1public inline fun &lt;T&gt; T.apply(f: T.() -&gt; Unit): T &#123; f(); return this &#125;4.2 例子12val s = "hoge".apply &#123; toUpperCase() &#125;println(s) //=&gt; hoge相比之前的结果，返回的依旧是小写字符；这是由于 apply 返回的是 apply 的调用者的缘故。4.3 主要用途由于 apply 的返回类型为调用者自身，所以可以利用 apply 实现一个 流式 API 调用。实际上就是 with 最后返回 this 的简略版本。5. also这是 Kotlin 1.1 新增的 scoping 函数5.1 定义1public inline fun &lt;T&gt; T.also(block: (T) -&gt; Unit): T &#123; block(this); return this &#125;5.2 使用例子12val s = "hoge".also &#123; it.toUpperCase() &#125;println(s) //=&gt; hoge可以看到，其作用和 apply 一样；但是和 apply 的区别在于，also 的函数参数并非指定接收者；而是将调用者 T 当做其参数传入 lambda；类似于 let 的 apply 版本。5.3 主要用途那么这样做有什么好处呢？首先，由于 没有指定接收者，所以 lambda 内外的 this 的含义没有改变：12345678910111213141516// applyを使用val button = Button(this).apply &#123; text = "Click me" setOnClickListener &#123; startActivity(Intent(this@MainActivity, NextActivity::class.java)) // 単なる「this」ではNG ^ &#125;&#125;// alsoを使用val button = Button(this).also &#123; button -&gt; button.text = "Click me" button.setOnClickListener &#123; startActivity(Intent(this, NextActivity::class.java)) &#125;&#125;其次，可以通过赋予 lambda 参数名字，例如上面的 button ，增强可读性。5.4 和 let 的区别also 和 let 都是通过将调用者作为 lambda 的参数传入函数的形式进行调用；其区别就在于 also 最终返回值为其自身的调用者，即 this；而 let 的最终返回值由它的 lambda 的最后一个表达式的返回值决定。类似于 apply 和 with 的区别；同理，也可以利用 let 来实现上面的 also 实现的功能：1234567val button = Button(this).let &#123; button -&gt; button.text = "Click me" button.setOnClickListener &#123; startActivity(Intent(this, NextActivity::class.java)) &#125; button // letの場合はこれが必要になる&#125;6. 总结let 用于进行元素变换操作，类似于 mapwith 用于对复杂对象的配置，需要提供具体的对象run 是 with 的 let 版本，配置对象属性，不需要提供具体对象apply 是 with 的流式 API 版本also 是 let 的 apply 版本，用于对象配置，同时保留流式 API 和 当前 this 的含义7. 参考资料Kotlin スコープ関数 用途まとめExploring the Kotlin standard library]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scala for-comprehension]]></title>
    <url>%2FScala%2FScala%20for-comprehension%2F</url>
    <content type="text"><![CDATA[Scala 作为函数式语言，提供了很多用于高阶函数来解决一类范式问题；但是，使用过多的高阶函数就会让代码的可读性变差；所以，对此 Scala 提供了一种类 Python 的简便的语法糖，用来解决代码的可读性问题。1. 问题背景在这里举一个 Effective Scala 中的例子：比如说，我要列出所有不同字母组成的 pair，那么该怎么办呢？如果用 Java 的话，就会有两层 for，那么在 Scala 下，我们就应该用到 flatMap：1234567val chars = 'a' to 'z'chars flatMap &#123; a =&gt; chars flatMap &#123; b =&gt; Vector("%c%c".format(a, b)) &#125;&#125; filter &#123; s =&gt; s.head != s.last &#125;这里用到了两个 flatMap，为什么？首先，如果都使用 map，那么内部的 map 将元素转变为了 Vector；而 char 作为 Range，会默认选择 Vector 作为 map 的选项；此时， a 转换成的东西就变成了 Vector[Vector[String]]；而 chars 又会默认生成一层 Vector；所以，最后生成的东西就会有三层 Vector，即 Vector[Vector[Vector(String)]]；所以，我们需要两次 flatten 进行展平，才能最终得到 Vector(String)；这也是为什么需要两次 flatMap 的原因。可以看到，如果采用 flatMap，那么操作就会变得十分难以理解。2. for-comprehension对此，Scala 提供了一种简便的，用于生成 Seq 的 for 表达式；通常称为 for-comprehension，也称为 Sequence Comprehension，或者 for expression。它的语法结构如下：1for (s) yield e其中，s 被称作 enumerators，e 则是遍历生成的元素；表达式对于 s 有以下几点要求：s 是 generator 和 filter 组成的，以分号间隔的语句序列。genrator 的形式为： p &lt;- c。其中 p 是一个模式(pattern)，c 则是一个集合filter 的形式为 if condition，其中 condition 是个布尔表达式允许多个 generator，但是在下面的 generator 必须比在上面的要变化的快。换成指令性语言的话，就是在下面的 generator 必须在更内部的 for 循环中。经过执行之后，这个表达式会返回一个由 e 组成的集合；具体返回的集合类型，例如 List 和 Vector，则由 s 来决定；如果类型不能满足，则会向类型结构的上一层回溯，直到找到一个最接近的满足要求的类型为止。同时，for-comprehension 可以使用花括号代替圆括号，此时，就不需要用分号来分隔语句了。3. 使用 for-comprehension 解决问题那么，对于上面的问题，我们试着使用 for-comprehension 来解决：1234567val chars = 'a' to 'z'for &#123; a &lt;- chars b &lt;- chars if (a != b)&#125; yield "%c%c".format(a, b)可以看到，使用 for-comprehension 来解决，写出来的代码会比 flatMap 简单得多。4. 关于返回类型对于上面的表达式，它的返回类型是什么呢？实际上，是一个 Vector。为什么是一个 Vector ？这是因为，chars 实际上是一个 Range 对象；而对于 Range 对象，它不能拥有一堆 String；此时，Scala 编译器会在类型结构中向上寻找最近的满足条件的类型；此时，寻找到的是 IndexedSeq，而这个类型的默认 Seq 实现就是 Vector]]></content>
      <categories>
        <category>Scala</category>
      </categories>
      <tags>
        <tag>Scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scala List 高阶函数]]></title>
    <url>%2FScala%2FScala%20List%20%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[高阶函数是函数式编程的一个很大的特性；同时，其中集合类的高阶函数在日常的开发和使用中，占了一个很重要的位置；但是，这些函数有可能会在刚接触的时候搞不懂它们的具体作用；那么今天就以 List 来说一说常用的高阶函数具体的作用。1. 子集操作在一个集合中选取一些特定的元素作为子集；我们在指令性语言中，通常选用 for 语句来实现这个需求；而在函数式语言中，我们有对应的高阶函数来解决这个问题。1.1 filter(p: (T) =&gt; Boolean)顾名思义， 过滤器，用来 选取符合条件的元素， 并将其作为返回值；这里的 符合条件 指的是 使得函数 p 的返回值为 true 的元素。例如：123val list = List(1, 2, 3, 4)list.filter((x) =&gt; x &gt; 2) // List(3, 4)1.2 filterNot(p: (T) =&gt; Boolean)同理，这个函数是上面的反面，也就是用来 过滤掉 符合条件的元素；返回的是， 不包含符合元素的子集；例如：123val list = List(1,2,2,3)list.filterNot((x) =&gt; x == 2) // List(1, 3)1.3 partition(p: (T) =&gt; Boolean)这个函数是上面两个函数的集合体，返回的是一个 Turple，包含的元素为：1(list.filter, list.filterNot)例如：1234val list = List(1, 2, 3, 4, 5, 6, 7)// Returns: (List(1, 2, 3), List(4, 5, 6, 7))list.partition((x) =&gt; x &lt; 4)1.4 takeWhile(p: (T) =&gt; Boolean)这个函数会一直选取元素， 直到 p 的返回值为 false，然后将元素作为新的集合返回。可以看到，这个函数返回的就是 符合条件的集合前缀例如：1234val list = List(1, 1, 1, 1, 2, 1)// 注意最后一个 1 并没有拿走list.takeWhile((x) =&gt; x == 1) // List(1, 1, 1, 1)1.5 dropWhile(p: (T) =&gt; Boolean)和上面的方法相反，这个方法会一直 丢弃 元素，直到 p 的返回值为 false；那么可以看到，这个函数返回的就是 不符合条件的集合后缀；123val list = List(1, 3, 6, 9, 4, 2, 1)list.dropWhile((x) x != 4) // List(4, 2, 1)1.6 span(p: (T) =&gt; Boolean)这个函数是上两个函数的结合，它返回的是如下的一个 Turple：1(list.takeWhile, list.dropWhile)1.7 partition、span 和它们的基本方法的区别既然 partition 和 span 都可以用基本的 filter、filterNot 和 takeWhile、dropWhile 来解决，那为什么还要专门实现一次这两个方法呢？其实，span 和 partition 只需要扫描一次集合；但是如果使用 filter、filterNot 和 takeWhile、dropWhile 来实现的话，就需要扫描两次集合了。所以，如果同时需要两者的数据的话，那么使用 span 和 partition 显然是更经济的。1.8 withFilterScala 除了 filter 之外，还提供了一个 withFilter 函数；那么，这两者有什么区别呢？根据文档：Note: the difference between c filter p and c withFilter p is that the former creates a new collection, whereas the latter only restricts the domain of subsequent map, flatMap, foreach, and withFilter operations.也就是说，filter 会返回一个 新的 List；但是 withFilter 不会返回新的 List；它只会提供一个过滤器的作用，让符合条件的元素通过，以方便接下来的 map 等其他高阶函数的使用；而就效率而言，withFilter 比 filter 要快。如果你需要返回一个新的集合，就使用 filter；如果你只是需要一个元素过滤器，而接下来，还需要进行其他操作，那么就使用 withFilter2. 元素检查有时候，我们会希望检查集合内部的元素状态；比如说， 是否所有的元素都满足某个特定条件；或者， 是否有元素满足特定条件。在 Scala 中，我们有高阶函数来进行这个操作。2.1 forAll(p: (T) =&gt; Boolean): Boolean顾名思义，检查 是否所有的元素都满足特定条件例如：123val list = List(1, 2, 3, 4)list.forAll(c =&gt; c &gt; 0) // true2.2 exists(p: (T) =&gt; Boolean): Boolean同理，检查 是否存在满足条件的元素例如：123val list = List(1, 2, 3, 4)list.exists(c =&gt; c &lt; 0) // false3. 变换3.1 map(f: (T) =&gt; U)map 函数，可以说是这里面用的最多的高阶函数了；map 函数的真正作用，实际上是一种变换功能，而且不仅可以变换成和现元素类型相同的类型，也可以变换成不同的类型；也就是说，可以通过 map 函数，将一种元素的集合，变成另一种元素的集合。例子：12345// 将所有元素都乘以 2val list = List(1, 2, 3, 4)list.map((x) =&gt; x * 2) // List(2, 4, 6, 8)12345// 将 Int 变成 Stringval list = List(1, 2, 3, 4)list.map((x) =&gt; x.toString()) // List("1", "2", "3", "4")3.2 flatten这个函数可以将嵌套的 List 展平，就像它的名字一样。例如：123val listOfLists = List(List(1, 2), List(3, 4))listOfLists.flatten = List(1, 2, 3, 4, 5, 6)3.3 flatMap它是 map 和 flatten 的集合体，相当于先进行 map 然后 flatten。例子：123val listOfLists = List(List(1, 2), List(3, 4))listOfLists.flatMap((x) =&gt; x.map(_ * 2)) // List(2, 4, 6, 8)也就是说，flatMap 先将元素 map 成 嵌套的 List；随后，再调用 flatten，将嵌套的 List 展平flatMap 的作用过于强大，使用时需要小心谨慎在 Twitter 的 Effective Scala 中，推荐使用 for-comprehention 来代替 flatMap 的使用3.4 zip[T](xs: List[U]): List[(T, U)]压缩，它的左右两个操作数分别是 两个 List；然后返回一个分别包含两个 List 元素的二元组的 List。例如：12345val list1 = List(1, 2, 3, 4)val list2 = List("a", "b", "c", "d")// List((1, "a"), (2, "b"), (3, "c"), (4, "d"))list1 zip list23.5 unzip有压缩就有解压；这个函数的作用就是将上面压缩后的结果解压出来；具体来说就是接受一个二元组的 List， 返回一个 List 的二元组。例如：12345val list1 = List(1, 2, 3, 4)val list2 = List("a", "b", "c", "d")// (List(1, 2, 3, 4), List("a", "b", "c", "d"))(list1 zip list2) unzip3.6 collect根据文档，collect 接受一个 PartialFunction，然后对集合中的每个元素都 apply 这个函数，返回一个新的集合。听起来，这个方法和 map 很像，不过其区别就是在于 collect 接受的是一个 PartialFnction ；这具体是什么意思呢？我们来举个例子：12345678910val convertFn: PartialFunction[Any, Int] = &#123; case i: Int =&gt; i; case s: String =&gt; s.toInt; case Some(s: String) =&gt; s.toInt&#125;List(0, 1, "2", "3", Some(4), Some("5")). collect(convertFn)// List[Int] = List(0, 1, 2, 3, 5)注意到， collect 的 lambda 中，并没有对所有的 case 都进行处理；上面的 List 除了含有 String 、 Int 和 Some[String] 之外，还含有 Some[Int]；这就是所谓的 PartialFunction ，它并没有对所有的情形都进行处理，也没有提供一个默认的选项。如果上面的 collect 替换为 map，则第四个 Some(4) 就会导致 MatchError；而 collect 则避开了这个错误。理论上，collect 进行了 map 和 filter 的两重功能。虽然，collect 不会造成 MatchError；但是 collect 不是使用 try...catch 实现的。collect 是通过检查函数中提供的 case 检查；如果 case 不匹配，则跳过该元素，不调用函数；如果 case 中存在 ???，那么同样也会抛出异常：123456789101112List(1, "").collect( &#123; case i: Int =&gt; i; case _ =&gt; ??? &#125;)scala.NotImplementedError: an implementation is missing at scala.Predef$.$qmark$qmark$qmark(Predef.scala:225) at $anonfun$1.applyOrElse(&lt;console&gt;:8) at scala.collection.immutable.List.collect(List.scala:303) ... 33 elided3.7 collectFirst这是 collect 的简化版本；它只会将函数应用在 第一个满足 其 case 的元素中，并返回一个包含该元素的 Option 对象。如果不存在这样的函数，那么就返回 None3.8 groupBy[A](f: (A) =&gt; K): Map[K, Seq[A]]groupBy 通过函数 f，将 List 分成不同的部分；每一个部分由一个键值 K 来进行映射，最终返回结果为一个 Map 对象。例子：1234567val fruit = List("apple", "peer", "orange", "pineapple")fruit groupBy (_.head)//&gt; Map(p -&gt; List("peer", "pineapple"),// a -&gt; List("apple"),// o -&gt; List("orange"))4. 规约在一个集合中，我们通常还会进行规约操作；例如求一个 1 到 100 的和；那么，此时，我们就是将一个 1 到 100 的集合规约到一个 Int，它是这个集合所有元素的和。下面介绍的就是一系列规约函数。4.1 reduceLeft(op: (B, T) =&gt; B)顾名思义，从左到右进行规约操作；该函数会从左到右地使用操作符 op 将元素连接起来。注意 op 是个二元操作，它接受两个参数，返回一个值。那么产生的结果就是一个 左斜的树：需要注意的是，reduceLeft 不仅能返回和原有元素相同类型的值，也能返回不同类型的值；基于这样的树结构，那么对 op 的类型就有了要求；可以看到，在上面，下方的 op 的返回值是作为上方 op 的左节点；也就是说，reduceLeft 要求， op 的左边参数的类型，必须和其返回值的类型相同。4.2 foldLeft(z: B)(op: (B, T) =&gt; B)foldLeft 则是对 reduceLeft 的进一步泛化；reduceLeft 是不允许在 空列表 中执行的；对此，foldLeft 提供了一个 初始值 z；如果列表为空，那么就返回 z；它生成的树如下：这里比较有意思的就是 foldLeft 实际上是一个 柯里化函数；可以先提供初始值，然后在 op 操作确定之后，再进行规约运算。4.3 reduceRight(op: (T, B) =&gt; B)我们既然能从左边规约，当然也可以从右边规约；reduceRight 的作用就是， 从右到左 执行规约操作；那么，它所生成的树就是 右斜的：同理，reduceRight 要求，它的右操作数的类型必须和它的返回值类型相同。4.4 foldRight(z: B)(op: (T, B) =&gt; B)同样的，我们也具有一个 foldRight 函数，在集合为空时，返回初始值 z；它生成的树如下：4.5 left 和 right 的区别那么 left 和 right 有什么区别呢？实际上，高阶函数的作用范围都是 整个列表；所以，对于满足 交换律 和 结合律 的运算，从左边执行和从右边执行的结果是 一样的，例如 加法操作；但是，对于不满足交换律和结合律的运算，例如 减法操作；那么这两个函数的执行结果就不一样。4.6 其他规约函数Scala 还提供了一些其他的针对数字类型的规约函数；例如：sum， product，max 和 min；不过，sum 和 product 只能用于数字类型，否则会报错。5. 其他高阶函数Scala 集合中还拥有其他的高阶函数，诸如：count、find、sortWith 等；这些函数的作用比较明显，可以从它的命名中推测出其作用，在这里就不多做解释了。]]></content>
      <categories>
        <category>Scala</category>
      </categories>
      <tags>
        <tag>Scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ofo 使用体验]]></title>
    <url>%2FTalk%2Fofo%20%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[最近因为和舍友出去看电影，终于第一次体验了一下著名的小黄车 ofo；ofo 的确是很方便，同时也解决了所谓「最后一公里」的这个需求痛点；但是，我不得不说，ofo 的运营团队还很年轻，一些很基本的流程问题都没搞清楚就胡乱上线功能。1. 校园认证就比如说 ofo 的校园认证，的确对我等大学生有很大的优惠；但是，当你校园认证不通过，而你急着用车，去进行了普通认证，那么：你就再也不能进行校园认证了!明明就是一个很容易考虑到的 Corner Case，可是 ofo 却没有处理好；看来 ofo 还需要多招几个测试大牛。2. 客服电话APP 上解决不了的问题，一般的用户就会想着去联系客服解决；在这里我不得不说一声 MMP，ofo 的客服电话三天两头打不通；在半个小时之内，我连续向其拨打了 12 通电话；但是，只有 3 通是能接通的。第一通电话接通之后，首先是让我退押金，然后再打电话；这也无可厚非，毕竟银行信用卡激活就是这么要求的第二通电话，就有点莫名其妙了，首先接话员连普通话也说不标准；然后说没有权限恢复我的认证状态，在经过多次撕逼之后，让我去找一个微信号去解决；结果这个微信号居然是个 异常号！第三通电话之后，告诉我，你还有余额没有退，所以不能给你恢复认证状态。结果呢？帮我申请了余额退款，说要到账之后才能进行下一步的操作。所以就导致我现在，没有押金，余额还在银行流转，所以小黄车就不关我什么事了。3. 总结可以看出，就是因为一个没有考虑到的 Corner Case ，现在我只能去骑 mobike;想到当年即使是写小学期项目，也要跟队员讨论个大半天的 Corner Case 才开始着手编码；可能这就是互联网 APP 泡沫生态的现状吧：大家都去抢功能，让功能尽早上线，剩下的维护啊支持啊，都可以往后边放一放。]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>ofo</tag>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Coursera 作业之函数集合]]></title>
    <url>%2FCoursera%2FScala%2FCoursera%20%E4%BD%9C%E4%B8%9A%E4%B9%8B%E5%87%BD%E6%95%B0%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[本文源码：https://github.com/wafer-li/scala-coursera/tree/master/funsets1. 背景知识该作业是实现一个函数集合的相关内容。何为函数集合？一般来说，编程语言中的集合(Collection)都是有限集合；但是，在数学上，还有很多的集合是无限集合，比如说 负数集；我们有没有一种办法去表示这个集合呢？当然有的，对于上面的负数集来说，我们如何知道一个数字是不是负数集中的元素呢？将它与 0 进行比较，如果 x &lt; 0，那么它就是负数集的元素。此时，(x) =&gt; x == 0 就成为了负数集的判断标准，我们将其作为负数集的 特征函数，通过特征函数来指代特定的集合。于是，我们得到了函数集合的定义：type Set = (Int) =&gt; Boolean和它的一个基本方法 contains()：1def contains(set: Set, x : Int) = set(x)2. 基本方法接下来，题目要求我们实现一些集合的基本方法。2.1 singletonSet()如何返回一个只有一个元素的函数集合呢？对于我们的特征函数来说，也就是只有给定的元素才能满足这个特征函数，这样的集合就是只存在给定元素的集合。所以，定义如下：1def singletonSet(elem: Int): Set = (x) =&gt; x == elem2.2 交、并、补这几个基本的数学集合操作并不难，只需要抓住我们特征函数就是 contains() 这一点就行了。2.3 filter()这个方法算是在 JVM 函数式语言中经常出现的集合方法；作用就是返回满足条件的集合内的元素；其中，一个很有趣的地方在于，filter(s, p) 的两个参数，虽然其表面上的类型不一样；但是实际上他们的类型是一样的，也就是说，s 和 p 都是集合！所以，我们只需要返回 s 和 p 的交集就行了1def filter(s: Set, p: Int =&gt; Boolean) = intersect(s, p)3. forAll()然后，有趣的地方来了，题目要求我们实现一个 forAll() 方法，用来检测是否 所有的 元素都满足给定的条件。当然，我们不能遍历全部的无限集元素；所以，我们就采取一个区间的办法，如果在这个区间内的所有的元素都满足条件，那么我们有信心认为所有的元素都满足了条件。在这里，同样要注意， s 和 p 的类型实际上是一样的！123456789def forall(s: Set, p: Int =&gt; Boolean): Boolean = &#123; def iter(a: Int): Boolean = &#123; if (a &gt; bound) true else if (diff(s, p)(a)) false else iter(a + 1) &#125; iter(-bound)&#125;4. exists()本题第二难的地方来了，题目要求实现一个 exists() 函数，用于检测 是否存在 一个元素满足给定的条件。按说这个还不是很难，但是，题目要求使用 forAll() 进行实现。按照我的早就丢给高中老师的逻辑关系知识，『所有』和 『存在』好像并无什么联系。不过，在论坛上有人提醒了我，可以使用 间接法；也就是说，我们可以考虑一下 不存在 的情况；也就是说，对于 所有的 元素，都 不满足 给定的条件；到此，我们就可以利用上之前实现的 forAll() 了。12def exists(s: Set, p: Int =&gt; Boolean) = !forAll(s, (elem) =&gt; !p(elem))但是，这显得太长了，能不能缩短到只有一行代码呢？之前提到，s 和 p 的类型实际上是一样的，也就是说，我们可以重用上面的方法来对 s 和 p 进行处理。那么，s 和 p 在不存在的情况下，是什么样的关系呢？我们可以从上面的结论出发继续思考：对于所有的元素，都不满足给定条件 $\Rightarrow$ 对于 s 的所有元素，都位于「在 s 且不在 p 中」这个集合内所以，我们得到了一个简便的写法：1def exists(s: Set, p: Int =&gt; Boolean) = !forAll(s, diff(s, p))5. map()本题最难的部分来了，map() 函数，用于对集合中的元素进行变换操作，返回一个变换过后的新集合。鉴于我们的集合是一个 函数，那么 map() 方法也就是返回一个 新函数，用来检测参数是否满足新变换过后的条件。因为 map() 函数是针对原有集合进行变换，所以，我们应该基于原有集合生成上面的新函数。也就是说，对于原有集合来说，是否存在一个元素，它变换过后的数值和传入的参数相等：12def map(s: Set, f: Int =&gt; Int) = x =&gt; exists(s, elem =&gt; x==f(elem))]]></content>
      <categories>
        <category>Coursera</category>
        <category>Scala</category>
      </categories>
      <tags>
        <tag>Scala</tag>
        <tag>Coursera</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scala 模式匹配]]></title>
    <url>%2FScala%2FScala%20%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[模式匹配，是 Scala 相比 Java 在类型上的一个很好地改进；通过引入模式匹配，消除了 Java 中常见的类型检测和强制转换(cast)；拥有更高的安全性1. 问题背景模式匹配主要解决的问题就是一个树状的类型依赖图；比如算数表达式，由文法可知，它是具有树状依赖关系的：\begin{aligned} E & \rightarrow \\ & E+E \ | \\ & E-E \ | \\ & E*E \ | \\ & E/E \ | \\ & (E) \ | \\ & i \end{aligned}所以，我们可以使用如下的类来表示一个算术表达式：123trait Exprclass Number(n: Int) extends Exprclass Sum(leftOp: Expr, rightOp: Expr) extends Expr那么当我们需要使用类似 eval() 的方法时，该如何实现这个方法呢？2. 各有缺陷的解法2.1 使用类型说明一个暴力解决的思路就是为 Expr 添加上一个类型的说明，即：1234trait Expr &#123; def isNumber: Boolean def isSum: Boolean&#125;不过，随着以后算术表达式的种类越来越多，比如加入了乘法和除法；那么，这个实现会导致方法数的平方级别爆炸。每增加一个种类，都需要对现有的所有类进行方法的增加显然，使用类型说明(classification) 是不行的。2.2 类型检测和造型Java 这门面向对象语言对此则有比较好的解法：通过对对象进行类型检测和强制转换(cast)；由于强制转换后类型得到限定，所以就可以分别进行检测工作：12345678public int eval(Expr e) &#123; if (e instanceof Number) &#123; ... &#125; else if (e instanceof Sum) &#123; ... &#125;&#125;相对的，Scala 也具有这种语法特性：123456789def eval(e: Expr): Int = &#123; if (e.isInstanceOf[Number]) &#123; e.asInstanceOf[Number].numberValue &#125; else if (e.isInstanceOf[Sum]) &#123; val sum = e.asInstanceOf[Sum] eval(sum.leftOp) + eval(sum.rightOp) &#125;&#125;不过，这种方法由于是比较低层级的，具有指令性特征；同时，过多的类型检测和强制转换也造成了诸多不安全因素：如果运行时类型改变了，那么很可能会出现异常。2.3 面向对象的解法现在我们来选择一个更高级的解决办法，通过利用多态特性，来解决此类问题。相比将 eval() 作为一个外部的函数，不如将其作为类的一个内部方法：1234567891011trait Expr &#123; def eval: Int&#125;class Number(n: Int) extends Expr &#123; override def eval: Int = n&#125;class Sum(leftOp: Expr, rightOp: Expr) extends Expr &#123; override def eval: Int = leftOp.eval + rightOp.eval&#125;通过语言自带的多态特性，我们可以使用到具体的 eval()；这样就能很优雅的解决上面的问题；不过，这种写法有个缺陷；如果我们需要添加一个新的方法，例如 show()，则需要更改所有的现存类；而且，如果我们需要一个化简操作，它不能仅仅只考虑一个节点，而需要多个节点综合考虑；这样，我们可以发现，即使使用多态，也没能解决我们所有的问题3. 模式匹配在 Scala 中，具有一个很常用的语法用于解决这类问题，即 模式匹配；模式匹配使用 match 定义：123456e match &#123; case Number(n) =&gt; n case Sum(left, right) =&gt; left.eval + right.eval case anotherE =&gt; anotherE.eval case _ =&gt; //Ignore&#125;match 语句块中，包含多个 case 语句；每个 case 语句包括：case 关键字，模式和表达式，模式和表达式使用 =&gt; 分隔。乍一看，这个语法和 C++/Java 中的 switch 很像；不过，它进行了大幅度的强化，主要就是放宽了对选择器的限制：现在 case 语句可以是：构造器变量常量通配符 _其中：构造器必须是 case class变量必须以小写字母开头常量必须以大写字母开头4. 匹配处理首先，如果没有 case 能够匹配选择器，则会抛出异常。然后，如果匹配成功，会将 整个 match 语句 替换为 case 的 right-hand side。对于不同的情况，则是：构造器，将参数绑定 case 中的形参变量，对变量进行赋值常量，检测和常量的相等性5. Case ClassCase Class 是一种特殊的类，通常用于进行模式匹配；但是，它还具有一些其他的有用特性：它不需要 new 关键字进行构建：123case Person(name: String, age: Int)val person = Person("hehe", 18)它的主要构造器参数直接可以作为类的字段：1val name = person.name它的相等性判断是结构化的，当它所有的成员都相等时，它就相等，和引用无关；同时还提供了 toString() 方法：12345678val firstSms = SMS("12345", "Hello!")val secondSms = SMS("12345", "Hello!")if (firstSms == secondSms) &#123; println("They are equal!")&#125;println("SMS is: " + firstSms)输出：12They are equal!SMS is: SMS(12345, Hello!)6. 模式匹配的解决办法使用模式匹配，我们不仅可以对单个节点进行解析工作；同时，我们还可以查看节点之间的关系：12345678910111213141516171819202122232425262728trait Expr &#123; def eval: Int = this match &#123; case Number(n) =&gt; n case Sum(left, right) =&gt; left.eval + right.eval &#125; def show: String = this match &#123; case Number(n) =&gt; n.toString case Sum(left, right) =&gt; left.show + "+" + right.show case Prod(left, right) =&gt; def f(e: Expr): String = e match &#123; case Sum(l, r) =&gt; "(" + l.show + "+" + r.show + ")" case _ =&gt; e.show &#125; f(left) + "*" + f(right) case Var(x) =&gt; x &#125;&#125;case class Number(n: Int) extends Exprcase class Sum(left: Expr, right: Expr) extends Exprcase class Var(x: String) extends Exprcase class Prod(left: Expr, right: Expr) extends Expr上面的 show 方法通过查看子节点情况，实现了优先级区分:7. 和多态方法的区别那么模式匹配相比面向对象方法有什么优势呢？如果你倾向于在现有的类架构上添加 通用的方法，那么采用模式匹配会更好；因为模式匹配只需要修改匹配代码，而不需要在各个子类重新实现方法。但是，如果你倾向于增加子类，而不是增加通用的处理方法，那么采用多态方法会更好；原因是采用多态架构只需要建立一个子类，而重载方法这些繁琐工作 IDE 会帮你做好；而模式匹配还需要在顶层代码中进行修改]]></content>
      <categories>
        <category>Scala</category>
      </categories>
      <tags>
        <tag>Scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[打字训练网站]]></title>
    <url>%2FTalk%2F%E6%89%93%E5%AD%97%E8%AE%AD%E7%BB%83%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[买了新键盘之后就想试一试它的威力，所以就找了一个打字训练网站来打字；在知乎上找了一圈，结果就找到了 这个；练了一圈的感受就是： 左手好累啊！！！基本上单词表里面最长的 S 和 T 都在左手了，而我又习惯使用左手来按空格键；结果就是我的左手现在累得不成样子了；不过最后成绩也不怎么样，大概也就 50 多 wpm 吧，相信大家一定会比我打字快的。]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
        <tag>打字</tag>
        <tag>Typing training</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Realforce 87u]]></title>
    <url>%2FBuying%2FRealforce%2087u%2F</url>
    <content type="text"><![CDATA[最近终于下定决心来买这个键盘了。主要说说使用感受吧2018/1/8 更新部分内容1. 手感我买的这个是静音版，手感介于红轴和茶轴之间，就是稍微软一点的茶轴，按起来有种噗噗的感觉；显然，打击感是一点也没有了，不过真的有种揉胸的感觉。不过这个键盘的优点在于：由于是分区压力，所以能极大地缓解小拇指的压力；之前我用的 filco 青轴，最后有 40% 的概率用小拇指打不出 shift 按键；这也是为什么我要买一个新键盘的原因。2. 特色功能Realforce 87u 有个特色功能，就是把没有什么卵用的 Scroll Lock 变成了 NumLock；也就是说，这个键盘有 小键盘 的功能！这是我在 87 键盘上从来没有见到过的。不过在 Mac 上，这个 NumLock 就失效了；2018/1/8 补充：可惜的是，自从升级到 High Sierra 之后下面的方法就不管用了不过吧，反正我也不怎么用这个小键盘，先就这样吧。需要使用 Karabiner 进行键位修改。首先下载 Karabiner，这里有个小问题就是 brew cask 会报 Operation not permitted 的错误；所以最好还是自己下载镜像安装为好。随后点击 Open private.xml：然后加上一条自定义配置[1]：12345&lt;item&gt; &lt;name&gt;Map Realforce Numlock to OSX Numlock function&lt;/name&gt; &lt;identifier&gt;private.pc_numlock_to_mac_numlock&lt;/identifier&gt; &lt;autogen&gt;__KeyToKey__ KeyCode::KEYPAD_CLEAR, KeyCode::VK_IOHIKEYBOARD_TOGGLE_NUMLOCK&lt;/autogen&gt;&lt;/item&gt;最后再到 Change Key 启用就可以了。3. 缺点目前遇到的缺点只有一个：就是它的导线槽太紧了，几乎是死死卡住键盘的线缆；结果我摆弄的时候需要用很大的力气才能把线弄出来，希望以后不要弄烂为好；小贴士：弄的时候长痛不如短痛，直接一个猛劲可以更快的减轻线缆的损伤其次就是居然不配理线用的尼龙扎带，差评！4. 为什么不买 HHKB不喜欢 HHKB 的配列。我就爱用 Caps Lock 🙃5. 总结如果你很喜欢用青轴，很享受用青轴的打击感，请直接买青轴，静电容不适合你；如果你用青轴感觉到力不从心，但是钱不够，请买茶轴或者红轴；如果你有点闲钱，而且比较有意向打造一个良好的打字环境，那么可以考虑买一个静电容；最后来一张玉照：6. 补充上传一张 Switch 的说明书，说不定以后会用到。1.https://www.zhihu.com/question/39522431/answer/81753723 ↩]]></content>
      <categories>
        <category>买买买</category>
      </categories>
      <tags>
        <tag>买买买</tag>
        <tag>键盘</tag>
        <tag>Realforce</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Experience]]></title>
    <url>%2FHexo%2FHexo%20Experience%2F</url>
    <content type="text"><![CDATA[1. 简介这是我折腾 Hexo 博客框架的经验；希望能给后来者以启迪。2. 我所需要的功能虽然，现今，网上已经很多教你如何一步一步地搭建 Hexo 博客，也有很多人踩过很多坑；不过，对于我的一些要求，仍然有很多的方面未能解决。我主要需要的功能一共有四个：数学公式渲染PlantUML 图TODO ListFootnotes3. 数学公式渲染这个倒是有很多人发了很多博客，然后也解决了一些问题。主要就是 hexo-renderer-marked 中，把 MathJax 中的 _ 解析渲染成了斜体；这样，就造成了解析错误；同时，对于多行的数学公式，也存在很多问题。经过一番倒腾，我的最终决定是使用 hexo-renderer-karmed 代替原先官方自带的 hexo-renderer-marked对于另外的渲染器，它们主要的缺点有：hexo-renderer-pandoc 过于沉重hexo-renderer-markdown-it 不支持 NexT 主题的 『Read More』所以，最后选择使用 hexo-renderer-karmed；不过这个插件在某些时候也存在问题；在这里有一个 workaround4. PlantUML平时我主要使用的 UML 绘图工具就是这个；主要是因为我用 Atom 上面的 markdown-preview-enhanced 能够实时展现 PlantUML 图。Hexo 插件列表中，也存在一个 PlantUML 的插件，hexo-tag-plantuml；不过这个是 tag 插件，如果使用这个的话，我就需要使用标签来定义 UML；而不能使用 markdown 原生的 code fence；此时，我的 markdown-preview-enhanced 也会不起作用；所以就只能自造轮子：自己实现了一个 filter 插件，用来将 code fence 转换成 PlantUML 图。插件源码在这里5. TODO List这个是比较神奇的：之前选择的 kramed 没有这个功能，而 marked 有这个功能；不过幸好代码量不多，可以直接将 PR 中的改动合并到 kramed 中。6. Footnotes这个实际上是一个 Reference 的功能；这个是目前最容易而且也没有坑的；直接安装 hexo-reference 插件即可。参考链接Goon X 的 Hexo 合集如何处理Hexo和MathJax的兼容问题]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scala 泛型和变形]]></title>
    <url>%2FScala%2FScala%20%E6%B3%9B%E5%9E%8B%E5%92%8C%E5%8F%98%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[1. 概述泛型是多态的一个重要组成部分，通过运行时确定的类型来加载对应的类代码；作为一个面向对象语言，Scala 同样具有泛型功能。2. 定义与 Java 不同，Scala 的泛型是使用方括号 [] 定义的：1class List[T] &#123; ... &#125;同样，在泛型方法的定义中，泛型参数的位置也和 Java 不一样：Java:1public static &lt;T&gt; listOf()Scala:1def listOf[T]()3. 上界和下界这个方面，Scala 和 Java 有些许不同；首先，在定义方面，Scala 使用两个特殊的符号表示上下界：A &lt;: B 表示 A 是 B 的子类，也就是 B 是 A 的上界；A &gt;: B 表示 A 是 B 的超类，也就是 B 是 A 的下界。而 Java 使用 extends 关键字来说明。其次，Scala 中，可以使用超类限定类型参数；而 Java 只能使用 extends 即子类限定类型参数：12345// Scala[U &gt;: T]// JavaU super T // ERROR!4. 逆变和协变关于逆变和协变，Scala 相比于 Java 中的 使用声明，还可以在定义中指明协变和逆变。4.1 名词解释如果 A &lt;: B (A 是 B 的子类)，那么对于类 C 来说：$C[A] &lt;: C[B]$ =&gt; C 是协变(covariant)的$C[A] &gt;: C[B]$ =&gt; C 是逆变(contravariant)的$C[A]$ 和 $C[B]$ 没有继承关系 =&gt; C 是不变(nonvariant) 的对 Java 而言，? extends T 提供了协变特性；? super T 提供了逆变特性4.2 定义中指明可变性这是 Scala 和 Kotlin 中相对于 Java 的一个改进，可以在 类定义 中指明泛型可变性。12345// Scalaclass List[+T]// Kotlinclass List&lt;out T&gt;此时，指明了 List 是 协变的，也就是说，List[String] 是 List[Object] 的子类。同理，下面的写法指明了逆变性：12345// Scalaclass List[-T]// Kotlinclass List&lt;in T&gt;当不使用 +、- 号修饰时，就是不变(nonvariant)的4.3 函数事实上，在 Scala 中，函数也是一个对象；def 语句声明的函数会被转化成一个 FunctionN&lt;-T, +U&gt; 类：123class Function1[-T, +U] &#123; def apply(param: T): U&#125;通过 apply 函数来进行函数的调用。我们可以看到，函数参数是逆变的，但是返回类型是协变的；这是为什么呢？实际上，这是里氏法则的应用：如果 $A_2 &lt;: A_1$ 且 $B_1 &lt;: B_2$，那么对于 $A_1 \Rightarrow B_1$ 和 $A_2 \Rightarrow B_2$ 来说：$A_1$ 所接受的范围比 $A_2$ 广，所以使用 $A_1$ 作为参数，可以接受 $A_2$；$B_1$ 比 $B_2$ 要更加严格，所以返回 $B_1$ 就相当于肯定能返回 $B_2$；此时，因为 $A_1 \Rightarrow B_1$ 的形参和返回值都满足 $A_2 \Rightarrow B_2$ 的要求；我们就可以使用前者替代后者，也就是说，此时：A_1 \Rightarrow B_1]]></content>
      <categories>
        <category>Scala</category>
      </categories>
      <tags>
        <tag>Scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scala 类和对象基础]]></title>
    <url>%2FScala%2FScala%20%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[1. 简介Scala 除了是一门函数式语言外，还同时具有面向对象的特征；在 Scala 中，一样具有类和对象以及多态的支持。2. 构造器类具有一个默认的 primary 构造器，它的参数直接位于 class 头中；而且，更加神奇的是，class 中可以直接执行另外的函数；也就是说， 整个类 都是 primary 构造器。对于多个构造器，我们采用如下的声明来实现：123class Person(val name:String, val age: Int) &#123; def this(name: String) = this(name, 17)&#125;通过直接定义 this 来定义一个新的构造器3. 定义和创建和 Java 一样，Scala 中，类使用 class 关键字进行定义：123class ChecksumAccumulator &#123; // class body&#125;不过和 Java 不同的，对象的构建，类没有参数，则不需要括号：1new ChecksumAccumulator4. 字段和方法类中，字段使用 val 和 var 定义，方法使用 def 定义。注意 def 同样要使用等于号 =123456class ChecksumAccumulator &#123; var sum = 0 def checkSum(): Int = &#123; return ~(sum + 0XFF) + 1 &#125;&#125;其中，如果方法需要有副作用，则将其返回值声明为 Unit123def add(b: Int): Unit = &#123; sum += b&#125;此时，方法会忽略函数体最后的值类型，转而将其转换为 Unit如果需要返回 Unit，我们也可以直接省略等于号，使用 Java 中常用的方法声明形式：123def add(b: Int) &#123; sum += b&#125;如果一个函数或者方法的定义没有等于号，那么默认其返回值类型为 Unit。如果需要函数或者方法来推断返回值类型，则需要加上等于号5. Getter 和 Setter很遗憾，Scala 的类成员是字段形式的，所以，不能像 Kotlin 那样采用语法糖式的 getter 和 setter 的写法；相比 Java，Scala 在定义字段时，会自动生成字段的 getter 和 setter，他们的命名为：12def x:T // getterdef x_= : (y: T): Unit // setter注意，方法名为 x 和 x_=那么如何提供自定义的 getter 和 setter 呢？我们只能采用后备字段，同时，将我们自定义的 getter 和 setter 满足上面的命名公约：123456class Person(private var _name: String) &#123; def name = _name def name_= (thatName: String): Unit = &#123; _name = thatName &#125;&#125;这样，我们就能够像使用属性一样使用 name 了。123val p = new Person("hehe")p.name = "nihao"6. 可见性简述Scala 中，默认的可见性是 public；其余的可见性修饰符和 Java 一致。7. 伴生对象Scala 没有静态成员，但是具有伴生对象(companion object)，是对象(object) 的一种。对象是一个 单例，当对象和类在同一个文件中定义，具有同样的名称时，称对象是类的伴生对象。对象不带参数，不能通过 new 关键字进行构建。方法的调用形式和 Java 的静态方法调用相同。12345678910111213object ChecksumAccumulator &#123; private val cache = Map[String, Int]() def calculate(s: String): Int = if (cache.contains(s)) cache(s) else &#123; val acc = new ChecksumAccumulator for (c &lt;- s) acc.add(c.toByte) val cs = acc.checksum() cache += (s -&gt; cs) cs &#125;没有伴生类的对象称为 孤立对象，实际上就是一个简单的单例。8. 类的解析过程Scala 采用代换模型对表达式进行解析，那么它是如何解析类的定义和声明调用的呢？对此，有如下的几个步骤：将 new 关键字当成普通方法进行代换，最终为值解析类定义中的方法形参解析构造器形参将 this 关键字替换成 new 的表达式将上述解析到的所有值进行代入，函数解析为字面量继续代换，最终得到结果]]></content>
      <categories>
        <category>Scala</category>
      </categories>
      <tags>
        <tag>Scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 集合框架]]></title>
    <url>%2FJava%2FJava%20%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[1. 介绍任何语言都会提供一套基础的数据结构的库；Java 也不例外，而且提供了一个庞大的数据结构库，有时对于它们之间的选择让人很困惑。这里就来简单说明一下 Java 的 Collection 和基本的 Collection 数据结构2. 接口关系图和现代的数据结构类库一样，Java 采用了 Collection 接口和实现相分离的策略。通过这样，来做到使用一个统一的接口，对某种数据结构的不同实现进行多态调用。基本的 Collection 接口继承关系如下：需要注意的是，Map 并非 Collection 的子类，而是自成一派。同时，这些接口都是 泛型接口，可以使用它们定义泛型方法。3. 接口具体含义这些接口的具体含义如下：CollectionCollection 类结构的根，一个 Collection 代表了一堆对象的集合体，对象通常被称作 元素Set一个 不能拥有重复元素 的 Collection，类似数学意义上的集合List一个 有序的 Collection，有时也被称作 序列(sequence)一般来说，List 的用户对于 List 有着比较精确地控制用户可以使用索引来进行元素的查找和插入操作Queue一个存储着即将进行处理的元素的 Collection相比 Collection，它提供了特别的加入、删除和查找操作比较特别的是，队列一般来说具有 先进先出(FIFO) 的插入和删除次序队列的新元素位于队列末尾，旧元素位于队列头部Deque双端队列，在队列两头都可以进行插入和删除操作同时，双端队列也同时支持 先进先出(FIFO) 和 后进先出(LIFO) 的插入和删除策略Map一个存储键值对的对象Map 不能包含重复键，每个键可以被映射到最多一个值上SortedSet一个它的元素按照 升序排列 的 SetSortedMap一个它的键按照 升序排列 的 Map4. Abstract 类集合框架中，除了接口和具体实现，还提供了一系列的 Abstract* 类；它是 Collection 和 Map 以及其子接口的简单实现形式，利用泛型来提供了一些通用的方法；比如 contains() 方法，就是利用了泛型的 Iterator 实现的。Abstract 类是用于进行具体集合类实现的，通过继承 Abstract 类，可以极大减轻5. 视图在通常情况下，我们需要将一个具体的 Collection 或者 Map 对象转换成另一种集合框架内的具体对象进行操作；所以，集合框架提供了一种很有用的视图技术；视图(views) 指的就是返回一个实现了 其他接口 的 引用，通过这个引用，来进行 原有集合 的操作，这个对象引用就是视图。5.1 Array.asList()不仅集合框架中存在包装器，Array 类中也存在可以包装成一个 List 的方法；它返回一个 List 的视图，可以通过它来使用 List 中的访问方法（包括 get 和 set）对 原数组 进行访问和元素的修改；但是，不能调用 add() 和 remove() 这种能够对数组大小产生影响的方法；注意，视图对象始终是在 原对象 进行操作的。有趣的是，asList() 返回的也是 ArrayList 对象不过，不是 java.util.ArrayList，而是 java.util.Arrays.ArrayList，是其自身的一个子类Java 5 之后，asList() 方法声明为了不定参数，可以直接传入元素进行转换操作。5.2 子范围可以使用诸如 subXXX() 和 headXXX() 和 tailXXX() 方法返回 Collection 的一个子范围；可以通过这个子范围视图对集合的一部分进行操作。5.3 不可变的视图通过 unmodifiableXXX() 可以获取一个不可修改的视图；这个视图中的所有的更改器方法都会返回 UnsupportedOperationException；当然，这不意味着其原始集合不能被更改，只是视图对象不能更改原有集合，但是通过原始集合的引用，同样可以更改原始的集合。需要注意的是，unmodifiableCollection() 返回的集合是通过原始的 Object.equals() 方法进行相等性判断的；也就是说，不能通过 Collection 视图进行相等性判定。5.4 同步视图集合框架还提供了一个同步视图，用来进行一系列的多线程同步工作。通过 synchronizedXXX() 可以获取到一个线程安全的 Collection 或者 Map；不过，这个线程安全仅限于一些基本的方法；对于遍历方法，包括使用迭代器和 Stream，都需要 手动进行同步5.5 检查视图在 Java 5 引入泛型之后，集合框架提供了一个检查视图；它专门用于检查是否有其他类型的对象混入了集合之中。例如：123ArrayList&lt;String&gt; strings = new ArrayList&lt;&gt;();ArrayList a = strings;a.add(new Date());由于使用了原始类型，编译器无法发现这一泛型错误。使用检查视图，我们就可以发现这一错误：1List&lt;String&gt; checkedStrings = Colllections.checkedList(strings, String.class);当发现类型不符合时，它会立即抛出一个 ClassCastException；不过，它也有缺陷，它是依赖于虚拟机的泛型安全机制；当向 ArrayList&lt;Pair&lt;String&gt;&gt; 中插入 Pair&lt;Date&gt; 时，就不能检测出这种错误。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scala Hello World]]></title>
    <url>%2FScala%2FScala%20Hello%20World%2F</url>
    <content type="text"><![CDATA[1. 简介Scala 既可以使用交互式命令行来编程，也可以将其写成一个独立的程序；其中，关于构建独立程序的写法一共有两种。2. main() 方法使用 main() 方法是通常各种语言的程序入口，Scala 也不例外：123def main(args: Array[String]) &#123; println("Hello, World!")&#125;3. 使用 Application 特质123object Hello extends Application &#123; println("Hello, World!")&#125;]]></content>
      <categories>
        <category>Scala</category>
      </categories>
      <tags>
        <tag>Scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scala 简介]]></title>
    <url>%2FScala%2FScala%20%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[1. 概述Scala 是高层级的，函数式，基于 JVM，完美调用 Java 的编程语言。其主要特点就是它是一门函数式语言。语法上，Kotlin 借鉴了其大部分的语法，所以体现出和 Kotlin 非常相似的特征。同时，由于基于 JVM，所以类型系统和 Java 没有多大区别。2. 什么是函数式语言函数式语言的两大理念：函数也是值，可以作为参数，也可以保存在变量中，与其他类型同级函数只应该接受参数输入，并输出返回值，不应该具有其他副作用3. 没有分号这里需要说的一个问题是，虽然 Scala 没有分号；但是当你写长表达式的时候可能会有问题：12someLongExpression+ someOtherExpression上面的语句会被隐式加上分号：12someLongExpression;+ someOtherExpression这样显然是不符合我们的实际意图的，解决办法有两个：使用括号12(someLongExpression + someOtherLongExpression)将操作符放在行尾12someLongExpression +someOtherExpression分号推断的规则为，除非以下情况，否则行尾将会被认为是一个分号：行尾由一个不能合法作为行尾的字符结束，如句点(.) 和中缀操作符 (+、-)下一行开始于不能作为语句开始的字行结束于括号(()) 和 方括号 ([]) 之中由于括号中不能容纳多个语句，所以，它之中的行不可能是一个逻辑行4. 面向对象Scala 中所有东西都是 对象；操作符实际上是对象的 方法5. 变量定义语法上和 Kotlin 无多大差别1var x: Int = 06. 函数定义1234def max(x: Int, y: Int): Int = &#123; if (x &gt; y) x else y&#125;有趣的是，Scala 中，函数定义需要一个等号；这意味着，函数实际上是一个 变量，而函数体实际上是一个 返回值的表达式。同时，函数体 没有 return，这主要是因为函数体是一个 表达式，而一个表达式理应返回其计算得到的值。这正好体现了函数式编程的思想，函数是一个值，函数体是一个表达式。7. 使用函数式风格Scala 程序员在解决问题时，应该优先考虑函数式风格而非指令式风格。简单的判断标准有：尽量使用 val 解决问题使用 var 会让你的 编码层级变低，而函数式编程的一个重要作用就是使你的视野聚焦在高层级中。尽量避免定义返回 Unit 的函数函数式编程一个理念就是函数体是表达式，而返回 Unit (Java 中的 void) 的函数一般来说都具有 副作用 (即函数做了不是生成返回值的工作)]]></content>
      <categories>
        <category>Scala</category>
      </categories>
      <tags>
        <tag>Scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 集合框架 Collection]]></title>
    <url>%2FJava%2FJava%20%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%20Collection%2F</url>
    <content type="text"><![CDATA[1. 概述Collection 接口是 Java 集合框架最基本的接口；它提供了基本的元素操作方法和遍历使用的迭代器；同时，它还提供了关于 Collection 的批量操作方法。2. 基本操作基本的元素操作包括 add() 和 remove()，同时也包括 size() 和 isEmpty() 等一系列的集合基本操作。其中 add() 和 remove() 的返回值是 boolean；这个布尔值用于表示增加和删除是否成功。（是否对集合本身进行了操作）3. 遍历操作Java 的 Collection 遍历操作有三种：使用迭代器 Iterator使用 for each 循环使用 Stream 的聚合操作(Java 8)实际上，使用 for each 循环和使用迭代器是一样的；for each 可以应用于任何实现了 Iterable 接口的类：123public ineterface Iterable&lt;E&gt; &#123; Iterator&lt;E&gt; iterator();&#125;for each 实际上就是应用它返回的迭代器进行遍历操作。关于 Stream 用单独的一篇文章介绍，这里主要解析迭代器的工作。4. 迭代器的遍历12345public interface Iterator&lt;E&gt; &#123; E next(); boolean hasNext(); void remove();&#125;其中，next() 方法返回下一个元素，hasNext() 方法用于检测是否到达了集合末尾。当到达了集合末尾时，调用 next() 会抛出 NoSuchElementException，所以，正确的写法是在循环时使用 hasNext() 作为判断条件：123while(iter.hasNext()) &#123; element = iter.next();&#125;其中，Collection 接口已经扩展(extends)了 Iterable 接口，所以自带 iterator() 方法。元素被访问的顺序取决于集合类的具体实现。比较特别的是，Java 中的迭代器和 C++ 中的迭代器不一样；C++ 中的迭代器是基于索引的，可以不执行查找操作就将迭代器进行移动；相反，Java 中的迭代器更类似于 read() 方法，迭代器的查找操作和移动操作紧密相连；Java 中的迭代器更类似于是 位于两个元素之间，调用 next() 将越过一个元素，并返回这个元素的引用。5. 迭代器的删除比较特别的是，Iterator 接口还提供了一个 remove() 方法；它会删除 上次 调用 next() 的元素；也就是说，如果你想删除某个位置上的元素，你的迭代器就必须 先越过 这个元素。1234Iterator&lt;String&gt; it = c.iterator();iter.next(); //skip over the firstiter.remove(); // delete the first需要注意的是，next() 和 remove() 是具有依赖性的；不能连续调用两次 remove()，否则，将会抛出 IllegalStateException12iter.remove();iter.remove();必须先调用 next() 来越过将要删除的元素。6. 批量操作Collection 同时提供了一套批量操作方法，用于对另一个集合进行操作，主要的方法有：containsAll()判断另一集合是否为本集合的子集（本集合是否完全包含了另一集合）addAll()将另一集合的所有元素加入到本集合中removeAll()将本集合中含有的 另一集合中的所有元素 从本集合中删除retainAll()将本集合中 不属于 另一集合的所有元素从本集合中删除即，将本集合改造成两个集合的 交集clear()删除本集合中的所有元素7. 和数组的转换操作Collection 存在一个 toArray() 方法；但是，比较坑爹的是，这个方法仅仅只返回一个 Object[]；1Object[] a = c.toArray();这显然没有什么卵用，因为 Object[] 是 新构建的，它不能强制转换成更为具体的数组。所以，我们需要采用另一个 toArray(T[] a) 方法；12// 写法一String[] stringArray = c.toArray(new String[0]);实际上，我们可以直接向 toArray() 提供一个足够大的数组：12// 写法二String[] stringArray = c.toArray(new String[c.size()]);那么这两种写法有什么区别呢？根据 JDK 文档，当数组参数的空间不够大时，它会自动重新构建一个足够大的数组进行元素转存；当数组空间足够大时，toArray() 就不自己构建数组了，而是直接将元素储存到数组中。这样看来，写法一好像没有什么必要，毕竟都要创建数组，不如直接创建了事，何必要多出一个无用的数组呢？实际上，写法二具有线程安全问题；即使你使用线程安全的 Collection，但是当有元素在 size() 和 toArray() 之间被删除了，那么最终生成的数组就会包含 null。而，写法一就可以直接避免这个问题。线程安全的 Collection 只保证每个方法是线程安全的，当你调用两个以上的方法联合使用时，就不具备线程安全了。Reference: The easiest way to transform collection to array?]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scala 函数式特征]]></title>
    <url>%2FScala%2FScala%20%E5%87%BD%E6%95%B0%E5%BC%8F%E7%89%B9%E5%BE%81%2F</url>
    <content type="text"><![CDATA[1. 函数类型函数类型是函数式语言的特征之一；其原因在于，函数是语言中的一等公民，可以作为变量，而变量是具有类型的。Scala 的函数类型定义如下：1f: Int, Int =&gt; Int使用箭头将参数类型和返回值类型相间隔；上面的例子表示函数 f 接受两个 Int 参数，返回值类型为 Int2. 高阶函数高阶函数指的是接受 函数作为参数 的函数，它的参数是函数类型。Scala 中的高阶函数如下：123def sum(f: Int =&gt; Int, a: Int, b: Int) = if(a &gt; b) 0 else f(a) + sum(a + 1, b)其中，f 是函数类型的参数，它接受一个 Int 作为参数，返回值是一个 Int；上面的例子如下数学公式的求法：\sum_a^b{f(a)}3. 匿名函数(函数字面量, lambda)作为语言的基本类型，如字符串，我们可以使用字面量表示它，如：12val s = "abc"println(s)上面可以直接写成1println("abc")在 Scala 中，函数也具有这种特性，我们可以直接定义一个函数字面量：12val f = (x: Int) =&gt; x * xsum(f, 1, 3)如上，f 是一个函数，具有参数 x，返回 x 的平方也可以将字面量直接传入1sum(x =&gt; x * x, 1, 3)大部分情况都不需要显式指定参数的类型，编译器会进行自动推断；同时，无法在函数字面量中显式指定函数的返回值类型只能通过定义函数变量的类型来进行显示指定实际上，Scala 中的匿名函数就是其他语言中的 lambda 表达式；就函数式上来说，Scala 提供了一种更轻便的语法4. 柯里化4.1 定义柯里化是函数式范式的一个特有现象；它指的是，一个函数，通过接受部分参数，可以返回接受剩余参数的 嵌套函数；事实上，对于一个函数def \ f(arg_1)\ldots(arg_n) = E当 $n \gt 1$ 时，以下的写法和上面是等价的：def \ f(arg_1)\ldots(arg_n) = \{def \ g(arg_n) = E; \ g\}所以，我们可以通过编写嵌套的接受部分参数的函数，并返回它，来达到柯里化的目的；实际上，这个过程就叫做柯里化。\begin{align} f(arg_1)(arg_2)\ldots(arg_n) \\ &= arg_1 \Rightarrow \{f(arg_2)\ldots(arg_n)\} \\ &= arg_1 \Rightarrow \{arg_2 \Rightarrow \{f(arg_3)\ldots(arg_n)\}\} \\ &= \cdots \\ &= arg_1 \Rightarrow arg_2 \Rightarrow arg_3 \Rightarrow \ldots \Rightarrow f \end{align}4.2 显式柯里化sum 函数可以使用如下的方法进行重写：1234567def sum(f: Int =&gt; Int): (Int, Int) =&gt; Int = &#123; def sumF(a: Int, b: Int) = &#123; if(a &gt; b) 0 else f(a) + sumF(a + 1, b) &#125; sumF&#125;上面的写法被称作 显式柯里化，就是将一个接受多个参数的函数通过显式编写一个内部的嵌套函数，并返回这个函数来达到柯里化。在调用时，我们可以直接如下调用：1sum(x =&gt; x * x) (1, 10) // 1^2 + 2^2 + ... + 10^2第一个括号，调用了外部函数，返回值是内部的 sumF 函数；这使得我们可以 继续使用括号 进行 sumF 的调用4.3 隐式柯里化许多函数式编程语言都提供柯里化的语法糖，这被称作 隐式柯里化；Scala 也提供了这样的语法糖：123def sum(f: Int =&gt; Int)(a: Int, b: Int) = if (a &gt; b) 0 else f(a) + sum(f)(a + 1, b)通过使用两个括号，就可以直接定义最内部的函数体，而不需要再定义一个内部的嵌套函数；这可以让我们像进行柯里化函数调用一样，定义柯里化函数4.4 柯里化的目的柯里化相比我们定义一个多参数函数来说，要稍显复杂；那么为什么不直接定义一个多参数函数呢？实际上，使用柯里化的目的在于可以动态确定参数；当函数的某些参数不确定时，我们可以先保存一个存根；剩余的参数确定之后，可以通过存根直接调用剩下的参数。柯里化的另一个用处类似建造者模式(Builder Pattern)，可以通过柯里化来减少参数和函数重载的爆炸。5. 部分应用(partially application)部分应用指的是， 固定 函数的某些参数，可以获取一个接受剩下参数的函数；有点类似于在运行时给予函数默认值。Scala 的部分应用写法如下：12345def add(a: Int, b: Int, c: Int) = a + b + cdef addA5 = add(5, _:Int, _:Int)addA5(2, 3) // 5 + 2 + 3可以看到，我们通过将参数 a 的值固定为 5 得到了一个新的函数；它接受 b 和 c，返回 5 + b + c6. 柯里化和部分应用的区别这两个概念经常被混淆，但是实际上有着一些差别：柯里化指的是将多参数函数 分解为 多个单参数（组）函数的特性部分应用指的是通过 固定 某个参数，得到接受剩余参数函数的特性虽然它们调用的效果都是返回一个函数，但是，两者一次调用返回的函数具有显著的不同：柯里化返回的函数只接受一个参数（组）由于返回的是层层嵌套的函数，所以会出现函数的连续调用add(1)(1)(1)(1)(1) 中，对于一个 (1)，返回的函数是接受另一个 1，同时将剩下的内部嵌套闭包返回部分应用返回的函数可以接受多个参数相比柯里化，部分应用返回的函数可以直接接受多个参数，如add_1(1,1,1,1)固定了第一个 1 之后，剩下的 1 可以直接传入，而不需要连续调用柯里化通过将函数分解嵌套来减少函数的参数；函数的部分应用通过给予参数默认值来减少函数的参数。柯里化函数的调用是函数的连续调用，而函数的部分应用是函数的一次调用。]]></content>
      <categories>
        <category>Scala</category>
      </categories>
      <tags>
        <tag>Scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计阶段]]></title>
    <url>%2FReviews%2FTSPi%2F%E8%AE%BE%E8%AE%A1%E9%98%B6%E6%AE%B5%2F</url>
    <content type="text"><![CDATA[1. HLD(作业)设计阶段要完成高层设计，出 SDS，软件设计规格说明（体系结构文档）包含：软件层次架构设计功能模块设计要根据需求分析书来数据库设计就是数据库设计，包括 E-R 图和数据库表设计接口和界面设计2. 设计标准Naming Conventions命名公约，各项命名的规定Interface formats内部的 API 接口设计和外部的 UI 设计界面设计线图（界面区域划分）System and Error Messages就是 LOG 和 Exception 界面Defect Standars缺陷标准，使用 PSPi 的就行LOC counting只计算新增的和修改过的代码Design Representation Standards就是 SDS 的内容3. 设计复用库复用的接口标准复用的文档标准复用部分的质量标准应用复用库的技术支持]]></content>
      <categories>
        <category>复习</category>
        <category>SPI</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>SPI</tag>
        <tag>TSPI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现阶段]]></title>
    <url>%2FReviews%2FTSPi%2F%E5%AE%9E%E7%8E%B0%E9%98%B6%E6%AE%B5%2F</url>
    <content type="text"><![CDATA[1. 实现标准扩展了设计标准Standards Review审查了世界标准Naming, interfae and message standardsCoding Standards编码规范Size Standards2. 表格INSLOGTLOGD3. 策略复查复用测试]]></content>
      <categories>
        <category>复习</category>
        <category>SPI</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>SPI</tag>
        <tag>TSPI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命令模式]]></title>
    <url>%2FDesignPattern%2F%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1. 概述命令模式将『请求』封装成对象，以便使用不同的请求，队列或者日志系统。命令模式也可以支持可撤销和回滚操作。命令模式通过将请求进行封装，成功地将客户和具体的低层组件进行解耦；客户只需要知道要加载命令，而不需要知道如何进行命令的具体执行操作。2. 类图结构可以看到，Client 处于最高层，它不需要知道 Command 的执行过程；这就达到了客户和低层组件的解耦目的。3. 封装请求调用者一个很重要的地方就是我们的请求接收者 Receiver 和我们的命令对象 Command 是组合关系也就是说，Command 具有一个接收者的内部对象；否则，它无法真正地成为一个可以执行的命令。123456789101112131415161718public interface Command &#123; void execute(); void undo();&#125;public class ConcreteCommand implements Command &#123; private Receiver receiver; public ConcreteCommand(Receiver receiver) &#123; this.receiver = receiver; &#125; @Override public void execute() &#123; receiver.action(); &#125;&#125;4. 支持撤销和回滚通常的命令都会具有可撤销的属性要求；那么我们如何实现这个可撤销的需求呢？撤销实际上就是返回到命令执行前的一个状态中；所以在实际的命令对象类中，我们通过记住 上一个 命令时的状态，就能实现撤销功能。123456789101112131415161718192021222324252627public class CeilingFanHighCommand implements Command &#123; CeilingFan ceilingFan; int prevSpeed; // 前一个命令后风扇的转速 public CeilingFanHighCommand(CeilingFan ceilingFan) &#123; this.ceilingFan = ceilingFan; &#125; public void execute() &#123; prevSpeed = ceilingFan.getSpeed(); &#125; public void undo() &#123; if (prevSpeed == CeilingFan.HIGH) &#123; ceilingFan.high(); &#125; else if (prevSpeed == CeilingFan.MEDIUM) &#123; ceilingFan.medium(); &#125; else if (prevSpeed == CeilingFan.LOW) &#123; ceilingFan.low(); &#125; else if (prevSpeed == CeilingFan.OFF) &#123; ceilingFan.off(); &#125; &#125;&#125;5. 使用空对象替代 null对于命令模式来说，它的客户类还是有一些细微的要求；我们可以使用一个队列或者数组来代表需要执行的命令插槽；当插槽没有加载命令时候，我们普通的做法是使用一个 null 来进行替代；但是，此时我们就需要对命令对象进行空检测：12345public void onButtonWasPushed(int slot) &#123; if (onCommand[slot] != null) &#123; onCommand[slot].execute(); &#125;&#125;对此，我们可以使用一个 NoCommand 对象，它是一个命令对象，只不过什么都不做；这样，即使插槽没有加载命令，我们也可以直接使用 NoCommand 来替代，这样就不需要进行空检测了：123456Command noCommand = new NoCommand();for (int i = 0; i &lt; 7; i++) &#123; onCommands[i] = noCommand; offCommands[i] = noCommand;&#125;6. 宏命令命令模式的一个最大的优点就是能使用宏命令；也就是一次调用，执行多个命令；实际上，我们只需要将命令对象中包装的接收者变成命令对象数组即可：12345678910111213public clas MacroCommand implements Command &#123; Command[] commands; public MacroCommand(Command[] commands) &#123; this.commands = commands; &#125; public void execute() &#123; for (int i = 0; i &lt; commands.length; i++) &#123; commands[i].execute(); &#125; &#125;&#125;7. 队列请求除此之外，命令模式还可以使用于工作队列；也就是说我们可以构建一个接受命令对象的队列，它只是按照顺序进行命令的执行操作；当线程可用时，它就会将命令分配给线程，然后执行 execute()；队列并不需要关心命令究竟是什么，是如何完成的，只需要对命令进行调度即可。8. 日志和恢复除了队列以外，我们另一个应用范围就是日志系统和崩溃恢复；为了完成这个功能，我们可以在命令接口中添加 store() 和 load() 方法；当调用者调用命令时候，同时调用 store() 将命令对象序列化到服务器中进行存储；当崩溃发生，需要恢复时，我们就可以将存储服务器中的命令对象进行反序列化，然后调用 load() 方法；9. 优缺点命令模式的优点非常明显，就是可以完全实现客户类和低层组件的解耦；高层的调用者不需要知道命令执行的具体细节，只需要调用接口的方法就可以执行命令的调用。但是缺点是它需要创建不同的命令对象来进行不同的命令接收者的包装；这就会让我们的代码中出现很多的小型类。]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
      <tags>
        <tag>DesignPattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scala 函数解析]]></title>
    <url>%2FScala%2FScala%20%E5%87%BD%E6%95%B0%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[1. 代换模型Scala 使用代换模型对函数和表达式进行解析工作；所谓的代换模型就是类似平常算术的过程；从左到右地将函数和表达式一步一步转换，最终转换成值。例如：1(2 * 2) + (4 * 5)对于上面的式子 Scala 是如何解析的呢？我们从左到右地解析，首先，我们解析 (2 * 2) 的内容，将其替换成值 4；此时，式子变为：14 + (4 * 5)由于有括号，和乘法的算术等级较高，所以我们接下来对 (4 * 5) 进行解析；此时，式子变为：14 + 20此时，我们计算上面的值，最后得到 24。可以看到，Scala 的解析是符合我们通常的算术解析规律的。2. 代换模型的缺陷使用代换模型最重要的一个要求就是，我们的表达式最终 能够 规约到一个 值；如果它最终不能够规约到一个值(无限循环，Non-Terminate)；或者表达式对其外部的变量产生了影响(副作用)；都会对代换模型造成污染。3. 副作用所谓的副作用就是指的是，函数和表达式的执行过程修改了外部的变量。例如，c++ 这个表达式就具有很明显的副作用；因为我们不能够直接将这个表达式规约为一个值；在执行的过程中，我们需要对 c 这个外部传入的变量进行修改；这就让这个表达式显得不够纯粹，这时候我们就说它具有 副作用4. 不能终结的解析所谓的不能终结的解析就是指的一个函数返回它自身；例如：1def loop(x: Int) = loop这个函数的解析永远也不会完成，这是因为我们如果使用代换模型对其进行解析的话，会发现，它的解析结果一直是其自身；所以，对它的解析会一直进行下去，无法完成。5. 参数解析Scala 有两种参数解析方式，不像其他的指令性语言只有一种解析方式；其中的一种叫传值调用(call-by-value)，另一种叫传名调用(call-by-name)。5.1 传值调用(call-by-value)这是 Scala 的默认的参数解析方式，也是其他指令性语言常用的参数解析方式。主要的解析步骤如下：将传入参数的表达式解析为值将函数使用函数体进行替换将函数的形参替换为第一步中得到的实参例如：123def square(x: Int) = x * xsquare(2 + 2)对于上面的代码，解析步骤如下：将 2 + 2 进行计算，得到它的值 4将 square 使用它的函数体进行替换，得到 x * x将 x 代换为 4计算出结果 165.2 传名调用(call-by-name)这是 Scala 的另一种参数解析方式，也是其他指令性语言不具备的。只要在定义参数时，使用 =&gt; 就可以定义传名调用的参数1def square(x: =&gt; Int) = x * x主要的解析步骤如下：将函数名替换为函数体直接将参数的表达式代入形参对得到的表达式进行解析和计算，得出结果还是使用上面的例子，解析步骤如下：将 square 替换为 x * x将 2 + 2 代入 x 中对得到的式子 (2 + 2) * (2 + 2) 进行代换模型的计算得到结果 165.3 区别那么这两种计算结果有什么区别呢？首先，传名调用具有懒加载的功能，直到参数 被使用 的时候，才进行参数表达式的解析；例如：12345def first(x: Int, y: Int) = xdef first(x: =&gt; Int, y: =&gt; Int) = xfirst(2 * 2, 4 * 4)此时，我们忽略了第二个参数，对于传名调用来说，它不需要解析 y 这个参数，只需要将它传入函数体即可；而对于传值调用，则需要先解析出 x 和 y 的值，即使 y 的值不会在函数体内使用到。其次，传名调用可以避免无限循环问题；对于上面的例子来说，我们可以这么调用：1first(1, loop)对于传名调用来说，由于它是直接传入函数体，然后，函数体并没有使用 y 这个参数；此时，我们就避免了对 loop 的解析工作；但是对于传值调用则不然，我们还是要对 loop 进行解析，从而出现无限循环问题。5.4 默认传值调用的原因既然传名调用具有那么多的好处，但是为什么还要默认使用传值调用呢？这是因为传值调用在具体实践过程中，比传名调用的执行要快；其次，由于 Scala 并不是纯函数式语言，实际上，它的函数还是允许有副作用的；并且同时还要支持和 Java 的互调用，而 Java 是指令式语言，采用传值调用显然会更好些。]]></content>
      <categories>
        <category>Scala</category>
      </categories>
      <tags>
        <tag>Scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[装饰者模式(Decorator Pattern)]]></title>
    <url>%2FDesignPattern%2F%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F(Decorator%20Pattern)%2F</url>
    <content type="text"><![CDATA[1. 概述装饰者模式 动态的 将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的解决方案2. 新的设计原则类应当对扩展开放，对修改关闭这乍看上去很矛盾，如何做到“既开放又关闭” 呢？实际上，我们可以采用 组合 和 委托 来达到扩展的目的；而 避免因为扩展而需要修改代码Bug 总是在修改、新增代码时引入的；如果能够尽量减少对代码的反复更改，那么就可以更有效的减少和避免 Bug装饰者模式就很好的体现了 “开放——关闭” 原则。3. 原理使用不同的 装饰者对象 来对 主体对象 进行装饰；通过 委托 来进行组合工作。这里有一个很重要的地方就是，为什么能实现上面图示的 包装 和 方法委托其使用到的技巧就是， 装饰者对象实际上也是主体对象，即它们有相同的超类。如果不具备相同超类的话，最多只能做到一层包装，而无法做到动态的，多层包装。注意，这里采用相同的超类，实际上只是为了做到 类型匹配，而装饰者并没有从超类中继承它的 行为。继承的原罪在于， 在运行时，行为需要改变！ 如果行为从继承中得到，那么它在编译时就会被确定，也就是所谓的 与具体实现绑定。但是，如果行为不从继承中得到，那么继承反而成了优点，因为继承可以实现多态，为我们的动态扩展提供合适的条件4. 特点装饰者和被装饰对象有 相同的超类型可以使用一个或者 多个 装饰者来包装对象由于有相同的超类型，所以在需要被装饰对象的场合时，可以使用装饰过后的对象来替代装饰者可以在所委托被装饰者的行为之前、之后，加上自己的行为，以达到特定的目的对象可以在任何时候被装饰，可以在运行时，动态地、不限量地对对象进行装饰5. UML 图解可以看到，装饰者和主体对象有一个 共同的超类同时， Decorator 和 Component 都是 抽象类对于实际的装饰者，他们都包含了一个 Component 实例，这就是被其装饰的对象，通过多态来进行方法委托。图中的 wrappedObject 需要从外部获得，一般来说，是通过 构造函数 传入的。6. 例子图解7. 真实的装饰者模式——Java IOJava IO 库中大量使用了装饰者模式，这也就是为什么会出现如下的代码：12InputStream in = new BufferdInpuStream(new FileInputSteram());可以看到 FileInputSteram 是被装饰的主体对象，而 BufferdInpuStream 是装饰对象。8. 缺陷装饰者对象的缺陷很明显，就是会 增加大量的小对象。同时，由于装饰者模式是通过 层层委托 来实现扩展的；所以，当装饰者需要改变的时候，就需要将改变应用到 所有的装饰者；此时，当装饰者数量较多时，更改难度大。]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
      <tags>
        <tag>DesignPattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin 使用 Gradle]]></title>
    <url>%2FKotlin%2FKotlin%20%E4%BD%BF%E7%94%A8%20Gradle%2F</url>
    <content type="text"><![CDATA[1. 概述一般来说，IntilliJ 会自动的给我们配置 Kotlin 的 Gradle 设置；但是，有时候我们也想自己进行一些自定义的 Gradle 配置；下面就来总结几个常用的配置方法2. 去除 src 中的 java 目录虽然说 Kotlin 经常和 Java 混着写，但是，有时候我们想写一个纯 Kotlin 程序的时候，却发现 src 目录中一直存在着一个 java 目录；这着实激起了我的强迫症，解决方法如下：1234sourceSets &#123; main.java.srcDirs = ['src/main/kotlin'] test.java.srcDirs = ['src/test/kotlin']&#125;这是 gradle java 插件中常用的指定源文件位置的方法；不过需要注意的是，即使我们使用的是 kotlin 插件，也要使用 main.java；而不能使用 main.kotlin这应该是因为 kotlin 插件继承了 java 插件的源文件位置设定的结果。2. 指定字节码版本有时候我们想使用一些高级的语言特性，不想为低级的 JVM 编写代码；这个时候就需要指定字节码版本；在 java 插件中，我们可以通过 sourceCompatibility 和 targetCompatibility 来解决这个问题；不过在 Kotlin 中，我们还有对应的 JVM 版本和语言和 API 版本可以设定（注意，仅在 Kotlin 1.1 之后可以使用）；12345678910compileKotlin &#123; sourceCompatibility = JavaVersion.VERSION_1_8 targetCompatibility = JavaVersion.VERSION_1_8 kotlinOptions &#123; jvmTarget = "1.8" apiVersion = "1.1" languageVersion = "1.1" &#125;&#125;注意一定要在 compileKotiln 中，因为这个是编译 Kotlin 时候的选项。]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin 基本类型]]></title>
    <url>%2FKotlin%2FKotlin%20%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Kotlin 中，任何事物都是对象。1. 数字类型Kotlin 中的数字类型有 Double、Float、Long、Int、Short、Byte1.1 位宽TypeBitWidthDouble64Float32Long64Int32Short16Byte8注意，在 Kotlin 中，字符不是一种数字类型1.2 字面常量数字类型可以有多种字面表示形式。整数十进制数字 123Long 类型通过加 L 后缀实现: 123L十六进制 0x0F二进制 0b00001011浮点数默认为 Double 类型: 123.5, 123.5e10使用 f 或者 F 后缀来表示 Float: 123.5f1.3 表示法Kotlin 中，任何数字都会被自动装箱123456val a: Int = 10000print(a === a) // trueval boxedA: Int? = a // 在类型后加 ? 表示一个 Nullable 对象val anotherBoxedA: Int? = aprint(boxedA === anotherBoxedA) // falseprint(boxedA == anotherBoxedA) // true上面是一个很好的例子，由于所有的数字都会被自动装箱，所以 boxedA 与 anotherBoxedA 不一致。但是由于两者均指向 a，所以保持了相等性。这里的 Int 与 Java 的 Integer 相同1.4 转换Kotlin 的原则之一就是尽量让事务明显化。所以，Kotlin 禁止隐式转换，就算是隐式向上转换也是不允许的。123val a: Int? = 1val b: Long? = aprint(a == b) // false由于 Int 不是 Long 的子类，而且禁止隐式转换，所以即使 b 指向了 a，它们也不相等。12val b: Byte = 1 // OKval i: Int = b // ERROR字面值会经编译器静态检查赋值给整数形式的变量，但是由于禁止隐式转换，第二个语句会产生 ERROR。需要转换时，应采用内置的转换方法toByte()toShort()toInt()toLong()toFloat()toDouble()toChar()1.5 位运算符Kotlin 支持全套 Java 的普通数字运算符。但关于位运算符则稍有不同，Kotlin 采用单词型而非 Java 的符号型位运算符。下面是 Kotlin 的位运算符列表shl(bits) =&gt; 位左移，相当于 Java 的 &lt;&lt;shr(bits) =&gt; 位右移，相当于 Java 的 &gt;&gt;ushr(bits) =&gt; 无符号数右移，相当于 Java 的 &gt;&gt;&gt;and(bits) =&gt; 按位取与操作，相当于 Java 的 &amp;or(bits) =&gt; 按位取或操作，相当于 Java 的 |xor(bits) =&gt; 按位取异或操作，相当于 Java 的 ^inv() =&gt; 按位取反操作，相当于 Java 的 ~2. 字符类型字符类型使用 Char 来表示，字符不是数字。123fun check(c: Char) &#123; if (c == 1) // ERROR&#125;字符使用单引号括起来&#39;1&#39;，反斜杠 \ 表示转义，转义字符和 Java 相同。和数字类型一样，字符类型也被自动装箱，保持相等性，而不保持一致性。3. 布尔类型使用 Boolean 来表示布尔类型，布尔类型有两个值，true 和 false。内置的逻辑布尔操作与 Java 相同。4. 数组使用 Array 表示数组，这是一个泛型类，类似于 Java 中的 ArrayList&lt;T&gt;，但并不完全相同。数组是 invariant 的，也就是说不能把 Array&lt;String&gt; 的数组赋予 Array&lt;Any&gt; 的实例，这会产生一个runtime failureKotlin 同样拥有 List 和 ArrayList 类型，在 JVM 上，Array 会被替换成 Java array。所以，事实上 Array 只是4.1 创建数组使用 arrayOf() 创建数组。12val array = arrayOf(1, 2, 3)val nullArray = arrayOfNulls(5) // Array with 5 null elements注意变量具有自动推断功能，类似 C++ 中的 auto也可以使用 Array() 创建数组。123// Crates an Array&lt;String&gt; with values// ["0", "1", "4", "9", "16"]val asc = Array(5, &#123;i -&gt; (i * i).toString()&#125;)Kotlin 内置了一些特定的数组类型，如 IntArray, ByteArray 等。1val x: IntArray = intArrayOf(1, 2, 3)4.2 访问数组Array 内置了 get() 和 set() 方法和 size 属性。但是也支持使用方括号进行访问的操作 []4.3 多维数组12val int2d: Array&lt;IntArray&gt;int2d = arrayOf(intArrayOf(1, 2, 3), intArrayOf(4, 5, 6), intArrayOf(7, 8, 9))5. 字符串使用 String 来表示字符串。与 Java 一样，字符串是一个不可变对象。5.1 相对 Java 增加的新特性与 Java 不同的是，Kotlin 支持使用方括号 [] 来获取字符串中的字符，同时也支持对字符串字符进行遍历。123for (c in str) &#123; println(c)&#125;5.2 raw string此外，Kotlin 还吸收了 Python 的多行字符串特性，使用三个双引号来表示一个 raw string，raw string 不接受转义，其中任何的字符都是字面字符。12345val rawString = """ This is a raw string. \n and \t will be displayed as its literal stirng."""5.3 字符串模板Kotlin 字符串具有模板功能，使用 $ 来指定参数例如：12val i = 10val s = "i = $i" // evaluates to "i = 10"也可以使用花括号 {} 来获取对象的属性填充到字符串中。例如：12val s = "abc"val str = "$s.lenth is $&#123;s.lenth&#125;" // evaluates to "abc.length is 3"需要注意的是，字符串的模板功能不仅可以在普通字符串中使用，同时也可以在 raw string 中使用。此时，如果需要表示 $ 美元符号，必须使用以下表达式：123var price = """$&#123;'$'&#125;9.99"""这里使用双引号${&quot;$&quot;}也是可以的，模板引用一个字面量时，结果就是它本身。]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin 接口]]></title>
    <url>%2FKotlin%2FKotlin%20%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[1. 基本形式Kotlin 的接口和 Java 8 中很相似。123456interface MyInterface &#123; fun bar() fun foo() &#123; // optional body &#125;&#125;2. 实现接口和类继承一样，使用同样的语法进行接口的实现12345class Child : MyInterface &#123; override fun bar() &#123; // body &#125;&#125;3. 声明属性在接口中可以声明属性。需要注意的是，接口中的属性不具备 backing field，所以不能进行初始化。接口中的属性可以是 abstract 的，或者提供一个自定义 getter。1234567891011121314interface MyInterface &#123; val property: Int // abstract val propertyWithImplementation: String get() = "foo" fun foo() &#123; print(property) &#125;&#125;class Child : MyInterface &#123; override val property: Int = 29&#125;4. 解决冲突和类继承一样，如果实现的多个接口方法出现冲突，就必须赋予 override 属性进行重载。1234567891011121314151617181920interface A &#123; fun foo() &#123; print("A") &#125; fun bar()&#125;interface B &#123; fun foo() &#123; print("B") &#125; fun bar() &#123; print("bar") &#125;&#125;class C : A &#123; override fun bar() &#123; print("bar") &#125;&#125;class D : A, B &#123; override fun foo() &#123; super&lt;A&gt;.foo() super&lt;B&gt;.foo() &#125;&#125;在这里，D 不需要 override bar()，这是因为 D 同时实现了 A，B，而 B 中对 bar() 方法进行了实现，同时 bar() 的实现中没有冲突。]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin 基础]]></title>
    <url>%2FKotlin%2FKotlin%20%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[1. 基本语法1.1 变量定义使用 val 定义常量（只读）1234val a: Int = 1val b = 1 // 类型可以被自动推断val c: Int // 如果没有进行变量初始化，则需要指定变量类型c = 1注意，kotlin 取消了分号使用 var 定义变量12var x = 5x += 11.2 注释与 Java 相同，单行注释使用 // ，多行注释使用 /* */不同的是，kotlin 中允许注释块嵌套。2. 编码规范2.1 命名风格命名风格和 Java 相同。类名采用大驼峰函数、方法、变量采用小驼峰使用 4 空格缩进公有方法和函数必须加上 KDoc2.2 关于冒号冒号在分隔两个类型的时候，前后都要有空格其余情况，只需后有空格即可。123interface Foo&lt;out T : Any&gt; : Bar &#123; fun foo(a: Int): T&#125;2.3 Lambda 表达式在使用 lambda 表达式时，lambda 表达式应与花括号有空格分隔。lambda 表达式应尽量的短。1list.filter &#123; it &gt; 10 &#125;.map &#123; element -&gt; element * 2 &#125;2.4 关于 Unit当一个函数返回 Unit 类型时，应将其省略。类似于 Java 中的返回值为 void3. 包和导入Kotlin 中的包和导入与 Java 区别不大。另外增加了 as 关键字用于赋予别名给类和函数，以防出现名称冲突。同时，Kotlin 中没有 Java 中的 import static 语句，所有的导入均使用 import 进行。]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin 空安全]]></title>
    <url>%2FKotlin%2FKotlin%20%E7%A9%BA%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[1. 概述Kotlin 对于 Java 的一个很大的改进在于，Kotlin 的类型系统目标在于要消除 NullPointerException或者 NPE。所以 Kotlin 提供了一个健壮的 Null 检查系统。2. 产生 NPE 的原因可能产生 NPE 的原因如下：显式调用 throw NullPointerException()使用 !! 操作符Java 代码造成的一些前后矛盾的初始化（在构造函数中没有初始化的 this 在其他地方使用）3. Kotlin 类型系统在 Kotlin 中，类型系统将变量引用分成了两种类型：可以为 null 的类型（nullable），和不能为 null 的类型（non-null）12var a: String = "abc"a = null // compilation error在类型后添加一个问号(?)来表明它是可以为空的。12var b: String? = "abc"b = null // ok此时，对于 a，由于它不会产生 NPE，你可以安全的访问它的成员。1val l = a.length但是对于 b，由于它可能为空，所以直接访问它，编译器会报错1val l = b.length // error: variable 'b' can be null但是我们依旧需要访问 b 啊！4. 访问可能为空变量的方法下面就介绍几种方法来进行 b 的安全访问。4.1 显式检查首先你可以直接对 b 进行空检查1val l = if (b != null) b.length else -1由于 Kotlin 具有智能造型特性，还可以直接在 if 语句中访问 b 的成员。1234if (b != null &amp;&amp; b.length &gt; 0) print("String of length $&#123;b.length&#125;")else print("Empty string")当然，这只适用于当 b 符合智能造型条件的情景，否则，b 有可能在检查之后再次变为空。4.2 使用安全访问第二个方法是采用安全访问操作符(?.)，即在点号(.)前加一个问号(?)1b?.length这个表达式当 b 不为空时返回 b.length；当 b 为空时，返回 null。表达式的返回结果是 Int?安全访问在链式操作中很有用。比如说，bob 是一个 Employee，他有可能被派往一个 Department，这个部门也许会存在一个主管。那么我们通过以下调用链来获取 bob 所在部门主管的名字。1bob?.department?.head?.name当调用链上的任何一个值为 null 时，表达式的返回值都为 null。如果你想对集合中的非空元素进行某种操作，可以结合安全访问和 let()1234val listWithNulls: List&lt;String?&gt; = listOf("A", null)for (item in listWithNulls) &#123; item?.let &#123; println(it) &#125; // prints A and ignores null&#125;let 操作接受一个 lambda 表达式，并返回 lambda 表达式的值。源代码4.3 Elvis 表达式如果对于一个引用 r，我们需要：当 r 不为空时，使用它；否则我们就使用一个其他的值(x)我们可以使用如下的语句：1val l: Int = if (b != null) b.length else -1一个更为简单的方法是使用 Elvis 表达式(?:)1val l = b?.length ?: -1如果在 ?: 的左边的值不为空，那么 Elvis 操作符就返回这个值，否则就返回右边的值。与 Java 中的条件操作符不同的是，只有当 ?: 的左边的值为空时，才会执行右边的语句；所以这个操作符不能像条件操作符一样执行一般的判断。想要实现条件操作符的功能，请使用单行的 if-else 表达式。4.4 !! 操作符第三个方法是给 NPE 爱好者们使用的，我们可以使用 b!!，使用它来进行调用，结果就会和 Java 一样，会抛出 NPE。1val l = b!!.length也就是说，如果你需要 NPE，就使用这个操作符。5. 安全的造型一般的造型 as 在对象不相符的时候，会产生一个 ClassCastException。一个更好的选择是使用 as?，一种更为安全的造型，当造型失败时，将会返回 null1val aInt: Int? = a as? Int // return null if failure6. 空类型的集合如果你拥有一个可空类型的集合，想要过滤出非空类型。只需要写如下语句：12val nullableList: List&lt;Int?&gt; = listOf(1, 2, null, 4)val intList: List&lt;Int&gt; = nullableList.filterNotNull() // non-null]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin 控制流程]]></title>
    <url>%2FKotlin%2FKotlin%20%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1. IfKotlin 中 if 语句是一个表达式，有返回值，功能和 C++ 和 Java 中的条件表达式相同。所以，Kotlin 中不支持条件表达式，因为 if 语句已经具备了这个功能。12345678910// Traditional usagevar max = a if (a &lt; b)max = b// With elsevar max: Int if (a &gt; b)max = aelsemax = b// As expressionval max = if (a &gt; b) a else b同时，if 表达式也支持语句块，语句块中的最后一个变量或常量的值就是语句块的返回值。12345val max = if (a &gt; b) &#123; print("Choose a") a&#125;else &#123; print("Choose b")b &#125;需要注意的是，如果 if 作为一个表达式（需要其返回值），那么 else 语句就必须存在。2. WhenKotlin 用 when 表达式替代了 Java 和 C++ 中的 switch 语句的功能。一个简单的 when 语句如下：1234567when (x) &#123;1 -&gt; print("x == 1")2 -&gt; print("x == 2")else -&gt; &#123; // Note the block print("x is neither 1 nor 2") &#125;&#125;与 if 语句一样，when 语句也可以作为表达式；当 when 作为表达式时，它的返回值是与其 case 相符的值。同样，when 作为表达式时，也可以使用块语句。与 Java 不同的是，when 语句可以对于一些不同的 case 进行一些相同的相应，而使用较少的代码量。1234when (x) &#123; 0, 1 -&gt; print("x == 0 or x == 1") else -&gt; print("otherwise")&#125;同时， when 语句的 case 可以使用随意的表达式，而不是 Java 中的仅能使用常量。1234when (x) &#123; parseInt(s) -&gt; print("s encodes x") else -&gt; print("s does not encode x")&#125;此外，也可以使用 in、!in、is、!is 进行范围和类型检测。123456when (x) &#123; in 1..10 -&gt; print("x is in the range") in validNumbers -&gt; print("x is valid") !in 10..20 -&gt; print("x is outside the range") else -&gt; print("none of the above")&#125;1234val hasPrefix = when(x) &#123; is String -&gt; x.startsWith("prefix") else -&gt; false&#125;Kotlin 在这里拥有一个非常好的特性叫 smart casts，当一个 is 表达式满足时，变量 x 将被自动 cast 到相应的类型，调用相应类型的方法。最后，when 也可以不接受参数使用，此时，when 的各个分支条件就变成了简单的布尔表达式，可以用于替代 if-else-if 结构。12345when &#123; x.isOdd() -&gt; print("x is odd") x.isEven() -&gt; print("x is even") else -&gt; print("x is funny")&#125;3. ForKotlin 中的 for 类似 Python 和 Java 中的 for-each 结构，使用 in 标识符来分隔 item 和 collection。123for (item in collection) [&#125; print(item)&#125;如果需要使用一个索引值，则可以使用 indices，它内置在 Kotlin 中的所有 collection 中。12for (i in array.indices) print(array[i]);同时也可以使用 withIndex() 方法。12for ((index, value) in array.withIndex()) print("$index, $value")4. While 和 do-while这两者和 Java 没有区别。5. 跳转Kotlin 支持三种形式的跳转：return：在最近的函数（包括匿名函数）返回break：跳出当前最近的循环continue：结束当前最近循环内工作，并从下一次最近循环开始与 Java 一样，Kotlin 也支持带标签的跳转，标签使用 @ 符号来指定。12345loop@ for (i in 1..100) &#123; for (j in 1..100) &#123; if (...) break@loop &#125;&#125;带标签的 break 用于跳出指定的循环结构，而带标签的 continue 则用于开始下一次指定的循环。6. 带标签的 return不仅如此，Kotlin 还支持带标签的 return，这主要是因为 Kotlin 允许函数的嵌套。一个比较普遍的使用场景是在 Lamda 表达式上。123456fun foo() &#123; ints.forEach &#123; if (it == 0) return print(it) &#125;&#125;类似如上的语句，return 的作用对象是其最近的函数，在这里是 foo()。但是如果我们要只从 Lambda 函数中返回(forEach)，则需要指定一个标签。123456fun foo() &#123; ints.forEach lit@ &#123; if (it == 0) re turn@lit print(it) &#125;&#125;一个更为常用的形式是直接使用 Lambda 表达式的名字。123456fun foo() &#123; ints.forEach &#123; if (it == 0) return@forEach print(it) &#125;&#125;另外的，我们也可以使用传统的匿名函数，来实现这个功能。123456fun foo() &#123; ints.forEach(fun(value: Int) &#123; if (value == 0) return print(value) &#125;)&#125;当需要返回某个值时，标签的解析具有更高优先权。例如：1return@a 1表示在 a 标签中返回 1，而不是返回 @a 1]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin Android Extension]]></title>
    <url>%2FKotlin%2FKotlin%20Android%20Extension%2F</url>
    <content type="text"><![CDATA[1. 概述Kotlin 对于 Android 开发，还提供了一些扩展特性，有助于提高 Android 开发的效率。2. findViewById任何一个 Android 开发者都会对这个方法非常熟悉，我们通过它来获取视图中组件的对象实例，随后进行操作。当然，一堆 findViewById() 势必降低了代码可读性，所以也出现了一些库（如 ButterKnife）用于简化这个方法的调用和造型，但由于它们都是运行期间的库，所以也就要求使用注解，这实际上并没有根本解决问题。Kotlin 则将简化一步到位，只需要 import 视图对应的包，你就可以简单轻松的获取到对象的实例。123456789101112// Using R.layout.activity_main from the main source setimport kotlinx.android.synthetic.main.activity_main.*class MyActivity : Activity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) textView.setText("Hello, world!") // Instead of findView(R.id.textView) as TextView // The name of instance is the name of its id &#125;&#125;3. 如何使用很简单，只需要在 app/build.gradle 文件添加上下面这一行即可：1apply plugin: 'kotlin-android-extensions'4. 使用场景配置好 Kotlin Android Extension 之后，就可以使用 import 语句来导入对应的 xml 视图组件了。1kotlinx.android.synthetic.main.activity_main.*这样你就能在 Activity 中直接通过 id 来使用这些组件了。假如你需要在 Fragment 中使用这些组件怎么办呢？Fragment 不像 Activity 拥有自带的 findViewById() 方法，它通常要使用一个 rootView 来进行组件获取。很简单，只需要在上面的基础上加一个 view 即可。1kotlinx.android.synthetic.main.activity_main.view.*这个功能也可以用在 Adapter 上；如果引入了这个语句，那么我们可以使用如下语法来进行组件获取和调用：123456&lt;TextView android:id="@+id/hello" android:layout_width="fill_parent" android:layout_height="wrap_content" android:text="Hello World, MyActivity" /&gt;1activity.hello.setText("Hi!")5. Android Flavors有些时候，我们的 APP 会被分成付费版和免费版；这个特性通常是通过在 build.gradle 划定 Android Flavors 来实现的。那么对于不同的 Flavor，我们需要不同的布局组件怎么办呢？很简单，只需要把上面的 main 改成相应的包名就行了；对于 free/res/layout/activity_free.xml，我们可以写如下语句1import kotlinx.android.synthetic.free.activity_free.*6. 实现原理通过扩展方法，来给每个类提供相应的扩展属性和扩展方法；然后通过不同的包来引入这些扩展。]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin 对象]]></title>
    <url>%2FKotlin%2FKotlin%20%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[1. 概述Kotlin 提供了一个 Object 属性用来实现在 Java 中很常见的三个功能：匿名类对象单例模式(Singleton)静态类成员它们分别被称为 对象表达式，对象声明，companion object2. 对象表达式Kotlin 使用 对象表达式 来实现 Java 中常用的匿名类对象功能。123456789window.addMouseListener(object : MouseAdapter() &#123; override fun mouseClicked(e: MouseEvent) &#123; // ... &#125; override fun mouseEntered(e: MouseEvent) &#123; // ... &#125;&#125;)如果类拥有一个构造器，那么就必须传入相应的参数123456789open class A(x: Int) &#123; public open val y: Int = x&#125;interface B &#123;...&#125;val ab: A = object : A(1), B &#123; override val y = 15&#125;当然，我们也可以只声明一个 object12345val adHoc = object &#123; var x: Int = 0 var y: Int = 0&#125;print(adHoc.x + adHoc.y)和 Java 的匿名类一样，对象表达式 也可以访问外部的变量，但和 Java 不同的是，变量并没有要求必须是 final123456789101112131415fun countClicks(window: JComponent) &#123; var clickCount = 0 var enterCount = 0 window.addMouseListener(object : MouseAdapter() &#123; override fun mouseClicked(e: MouseEvent) &#123; clickCount++ &#125; override fun mouseEntered(e: MouseEvent) &#123; enterCount++ &#125; &#125;) // ...&#125;3. 对象声明Kotlin 使用 对象声明 来实现 Java 中常用的单例模式12345678object DataProviderManager &#123; fun registerDataProvider(provider: DataProvider) &#123; // ... &#125; val allDataProviders: Collection&lt;DataProvider&gt; get() = // ...&#125;这虽然和 对象表达式 很相似，但是要注意的是 object 关键字后面跟一个名字后，我们不能再叫它表达式，也不能给他赋值，但是可以通过它的名字访问它。调用 object1DataProviderManager.registerDataProvider(...)对象声明 可以拥有超类。123456789object DefaultListener : MouseAdapter() &#123; override fun mouseClicked(e: MouseEvent) &#123; // ... &#125; override fun mouseEntered(e: MouseEvent) &#123; // ... &#125;&#125;同时， 对象声明 不能是局部变量，比如直接嵌套在一个方法里，但是可以嵌套在其他的对象声明或者非内部类里面。4. 伴生对象(companion object)这个在类的章节中也有所介绍，用于实现 Java 的静态成员功能。使用 companion 关键字来声明一个伴生对象12345class MyClass &#123; companion object Factory &#123; fun create(): MyClass = MyClass() &#125;&#125;伴生对象的成员可以直接使用其名字来调用1val instance = MyClass.create()我们也可以调用伴生对象本身，通过使用 Companion1val x = MyClass.Companion由于没有名字区分，一个类只能拥有一个伴生对象虽然说伴生对象看起来是静态的，但是在实际执行过程中，它依旧会实例化，所以它也可以拥有超类和重载方法。12345678910interface Factory&lt;T&gt; &#123; fun create(): T&#125;class MyClass &#123; companion object : Factory&lt;MyClass&gt; &#123; override fun create(): MyClass = MyClass() &#125;&#125;当然，你也可以让 JVM 将伴生对象真正的静态化，使用 @JvmStatic 注解即可。5. 对象表达式 和 对象声明 的不同点当 对象表达式 被声明时，它将会被立即执行。而 对象声明 会被延迟初始化，它将会在第一次调用它的时候进行初始化，而不是声明它的时候。伴生对象会在对应的类第一次被加载之后使用 java 的静态初始化器生成]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin 类属性和域]]></title>
    <url>%2FKotlin%2FKotlin%20%E7%B1%BB%E5%B1%9E%E6%80%A7%E5%92%8C%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[1. 声明和调用声明类中的属性和值很简单，类似 Java，使用 var 声明变量，使用 val 声明常量。1234567public class Address &#123; public var name: String = ... public var street: String = ... public var city: String = ... public var state: String? = ... public var zip: String = ...&#125;注意，变量默认为 public 属性。由于变量默认为 public，所以直接使用类成员运算符(.)，即可调用其属性和方法。1234567fun copyAddress(address: Address): Address &#123; val result = Address() // there's no 'new' keyword in Kotlin result.name = address.name // accessors are called result.street = address.street // ... return result&#125;需要说明的是，在编译时，系统会自动生成默认的 Getter 和 Setter。下面的写法123class Foo &#123; var bar: Int = 1;&#125;和以下 Java 代码是等同的。1234567891011class Foo &#123; private int bar = 1; public int getBar() &#123; return bar; &#125; public void setBar(int value) &#123; this.bar = value; &#125;&#125;同时，在访问和修改时，系统会调用变量的 getter 和 setter 来进行，而不是直接取值和改值。除此之外，Kotlin 的变量在使用前必须被初始化，否则编译器将报错。2. Getter 和 Setter定义一个类属性的完整语法如下：123var &lt;propertyName&gt;: &lt;PropertyType&gt; [= &lt;property_initializer&gt;] [&lt;getter&gt;] [&lt;setter&gt;]可以看到，初始化，Getter 和 Setter 都是可选项。需要注意的是，虽然在这里，初始化是可选项，但是这并不意味着变量不需要被初始化。实际上，Kotlin 中的变量在被使用前必须被初始化！特别的，一个类中的属性无论何时都要被初始化。这实际上是 Kotlin 的主旨之一，即，尽量使得过程显式化。12var allByDefault: Int? // error: explicit initializer required, default getter and setter impliedvar initialized = 1 // has type Int, default getter and setter2.1 改变 Getter 和 Setter 的可见性如果只需要改变可见性而不需要改变默认的 getter 和 setter，只需要在 get 或者 set 之前加上可见性修饰符即可，而不需要定义其主体。12345var setterVisibility: String = "abc" private set // the setter is private and has the default implementationvar setterWithAnnotation: Any? = null @Inject set // annotate the setter with Inject2.2 自定义 Getter 和 Setter自定义 getter 和 setter 很简单，只需要在变量下方使用 get 和 set 即可。12345var stringRepresentation: String get() = this.toString() set(value) &#123; setDataFromString(value) // parses the string and assigns values to other properties &#125;事实上， Kotlin 没有域这一属性，即不允许直接取值和赋值。但为了自定义 getter 和 setter，又必须提供一个直接的取值和赋值的途径，对此，Kotlin 采用了一个名为 backing field 的特性，即，只允许在 getter 和 setter 中使用 field 这一变量作为直接取值和赋值的途径。backing field 会在如下条件下生成：变量进行了初始化使用了 field 变量12345var counter = 0 // the initializer value is written directly to the backing field set(value) &#123; if (value &gt;= 0) field = value &#125;如果 backing field 不能满足需求，Kotlin 还提供了 backing property 特性。1234567private var _table: Map&lt;String, Int&gt;? = nullpublic val table: Map&lt;String, Int&gt; get() &#123; if (_table == null) _table = HashMap() // Type parameters are inferred return _table ?: throw AssertionError("Set to null by another thread") &#125;实际上就是使用另一个 private 变量来帮助实现自定义的 getter 和 setter。3. 编译时常量编译时常量指的是，在编译时就能确定的常量，也就是不需要依赖其他类的常量以Java为例， static final int a = 1 将是一个编译时常量，编译后的符号表中将找不到 a ，所有对 a的引用都被替换成了 1。而 static final int b = &quot;test&quot;.length() 将是一个运行时常量。Kotlin 中使用 const 标识符来指定编译时常量，JVM 将对这些变量进行优化，提高它们的运行速度。编译时常量必须满足如下条件：声明在 Top-level，或者是一个 object 的成员使用原始类型或者 String 进行初始化没有自定义的 getter编译时常量可以使用在注解中。123const val SUBSYSTEM_DEPRECATED: String = "This subsystem is deprecated"@Deprecated(SUBSYSTEM_DEPRECATED) fun foo() &#123; ... &#125;4. 延迟初始化一般来说，类中的属性必须被初始化，但是也有时需要通过注入或者 @SetUp 在 JUnit 中进行初始化。对此 Kotlin 提供一种特性称作延迟初始化，使用 lateinit 标识符可以指明一个变量需要延迟初始化。1234567891011public class MyTest &#123; lateinit var subject: TestSubject @SetUp fun setup() &#123; subject = TestSubject() &#125; @Test fun test() &#123; subject.method() // dereference directly &#125;&#125;延迟初始化只能应用在 var 中（而不能在 primary constructor 中）。延迟初始化的变量不能拥有自定义的 getter 和 setter，同时，它的类型也不能是原始类型。]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin 类基础]]></title>
    <url>%2FKotlin%2FKotlin%20%E7%B1%BB%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[1. 声明使用 class 来声明一个类。12class Invoice &#123;&#125;如果一个类是空的，那么大括号可以省略。1class Empty2. 创建Kotlin 类使用 constructor 来指定构建方法。2.1 primary constructor一个类必须拥有一个 primary constructor。primary constructor 是类头的一部分。12class Person constructor(name: String) &#123;&#125;如果一个 primary constructor 没有任何的可见性或者注解来修饰，则 constructor 可以省略。12class Person(name: String) &#123;&#125;一个 primary constructor 不能包含任何代码，对应的，使用 init 块来进行初始化构建。12345class Person(name: String) &#123; init &#123; logger.info("Person construction.") &#125;&#125;类头的参数可以在 init 块中使用，而且，也可以在声明类域时使用。123class Customer(name: String) &#123; val customerKey = name.toUpperCase()&#125;实际上，也可以直接在 primary constructor 中进行类域的初始化。123class Person(val firstName: String, val lastName: String, var age: Int) &#123;// ...&#125;通过添加 val 或者 var，primary constructor 中的参数就可以自动成为类的域。当如果 primary constructor 中存在可见性修饰符或者注解时，constructor 标识符必须存在。1class Customer public @Inject constructor(name: String) &#123; ... &#125;2.2 secondary constructor类也可以声明一个次要的构造器，相当于 Java 的重载构造函数。12345class Person &#123; constructor(parent: Person) &#123; parent.children.add(this) &#125;&#125;如果一个类拥有 primary constructor，则每一个 secondary 都需要包含 primary constructor 的参数。语法类似于 C++ 的 super 继承，使用 this，通过参数来表示不同的所继承的 constructor。123456789class Person(firstName: String) &#123; constructor(firstName: String,lastName: String) : this(firstName) &#123; &#125; constructor(firstName: String, lastName: String, middleName: String) : this(firstName, lastName) &#123; &#125;&#125;注意，不是每个 constructor 都要直接继承 primary constructor，只需要包含其参数即可。2.3 默认参数一个类的构造器可以拥有默认参数，默认参数使用 = 来指定。12class Customer(name: String = "") &#123;&#125;当 primary constructor 中的参数都有默认值后，编译器会自动生成一个没有参数的 constructor。3. 实例化将一个类实例化很简单，只需要像一个方法去调用即可。1val customer = Customer("hehe")注意，Kotlin 中没有 new 标识符。4. 继承任何的类都有一个默认的超类 Any，但 Any 不是 Java 中的 java.lang.Object。实际上，Any 只含有 Object 中的 equals() toString() hashCode() 方法。4.1 声明超类Kotlin 中使用冒号用于声明超类123open class Base(p: Int)class Derived(p: Int) : Base(p)如果子类拥有 primary constructor，那么超类就必须在 primary constructor 中立即进行实例化。所谓的立即实例化就是在冒号之后构建出基类的实例如果子类中没有 primary constructor，那么需要在其他 constructor 中使用 super 关键字进行基类构建。1234567class MyView : View &#123; constructor(ctx: Context) : super(ctx) &#123; &#125; constructor(ctx: Context, attrs: AttributeSet) : super(ctx, attrs) &#123; &#125;&#125;注意到，对于不同的 constructor，也可以使用不同的基类 constructor 进行构建。注意到，Kotlin 在基类前使用了 open 关键字，这是用来指明 Base 类是可以被继承的。默认情况下，Kotlin 中的类全部都是 final 类，不允许被继承。需要被继承的类使用 open 来指定。这主要基于 《Effective Java》中的第 17 条：设计并为你的继承写文档，否则就禁止它。4.2 Override 成员Kotlin 的一个主要原则是尽量将操作显式化。所以，如果一个成员是 override 基类成员而来的，则需要显式指明 override 。1234567open class Base &#123; open fun v() &#123;&#125; fun nv() &#123;&#125;&#125;class Derived() : Base() &#123; override fun v() &#123;&#125;&#125;注意，不仅类是 final 的，成员也是 final 的。被 override 成员在基类中的 open 和在子类中的 override 标识符缺一不可如果一个成员被指定了 override，那么它默认不再带有 final 属性。如果不允许再次 override，那么就需要给它指定 final123open class AnotherDerived() : Base() &#123; final override fun v() &#123;&#125;&#125;Override 一个变量和 override 方法一样，不过比较有趣的是，你可以在 primary constructor 中使用 override 关键字。1234567open class Foo &#123; open val x: Int get &#123; ... &#125;&#125;class Bar1(override val x: Int) : Foo() &#123;&#125;注意，可以将 val 常量使用 var 进行 override，但反之不行。这主要是因为 val 只拥有 getter，当使用 var 时，相当于给它赋上了 setter，但是反过来则不行了，val 不具备 setter。4.3 关于 override 的规则如果一个类继承了具有同一个域的不同基类和接口，那么，这个类就必须 override 这个域。域指的是变量、常量、方法等类成员1234567891011121314151617open class A &#123; open fun f() &#123; print("A") &#125; fun a() &#123; print("a") &#125;&#125;interface B &#123; fun f() &#123; print("B") &#125; // interface members are 'open' by default fun b() &#123; print("b") &#125;&#125;class C() : A(), B &#123; // The compiler requires f() to be overridden: override fun f() &#123; super&lt;A&gt;.f() // call to A.f() super&lt;B&gt;.f() // call to B.f() &#125;&#125;5. 抽象类一个声明了 abstract 的类是一个抽象类。一个抽象类，其本身和其所有的方法都必须声明 abstractabstract 类中不允许存在没有声明 abstract 的方法。声明了 abstract 的方法不能存在于没有声明 abstract 的类中。1234567open class Base &#123; open fun f() &#123;&#125;&#125;abstract class Derived : Base() &#123; override abstract fun f()&#125;6. 伴生对象(Companion Objects)Kotlin 不像 Java，没有静态成员对象。Kotlin 推荐使用包级别的函数来实现工具类。但是，缺少静态成员也有缺点，其一就是无法实现静态工厂。为了实现这一特性，Kotlin 通过所谓的伴生对象(Companion Objects)来实现。12345class MyClass &#123; companion object Factory &#123; fun create(): MyClass = MyClass() &#125;&#125;伴生对象是对象声明的一种，在另一篇文章会有所介绍。7. 封闭类(Sealed Class)封闭类(Sealed class)用来表示对类阶层的限制, 可以限定一个值只允许是某些指定的类型之一, 而不允许是其他类型. 感觉上, 封闭类是枚举类(enum class)的一种扩展: 枚举类的值也是有限的, 但每一个枚举值常数都只存在唯一的一个实例, 封闭类则不同, 它允许的子类类型是有限的, 但子类可以有多个实例, 每个实例都可以包含它自己的状态数据.要声明一个封闭类, 需要将 sealed 修饰符放在类名之前. 封闭类可以有子类, 但所有的子类声明都必须嵌套在封闭类的声明部分之内.12345sealed class Expr &#123; class Const(val number: Double) : Expr() class Sum(val e1: Expr, val e2: Expr) : Expr() object NotANumber : Expr()&#125;注：从封闭类的子类再继承的子类(间接继承者)可以放在任何地方, 不必在封闭类的声明部分之内.使用封闭类的主要好处在于, 当使用 when expression 时, 可以验证分支语句覆盖了所有的可能情况, 因此就不必通过 else 分支来处理例外情况.123456fun eval(expr: Expr): Double = when(expr) &#123; is Expr.Const -&gt; expr.number is Expr.Sum -&gt; eval(expr.e1) + eval(expr.e2) Expr.NotANumber -&gt; Double.NaN // 不需要 `else` 分支, 因为我们已经覆盖了所有的可能情况&#125;]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java to Kotlin]]></title>
    <url>%2FKotlin%2FJava%20to%20Kotlin%2F</url>
    <content type="text"><![CDATA[1. 概述下面总结一些代码段，用于帮助从 Java 迁移到 Kotlin2. Lazy Initialization123456789101112131415// Javaprivate A a = null;public A getA() &#123; if (a == null) &#123; a = initA(); &#125; return a;&#125;private A initA() &#123; // ...&#125;1234567// Kotlinval a: A by lazy &#123; initA() &#125;private fun initA(): A &#123; // ...&#125;3. App.getContext()12345678910111213141516// Javaclass App extends Application &#123; private Context context = null; @Override public void onCreate() &#123; super.onCreate(); context = getAppContext(); &#125; public Context getContext() &#123; retrun context; &#125;&#125;123456789101112// Kotlinclass App : Application() &#123; conpanion object &#123; lateinit var context: Context private set &#125; override fun onCreate() &#123; context = applicationContext &#125;&#125;或者也可以直接扩展 Context 类12val Context.myApp: MyApp get() = applicationContext as MyApp4. it in lambda当实现的接口是单方法接口时，Kotlin 会自动使用 lambda 来代替；这时候很容易出现不知道怎么写的问题。此时，放心大胆的用 it 这个内置的 lambda 表达式参数。12345678// Javabutton.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View view) &#123; // Perform action on click &#125;&#125;);12345// Kotlinbutton.setOnClickListener &#123; it -&gt; // it is a view // Perform action on click&#125;需要注意的是 lambda 是表达式，默认返回值为最后执行函数的返回值或者字面量；不需要 return 关键字。5. Functional Read From StdIn12345fun main(args: Array&lt;String&gt;) &#123; val reader = BufferedReader(InputStreamReader(System.`in`)) reader.lines().forEach(::println)&#125;]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 基础]]></title>
    <url>%2FJava%2FJava%20%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[1. 变量和数据类型boolean【Java】 = bool【C ++】所有的变量都要被初始化，最好在声明的时候就对其赋值1double n = 0.0; //Recommended使用 final 关键字指定常量Java 有 原始类型 和 引用类型原始类型保存的是值，而引用类型实际上是指向内存块的指针数组和对象名都是对于真正的数组或者对象的引用，而不是其自身【这里的“引用”类似于指针，而不是对象的别名】数组和对象都要使用new来声明构建，Java会自动进行垃圾处理，因而不需要显式delete数组的声明：int[] a = new int[100];类的构建：Class a = new Class(...);注意只有使用了 new 才会分配空间和构建对象，单纯的声明 int[] a类似于声明一个指向数组的指针Java对于大型数据类型只有通过 new 来构建，int a [100] 这种语法将不被接受，对于数组还可以使用列表初始化的语法int[] a = {1,2,3,4,6};Java允许数组长度为0 （注意这里和null并不同）2. 作用域Java不允许在嵌套的代码块内声明同名变量所以尽量保证变量的名称不重复【在同一个包(package)内】3. 控制流程for循环中，Java要求在三个部分对同一计数器变量进行初始化，检测和更新可以使用break label的形式来跳出多重嵌套循环123456789101112131415161718//例如label:for()&#123; for() &#123; for() &#123; if() &#123; break label; &#125; &#125; &#125;&#125;//break语句使得程序跳转到带标签的语句块末尾//即最外层的for循环的末尾for each循环，可以依此处理数组（或其他形式的集合）的每个元素，而不需要在意下标值12345678910111213 //语法 for(variable : colletion) &#123; //statement &#125; //依次打印数组内字符 a[] = new int [100]; .... for(int element : a) &#123; System.out.println(element);&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 多线程基础]]></title>
    <url>%2FJava%2FJava%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[1. 创建线程1.1 通过 Runnable 接口创建实现 Runnable 接口123class Myrunnable implement Runnable &#123;run();&#125;创建 Runnable 对象1Runnable r = new Myrunnable();由 Runnable 对象创建 Thread 对象1Thread t = new Thread(r);启动线程1t.start();不能直接调用 run() 方法，应调用 Thread.start() 方法来间接调用 run 方法1.2 通过继承 Thread 类实现实现继承类12345public class MyThread extends Thread &#123; public void run() &#123; // Do works &#125;&#125;构造类实例1234public void static main(Sting [] args) &#123; MyThread my = new MyThread(); Thread t = new Thread(my);&#125;通过 start() 方法开启线程1t.start();2. 中断线程Java 使用中断来执行终止线程的作用；但是，当一个线程接收到终止信号时，它可以选择对于中断信号的响应方式，这就带来了很好的扩展性。但同时也带来了一些疑惑的地方。2.1 中断置位和检测使用 Thread.currentThread() 方法获取到当前运行的线程关于 Thread.currentThread() 方法：此方法的官方解释是：Return the current executing Thread reference.所谓的当前线程指的是：运行当前代码段的线程，由于一段代码只能在一个线程中运行，如果使用多个线程同时执行同一段代码时，那么这个方法获取到的就是执行当前代码段的线程，叫做当前线程。注意，这个方法如果不在子线程中（即 run() 方法中），那么获取到的就一直是主线程（main）需要特别注意的是，不同线程不允许访问同一个变量，否则会引起竞争冒险使用 interrupt() 将中断布尔值置为 trueJava 的中断线程实际上是将线程内置的一个 boolean 值置为 true，以此来表示该线程已被中断。当我们需要中断一个线程时，就调用该方法将线程内部的中断布尔值置为 true。线程会在适当时候轮询这个布尔值，同时响应中断操作。注意这个动作是 Thread 官方类库中自带的。使用 isInterrupted() 来查询当前线程的中断布尔值一个好的 run() 方法应该包含对中断的检测，如果检测到中断，那么就应该进行响应。一般来说，应该放弃当前正在进行的工作，进行清理后将线程终止。但是如果需要在 run() 中执行 sleep() 方法，那么就没有必要检测中断状态，因为 sleep() 方法在被中断时，会抛出 InterruptedException，那么只需捕获这个异常进行处理即可。关于 interrupted() 和 isInterrupted()isInterrupted() 方法检测中断状态，但是不会影响中断状态的值。interrupted() 方法检测中断状态，同时将中断状态清除。需要注意的是，sleep() wait() 方法在抛出 InterruptedException 之后，都会将中断状态清除。对于这种状况，我们就需要对其进行一些处理。2.2 关于 InterruptedException 异常2.2.1 抛出时机当线程同时位于阻塞和中断状态时，抛出。即，当线程调用 sleep() wait() join() 等方法时被中断，那么抛出异常。一般来说，如果一个方法可以抛出 InterruptedException，那么说明这个方法的当前线程是可以被中断（取消）的。2.2.2 InterruptedException 的处理不捕捉该异常，改为向上层抛出。这在很多基础类库的方法中很常见，比如 sleep().通过将这个方法传送给更高级的调用者，让高层面的调用方法对其进行处理。123public void putTask(Task r) throws InterruptedException &#123; queue.put(r);&#125;执行清理后，将该异常抛出。这种逻辑常常在一些第三方的并发库中，为了避免由于异常导致的数据缺失，进行一些必要的清理、保存操作后，将异常传给调用者。12345678910111213141516171819public void matchPlayers() throws InterruptedException &#123; try &#123; Player playerOne, playerTwo; while (true) &#123; playerOne = playerTwo = null; // Wait for two players to arrive and start a new game playerOne = players.waitForPlayer(); // could throw IE playerTwo = players.waitForPlayer(); // could throw IE startNewGame(playerOne, playerTwo); &#125; &#125; catch (InterruptedException e) &#123; // If we got one player and were interrupted, put that player back if (playerOne != null) players.addFirst(playerOne); // Then propagate the exception throw e; &#125;&#125;捕捉中断后，重新将中断置位当不便抛出中断时，比如通过实现 Runnable 接口定义的任务。此时，就要重新将中断置位，以便高层代码能了解到中断的发生。1234567891011121314151617181920public class TaskRunner implements Runnable &#123; private BlockingQueue&lt;Task&gt; queue; public TaskRunner(BlockingQueue&lt;Task&gt; queue) &#123; this.queue = queue; &#125; public void run() &#123; try &#123; while (true) &#123; Task task = queue.take(10, TimeUnit.SECONDS); task.execute(); &#125; &#125; catch (InterruptedException e) &#123; // Restore the interrupted status Thread.currentThread().interrupt(); &#125; &#125;&#125;当且仅当已知线程即将退出时，才能生吞线程这种线程首先必须是由继承 Thread 实现的，而不是 Runnable 实现的，或者其他通用代码库中的方法。应在两处轮询中断状态，确保其一定会退出1234567891011121314151617181920public class PrimeProducer extends Thread &#123; private final BlockingQueue&lt;BigInteger&gt; queue; PrimeProducer(BlockingQueue&lt;BigInteger&gt; queue) &#123; this.queue = queue; &#125; public void run() &#123; try &#123; BigInteger p = BigInteger.ONE; // 两处轮询中断状态 while (!Thread.currentThread().isInterrupted()) queue.put(p = p.nextProbablePrime()); &#125; catch (InterruptedException consumed) &#123; /* Allow thread to exit */ &#125; &#125; public void cancel() &#123; interrupt(); &#125;&#125;3. 线程的生命周期新建当线程被 new 的时候可运行当调用 start() 方法后，进入可运行状态运行当线程经调度器获得资源时，进入运行状态阻塞状态当 sleep() wait() join() 方法调用，和等待锁或者等待 IO 输入 时，进入阻塞状态。注意，join() 方法会导致调用这个方法的线程阻塞，如果线程 t1 调用 t2.join()，那么 t1 将进入阻塞状态，直到 t2 执行完毕。使用 yeild() 方法不会使线程被阻塞，它只是让当前运行的线程放弃资源，重新进入可运行状态，接受调度器的重新调度。终止状态仅有两种情况会使得线程终止。一是 run() 方法执行完毕。一是由于未捕获的异常造成的线程终止。3.1 Java 如何终止一个线程对于会引起 InterruptedException 的方法对于这种方法，直接对 InterruptedException 进行捕获即可。注意如果产生异常的方法在一个循环之中，那么就要 break 出来。注意要将中断状态再次置位，否则如果在一个嵌套循环里面发生中断的话，那么将得不到正确处理。对于不会引起 InterruptedException 的方法对于这种方法，我们可以通过在执行真正的工作前，先轮询中断状态的布尔变量。如果中断状态已经被置位了，那么就执行退出。但是这样会造成一定程度的延时性，所以最好还是通过异常进行处理。例如：1234567891011public void run() &#123; try &#123; while(!Thread.currentThread().isInterrupted()) &#123; // ... &#125; &#125; catch (InterruptedException consumed) &#123; /* Allow thread to exit */ &#125;&#125;public void cancel() &#123; interrupt(); &#125;对于被 IO 阻塞的方法对于这种方法，当中断发生时，它会产生 InterruptedIOException。通过类似捕获 InterruptedException 的方法来捕获 InterruptedIOException。但是要注意，由于中断的发生，我们需要同时关闭这个线程所占有的 IO 流，此时，我们要重载 interrupt() 方法，使其能够关闭 IO 流，同时引起 IOException 的发生。所以对于 IOException，我们就需要判断是否是由于中断引起的 IOException123456789101112131415161718192021222324252627282930313233343536 import java.io.IOException; import java.io.InputStream; import java.io.InterruptedIOException; public class BlockedOnIO extends Thread &#123; private final InputStream in; public BlockedOnIO(InputStream in) &#123; this.in = in; &#125; @Override public void interrupt() &#123; super.interrupt(); try &#123; in.close(); &#125; catch (IOException e) &#123;&#125; // quietly close &#125; public void run() &#123; try &#123; System.out.println("Reading from input stream"); in.read(); System.out.println("Finished reading"); &#125; catch (InterruptedIOException e) &#123; Thread.currentThread().interrupt(); System.out.println("Interrupted via InterruptedIOException"); &#125; catch (IOException e) &#123; if (!isInterrupted()) &#123; e.printStackTrace(); &#125; else &#123; System.out.println("Interrupted"); &#125; &#125; System.out.println("Shutting down thread"); &#125;&#125;4. 线程属性4.1 优先级系统会优先调用高优先级的线程线程优先级高度依赖系统实现，由系统线程优先级映射到 Java 虚拟机上4.2 守护线程守护线程用于给其他线程提供服务，例如发送定时信号等。守护线程由于很容易中断，不应访问固有资源（例如文件、数据库等）setDaemon() 方法必须在线程开始前调用当程序中只存在守护线程时，JVM 退出，守护线程一并终止典型应用：GC（垃圾回收），保持长连接等。4.3 uncaughtExceptionHandler线程的 run() 方法不能抛出任何被检测的异常未捕获的异常会被 uncaughtExceptionHandler 捕获可以使用特定的方法设置处理器，如果未设置，则为空任何线程默认情况同属于一个线程组线程组（ThreadGroup）默认实现了一个处理器，其对应方法按照如下逻辑进行工作如果有父线程组，那么就采用父线程组的处理器否则，如果 getDefaultExceptionHandler() 方法部位空，那么则调用该处理器。否则，如果线程已经死亡，则什么都不做否则，将线程的名字和对应的栈轨迹输出到 System.err 上。这也是我们通常见到的情景。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 多线程工具]]></title>
    <url>%2FJava%2FJava%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[1. 并发工具对于很多的多线程问题，我们不需要再去实现一遍底层的锁和同步机制了。对于一般的应用向问题，应优先采用并发工具Executor 和 Task 优先于线程(Runnable)并发工具优先于 wait() 和 notify()—— Effective Java Second Edition1.1 阻塞队列对于许多线程问题，可以通过使用一个或者多个队列来将其形式化。可以通过 Producesor 将任务加入队列，然后由 Comsumor 来将任务取出然后进行处理的方式来实现。Java 的阻塞队列自带了阻塞特性，不再需要显式的同步1.1.1 API这里只介绍阻塞队列的阻塞方法，实际上阻塞队列也包含一些非阻塞的方法方法正常动作特殊情况下的动作put添加一个元素如果队列满，则阻塞take移出并返回头元素如果队列空，则阻塞offer添加一个元素，并返回 true如果队列满，则返回 falsepoll移出并返回队列的头元素如果队列空，则返回 nullpeek返回队列的头元素（不移出）如果队列空，则返回 null注意：offer 、peek、poll 在特殊情况下并不阻塞，但是它们有对应的超时版本由于 peak poll 带有 返回 null 的属性，所以不能往这样的队列插入 null 值这个队列还具有 add() 和 remove 方法，但是它们在特殊情况下会抛出异常，所以在多线程程序中不要使用这样的方法。Java 准备了多种实现形式的阻塞队列，包括链表、双端链表、数组等实现，甚至包括优先队列。同时，Java 1.7 还提供了 TransferQueue 接口，这个接口允许生产者线程等待，直到消费者线程准备就绪。1.1.2 例子下面是一个使用阻塞队列来管理多线程关系的例子：即，生产者线程将元素加入到队列中，消费者线程将元素取出进行处理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public class BlockingQueueExample &#123; public static void main(String[] args) throws Exception &#123; BlockingQueue bq = new ArrayBlockingQueue(1000); Producer producer = new Producer(bq); Consumer consumer = new Consumer(bq); new Thread(producer).start(); new Thread(consumer).start(); Thread.sleep(4000); &#125;&#125;/*** Producer generate the sum.* And add it into the queue*/public class Producer implements Runnable &#123; private BlockingQueue bq = null; public Producer(BlockingQueue queue) &#123; this.setBlockingQueue(queue); &#125; // The blocking queue has a internal synchronize // The delay of each end of the addition will show this public void run() &#123; Random rand = new Random(); int res = 0; try &#123; res = Addition(rand.nextInt(100), rand.nextInt(50)); System.out.println("Produced: " + res); bq.put(res); Thread.sleep(1000); res = Addition(rand.nextInt(100), rand.nextInt(50)); System.out.println("Produced: " + res); bq.put(res); Thread.sleep(1000); res = Addition(rand.nextInt(100), rand.nextInt(50)); System.out.println("Produced: " + res); bq.put(res); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public void setBlockingQueue(BlockingQueue bq) &#123; this.bq = bq; &#125; public int Addition(int x, int y) &#123; int result = 0; result = x + y; return result; &#125;&#125;/*** Comsumer take the result from the queue.* And print it out to the output*/public class Consumer implements Runnable &#123; protected BlockingQueue queue = null; public Consumer(BlockingQueue queue) &#123; this.queue = queue; &#125; public void run() &#123; try &#123; System.out.println("Consumed: " + queue.take()); System.out.println("Consumed: " + queue.take()); System.out.println("Consumed: " + queue.take()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;The output:123456Produced: 93Consumed: 93Produced: 69Consumed: 69Produced: 76Consumed: 761.2 线程安全的集合在 java.util.concurrent 包提供了许多线程安全的集合。主要用于多线程并发修改一个数据结构的并发问题。包括 哈希表、有序集和队列等一般来说，线程安全的集合要比一般的集合更高效在较早的 Java 版本，曾有“同步包装器”使得一般的集合类型变为同步的，但是现在已经不推荐使用了，最好使用 java.util.concurrent 包中的集合2. Callable 和 Future2.1 CallableCallable 是一个带返回值的 Runnable，具有泛型特性。例如 Callable&lt;Integer&gt; 表示一个最终返回 Interger 的异步计算2.2 FutureFuture 保存异步任务的结果，可以将其启动然后交给一个线程。所有者在任务执行完毕后，可以通过 get() 方法获得结果。Future 具有以下方法1234567public interface Future&lt;V&gt; &#123; V get() throws ...; V get(long timeout, TimeUnit unit) throws ...; void cancel(boolean mayInterrupt); boolean isCancelled(); boolean isDone();&#125;第一个 get() 调用直到计算完成前会被阻塞；如果任务完成前第二个 get() 超时，则抛出 TimeoutException如果线程被中断，则都抛出 InterruptedException如果任务已经完成，那么 get() 立即返回可以使用 cancel() 方法来中断任务，如果任务没有开始，则它将被取消而不会再运行，如果任务已经在运行，那么则由 mayInterrupt 参数来决定是否中断任务如果任务已经被取消或者已经完成，那么返回 false，其他情况返回 true注意，此方法一旦返回，则 isDone() 永远返回 true2.3 FutureTaskJava 实现了 FutureTask 包装器，它是一个类，同时实现了 Runnable 和 Future 接口它接受一个 Callable 接口作为构建器参数，主要用于将 Callable 转换为 Runnalbe 和 Future可以如下使用123456Callable&lt;Integer&gt; myComputation = ...;FutureTask&lt;Integer&gt; task = new FutureTask&lt;Integer&gt;(myComputation);Thread t = new Thread(task) // It's a Runnalet.start();...Integer result = task.get(); // It's a Future3. 执行器(Executor)如果你需要做一些重复性较高的异步任务，或者创建大量的生命期很短的线程，那么就应该用线程池来管理。实际上，为了提高效率，执行任何的并发任务，都应该优先考虑 Execulator 和 TaskExeculator 和 Task 优先于线程(Thread)—— Effective Java Second Edition在这里，并发的最小单位升级为 Executor 和 Task。所谓的 Task 就是用户构建的 Runnable 或者 Callable 对象；这也是为什么要优先采用 Runnable 的原因3.1 基本使用基本的使用步骤如下：使用 Executors 的静态方法构建线程池，或者叫 ExecutorService调用 execute() 或 submit() 提交 Runnable 或 Callable 对象当不在提交任务时，调用 shutdown()注意，还有一个 execute() 方法执行 submit() 的效果。它们的主要区别在于，execute() 会触发未捕获处理器，从而向 System.err 输出错误信息;submit() 会抛出 ExecutionException，可以使用 getCause() 获取出错信息另外， submit() 返回的是 Future 对象，可以通过它取消特定任务。由此，如果使用 Callable 那么使用 submit()；如果使用 Runnable 那么使用 execute()例子：123456789ExecutorService executorService = Executors.newFixedThreadPool(10);executorService.execute(new Runnable() &#123; public void run() &#123; System.out.println("Asynchronous task"); &#125;&#125;);executorService.shutdown();3.2 ScheduledExecutorService 预定执行该类是 ExecutorService 的子类，用于构建预订性和重复性、周期性 的任务可以指定任务只运行一次，也可以指定任务的运行周期3.3 控制任务组使用 ExecutorService 的另一个重要原因就是可以实现控制一组相关任务。特别是在采用分治策略的算法中常常能用到。例如，使用对一个大整数进行因式分解，那么我们可以将整个过程分成很多很小的过程，当小任务全部解决完毕时，整数的因式分解也就完毕了。或者，我们可以用它来提交很多对于同一个问题的不同解决方案，如果有任何一个解决方案得出答案，那整个任务就可以停止了。对于以上两种情况，使用 ExecutorService 分别有两种方法进行对应：invokeAll()，这个方法提交所有的 Callable 到一个集合中，并返回一个 Future 对象，代表所有任务解决结果invokeAny()，这个方法提交所有的 Callable 到一个集合中，并返回一个 Future 对象，代表某一个任务的解决结果例子：123456// invokeAll -- Return a List of FutureList&lt;Callable&lt;T&gt;&gt; task = ...;List&lt;Future&lt;T&gt;&gt; results = executor.invokeAll(task);// invokeAny -- Return only one FutureFuture&lt;T&gt; resultOfInvokeAny = executor.invokeAny(task);可以使用 ExecutorCompletionService 来对 invokeAll() 得到的结果集进行排列处理12345678910// executor is a ExecutorServiceExecutorCompletionService service = new ExecutroCompletionService(executor);for (Callable&lt;T&gt; task : tasks) &#123; service.submit(task);&#125;for (int i = 0; i &lt; tasks.size(); i++) &#123; processFurther(service.take().get());&#125;3.4 Fork-Join 框架对于多线程处理的分治策略的任务， Java 实现了一种 Fork-Join 框架来更好的实现这种任务流程。分治的很常见的实现方式是递归实现，这个框架也使用了递归的思路使用步骤：提供一个扩展了 RecursiveTask&lt;T&gt; 或者 RecursiveAction 的类Override compute() 方法，在其中调用子任务并将其合并例子：123456789101112131415161718class Counter extends RecursiveTask&lt;Integer&gt; &#123; ... @Override protected Integer computer() &#123; if (to - from &lt; THRESHOLD) &#123; // solve problem directly &#125; else &#123; int mid = from + (to - from) / 2; // Recursive solve left Counter first = new Counter(values, form, mid, filter); // Recursive solve right Counter second = new Counter(values, mid, to, filter); invokeAll(first, second); // Add both to executor return first.join() + second.join(); // bind the solution &#125; &#125;&#125;4. 同步器(Synchronizer)同步器是并发工具的一种，一些使线程能够等待另一个线程的对象，允许它们协调动作。同步器类作用何时使用CyclicBarrier (不常用)允许线程集等待直到其中预定数目的线程到达一个公共障栅(barrier)，然后可以选择执行一个处理 barrier 的动作当大量的线程需要在它们的结果可用之前完成时CountDownLatch (常用)允许线程集等待直到计数器为 0当线程需要等待事件发生（才允许执行时）Exchanger（不常用）允许两个线程在要交换的对象准备好时交换对象当两个线程工作在同一个数据结构的两个实例上时Semaphore（常用）允许线程集等待知道它被允许继续执行为止限制访问资源的线程总数SynchronousQueue允许一个线程将对象交给另一个线程在没有显式同步的情况下，当两个线程准备好将一个对象传递到另一个时注意 CountDownLatch，这个类用于让某些线程等待其他线程。它是唯一一个带有 int 构造参数的同步器，用于指定等待的并发线程的个数形象来说，就是一个红绿灯，直到倒计时完毕，线程才可以运行下面是一个简单的多线程计时的例子1234567891011121314151617181920212223242526272829303132333435363738/*** A simple timing concurrent execution.* The timer will not start until all the worker thread are ready.* And when the last worker thread done, the timer stop*/public static long time(Executor executor, int concurrency, final Runnalbe action) throws InterruptedException &#123; final CountDownLatch ready = new CounDownLatch(concurrency); final CountDownLatch start = new CounDownLatch(1); final CountDownLatch done = new CounDownLatch(concurrency); for (int i = 0; i &lt; concurrency; i++) &#123; executor.execute(new Runnable() &#123; // This is the worker thread public void run() &#123; ready.countDown(); // Tell the timer worker is ready try &#123; start.await(); // Worker stuck at start point // Because of blocking, // this statement will not run // until the start count down reach 0 action.run(); &#125; catch (InterruptedException) &#123; Thread.currentThread().interrupt(); &#125; finally &#123; done.countDown(); // Tell the timer worker is done &#125; &#125; &#125;); &#125; // This is the timer thread ready.await(); // Wait for all the workers are done long startNanos = System.nanoTime(); start.countDown(); // Let worker thread off!! done.await(); // Wait for worker done. return System.nanoTime() - startNanos;&#125;在线程中调用锁存器的 await() 方法可以阻塞当前线程当锁存器的计数器为 0 时，所有的被该锁存器阻塞的线程即刻执行锁存器是共享的，在任何线程中都可被更改一旦归 0，障碍即刻被放弃]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 异常]]></title>
    <url>%2FJava%2FJava%20%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[1. 异常分类※具体的结构层次如图ThrowableError※Java运行时系统的内部错误和资源耗尽错误，应用程序不该抛出这类异常;该异常出现时，只能终止程序ExceptionIOException 及其他※包含试图在文件尾部后面读取数据（IO）试图打开一个不存在的文件（IO）试图根据给定的字符串查找Class，而这个类并不存在Runtime Exception※包含错误的类型转换数组访问越界访问空指针注意要点如果出现 RuntimeException，那么就一定是你的问题，需要从程序设计方面进行改进所有派生于 Error 和 RuntimeException 的异常称为未检查异常注意 IOException 并不包含用户输入的部分，此类通过一般检查可以避免的异常不应作为异常抛出并处理，应该由流程控制语句（if else while continue）处理2. 声明异常类似于C++98的异常规范在方法的首部声明1public FileInputStream(String name) throws FileNotFoundException声明多个时 ，使用逗号隔开必须声明所有可能抛出的已检查异常如果未声明，则表明方法不会抛出（已检查）异常不必声明未检查异常子类方法的声明异常不能比超类方法更为通用即子类声明的异常层次不能高于超类方法超类没有声明异常时，子类也不能声明异常3.抛出异常使用 throw 关键字表明抛出异常注意与声明异常的关键字（throws）区分开只能抛出 Throwable 子类的对象而 C++ 能抛出任何类型的值抛出异常与捕获异常不同，如果没有异常处理器（try catch）捕获异常，则程序将会终止自定义异常通常包含一个默认构造器和一个带有详细描述信息的构造器必须派生于 Exception 及其子类4.捕获异常4.1 使用try/catch语句块来捕获异常如果调用一个抛出已检查异常的方法，则必须对其处理（try/catch），或继续将其传递（throws）一个catch语句里面可以捕获多个异常类型，使用 | 间隔开此时，异常变量为 final可以在 catch 语句中再次抛出异常与 C++ 不同的是，不能只写 throw 关键字，而需要将整个抛出异常都写上4.2 finally 子句123456789101112try&#123; ...&#125;catch(...)&#123; ...&#125;finally&#123; ...&#125;4.2.1 概述不管是否有异常被捕获，finally 子句都将被执行抛出异常并被捕获时，先执行 catch 语句，后执行 finally 语句抛出异常未被捕获时，先执行 finally 语句，后将异常返回给调用者try 可以只有 finally，而没有catch当finally语句抛出异常时，会覆盖掉原有异常（此时建议使用带资源的try语句）※如果此异常必须返回给调用者的话，则需要进行一些处理才能返回给调用者※如果原异常具有异常处理器（被捕获）则不需要这种解决办法常规解决办法12345678910111213141516171819202122232425InputStream in = ....;Excepiton ex = null;try&#123; try &#123; ... &#125; catch(Exception e) &#123; ex = e; throw e; //这里重新抛出了e，为的就是将这个异常返回给调用者 &#125;&#125;finally&#123; try &#123; in.close(); &#125; catch(Exception e) //在这里捕获（抑制）了close方法的异常， &#123; if(ex == null) throw e; &#125;&#125;4.2.2 带资源的try语句只要需要关闭资源，就要尽可能使用带资源的try语句资源必须属于一个实现了AutoCloseable的类，否则应使用常规方法1234try(Resource res = ...)&#123; ....&#125;资源：特指文件和输入输出流等，和申请的内存无关当 try 块退出时，将会自动调用 res.close()可以指定多个资源当出现异常时，close 异常会被自动捕获（抑制），原有异常将会重新抛出close 的异常将会被增加到原有异常中，可以使用 getSuppressed 方法获取到被抑制的异常列表此 try 块也可以有 catch 和 finally 子句，会在关闭资源之后执行5. 使用异常的技巧5.1 异常处理不能代替简单的测试异常处理会比简单的测试花费更多的时间应该仅在异常状况下使用异常机制资源的IO错误，设备错误，物理限制等等而对于用户的输入错误，应该使用流程控制来进行处理5.2 不要过分细化异常应该将整个任务包装在一个try语句内5.3 利用异常层次结构※应该尽量的抛出更为恰当的子类，而不是仅仅抛出较为高层次的异常类对象※捕获时同理5.4 应该关闭不重要的异常※在方法多重调用时使用5.5 早抛出，晚捕获6. 断言断言就是增加一个编译检查项，如果结果与断言不符，那么就抛出异常]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 接口和内部类]]></title>
    <url>%2FJava%2FJava%20%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[1. 接口这是 Java 中的专有名词，指代的是 interface 关键字1.1 接口1public interface Comparable &#123;...&#125;接口不是类，而是对类的一组需求描述接口中的所有方法自动为public实现接口将类声明为实现给定的接口1class Employee implements Comparable &#123;....&#125;对接口中的所有方法进行定义接口实现必须声明为public特性不是类，不能使用new来实例化不能包含实例域和静态方法可以包含常量，接口中的域被自动设为public static final可以声明接口的变量1Comparable x;必须引用实现了接口的类对象1x = new Employee();可以使用instanceof来检查一个对象是否实现了某个特定接口1if(anObject instanceof Comparable)可以扩展（继承）1public interface Powered extends Moveable每个类只能拥有一个超类，但是可以实现多个接口123class Employee extends Persons implements Comparable &#123; ...&#125;1.2 对象克隆默认克隆（Object.clone()）浅拷贝protected方法实现克隆必须实现 Cloneable 接口使用 public 重新定义 clone() 方法即使浅拷贝能满足要求，也要进行上述两条操作需要声明 CloneNotSupportedException 异常2. 内部类1234567class TalkingClock&#123; public class TimePrinter implements ActionListenner &#123; ... &#125;&#125;2.1 概述在类的内部直接定义，类似于C++的嵌套类可以访问作用域内的数据，包括私有的可以隐藏内部类可以便捷实现回调2.2 普通内部类可以访问外围类对象数据（包括私有的）通过 OuterClass.this 访问外围类在外围类的作用域之外，使用 OuterClass.InnerClass 引用内部类2.3 局部内部类简称局部类，在一个方法内进行定义1234567public void start()&#123; class TinmePrinter implements ActionListenner &#123; ... &#125;&#125;局部类可以访问局部变量（必须声明为 final）更新封闭作用域内的计数器时，使用 final 的长度为 1 的数组2.4 匿名内部类12345new SuperType(cosntruction parameters) &#123; ... &#125;// 如果只创建局部类的一个对象的时候才使用SuperType可以是类或者接口如果用于实现接口时，不能有任何构造参数1234new InterfaceType() &#123; ... &#125;2.5 静态内部类用于将一个类隐藏在另一个类之中，通常用于防止名称的冲突只有内部类可以声明为 static特别的，通过静态方法构造的内部类必须声明为 static]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 多线程同步]]></title>
    <url>%2FJava%2FJava%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[1. 概述由于每句代码只能在一个线程中执行，当多个线程试图访问同一个对象域时，就会出现竞争，导致对象的数据最终出现错误。特别是当线程中的操作不是原子操作的时候，当线程切换的时候。为了消除竞争的危害，对于多个线程有可能同时操作同一个对象的情况，我们就要实现线程同步实现线程同步的方法主要有三种：使用 Lock/Condition 即显式的锁使用 synchronized 关键字使用并发库和阻塞类来实现线程管理Executor 和 Task 优先于线程并发工具优先于 wait() 和 notify()—— Effective Java Second Edition注意，线程同步不仅要求互斥性，也要求可见性，即只有一个线程能对同步代码块进行操作，同时，该代码块对所有线程应是可见的2. 使用 ReentrantLock 实现同步2.1 锁的初级使用ReentrantLock 是一个锁对象，在有可能出现竞争的方法中使用锁，就可以保护一段代码块同一时间只能由一个线程进行读写操作例如：1234567891011121314public class Bank &#123; private ReentrantLock myLock; public void transfer() &#123; myLock.lock(); // ----------- 临界区 try &#123; // some works &#125; finally &#123; myLock.unlock(); &#125; // ---------- 临界区 &#125;&#125;在临界区之间的代码是受锁对象保护的，当其他线程试图执行临界区代码（试图获取锁）时，就会导致线程阻塞，直到当前执行的线程解开锁为止。注意要将解锁代码放置在 finally 中，否则可能会由于异常的抛出而无法解锁。此时，不能使用带资源的try块。因为要在 finally 中释放锁，而释放锁的方法不是 close()锁是可重入的，锁对象自身维护一个持有计数，如果在临界区中调用了另一个被锁保护的方法，那么，计数器增加，解锁后，计数器减少，直到持有计数为 0 时，线程才会释放锁。当由于异常而跳出临界区时，应进行相应的清理操作，保证对象的完整性。因为在 finally 中，锁会被释放。2.2 公平锁使用 ReentrantLock(boolean fair) 可以指定构造一个公平锁。它倾向于让阻塞队列中等待时间最长的线程获取到锁，但是额外的检测成本可能会造成性能损失。2.3 条件对象条件对象 Condition 用于确保临界区中的代码符合执行条件。2.3.1 使用条件对象的原因不能使用一般的 if 语句进行检查因为 if 是非原子性的，线程可能在通过检查之后被剥夺，再次进入时却又不满足执行条件。12345// DON'T DO THAT!!if (bank.getBalance(form) &gt;= amount) &#123; // transfer() was protected by Lock object. bank.transfer(from, to, amount)&#125;不能在临界区内检查条件有可能在条件不满足的情况下，需要其他线程的协助才能满足条件。例如，当前线程操作的账户对象不满足转出余额，那么就需要等待另一线程向当前账户注资。此时，由于当前线程占有锁，其他线程无法操作这一账户。2.3.2 使用条件对象通过锁对象的 newCondition() 来获得一个条件对象。当条件不满足时， 调用条件对象的 await() 方法该方法会使当前线程阻塞，加入条件对象等待队列，并放弃锁当条件有可能满足时，调用条件对象的 singalAll() 方法这一方法会激活所有的等待该条件对象的线程，并尝试重新获取锁，从被阻塞的地方继续执行此时，线程应再次测试条件，因为此时无法确保条件是否被满足。之所以不能确保，是因为线程在 await() 之后，不具备将自己唤醒的能力，必须由另一线程执行 singalAll() 方法。如果没有一个线程能够调用 singnal，那么此时系统就死锁了。所以就应在对象的状态有利于等待线程的改变时调用 singalAll() 方法。另外，也有一个 singal() 方法，这个方法会随机选择一个等待线程进行唤醒。综上，以下是使用条件对象的基本框架：123456789101112131415161718192021222324252627282930313233class Bank &#123; private Condition sufficientFunds; private ReentrantLock bankLock; .... public Bank() &#123; ... // Using the Lock object to // get the condition object reference sufficientFunds = bankLock.newCondition(); &#125; ... public void transfer(int from, int to, int amount) &#123; // Lock the code bankLock.lock(); try &#123; while(accounts[from] &lt; amount) &#123; // Don't have sufficient funds, await sufficientFunds.await(); &#125; // Have sufficient funds // Transfer funds.. ... // Transfer complete, singnal all sufficientFund.singnalAll(); &#125; finally &#123; // Unlock the code bankLock.unlock(); &#125; &#125;&#125;3. synchronized 关键字3.1 内部锁这里比 8.5.1 更 “高级” 和傻瓜性了；其实从 jdk 1.0 开始，任何 Java 对象都拥有一个内部锁；我们不需要再显式实现一个锁和条件对象的架构了。如果一个方法用 synchronized 声明，那么对象的锁将保护整个方法;也就是说：123456789101112131415// Both of these method is equivalentpublic synchronized void method() &#123; // method body&#125;public void method() &#123; this.intrinsicLock.lock(); try &#123; // method body &#125; finally &#123; this.intrinsicLock.unlock(); &#125;&#125;3.2 唯一的条件对象对象的内部锁拥有唯一一个条件对象；通过 wait() 方法将线程添加到条件的等待队列；通过 notifyAll() notify() 方法解除等待线程的阻塞也就是说：12wait(); == intrinsicCondition.await();notify()All == intrinsicCondition.singnalAll();3.3 例子使用 synchronized 重写的 Bank 类123456789101112131415161718192021class Bank &#123; private double[] accounts; public synchronized void transfer(int form, int to, int amount) throws InterruptedException &#123; while (accounts[from] &lt; amount) &#123; // Do not have suffient funds // Using wait() method instead of await() wait(); &#125; // Do have suffient funds // Transfering.. accounts[from] -= amount; accounts[to] += amount; // Transfer done // Using notifyAll() method instead of singnalAll() notifyAll(); &#125; public synchronized double getTotalBalance() &#123;...&#125;&#125;3.4 局限性可以看到，使用 synchronized 关键字大大减少了代码量，使代码更为整洁；但是对应的，也存在一些缺点：不能中断一个正在试图获得锁的进程因为锁在对象内部，开发者无法操作，2 同试图获得锁时，不能设定超时每个锁仅有单一的条件，可能是不够的3.5 总结那么，究竟是使用 synchronized 关键字还是 Lock/Condition 机制呢？最好两者都不使用，使用 Java 自带或一些第三方的并发工具来处理同步问题。Effective Java 中提到 “并发工具优先” 的概念，即，成套的并发库和并发工具，要优先于使用 wait(), notify() 方法如果不想采用并发库，并且 synchronized 的缺点并没有对程序造成影响，那么尽量使用它这样可以减少编写的代码，减少出错的几率如果特别需要 Lock/Condition 的独有特性时，那么才使用 Lock/Condition比如说即时中断，特定的等待超时等。4. 同步阻塞同步阻塞允许客户使用123synchronized(lock) &#123; // method body&#125;获取到内部的锁这也叫做客户端锁定，这个方法是很脆弱的，通常不推荐使用5. 监视器监视器是 Per Brinch Hansen 提出的面向对象的线程安全实现方式。使用 Java 语言来表述就是：监视器是只包含私有域的类每个监视器类的对象有一个相关的锁使用该锁对所有的方法进行加锁该锁可以有任意多个相关条件Java 的 synchronized 关键字使用一种不严谨的方法实现了监视器但是这也导致了 Per Brinch Hansen 本人的批评6. Volatile 域volatile 可以被看做是一种 程度较轻的 synchronized;它只具有 synchronized 提供的可见性，而不具备原子性同时， volatile 变量不会造成阻塞这说明了，当我们需要同步的写入操作时，volatile 就不适用了；但是如果该变量仅用于读取，那么 volatile 能提供优于 synchronized 的性能。6.1 正确使用 volatile 变量的条件对该变量的写操作不依赖于当前值比如说，用 volatile 变量做计数器是不行的，因为计数器的增加要先读取当前值该变量没有包含在具有其他变量的不变式中大多数的编程情形都会和这两个条件的其中之一冲突，使得 volatile 不能如 synchronized 一样普遍实现线程安全6.2 性能考虑一般情况下， volatile 的性能要比使用 synchronized 要高；所以在符合使用 volatile 的情形下应该尽量使用。6.3 正确使用的情形状态标志这是 volatile 的最常使用情形，作为一个布尔状态标志，用于指示发生了一个重要的一次性事件，或监视线程状态（是否被终止）1234567891011volatile boolean shutdownRequested;...public void shutdown() &#123; shutdownRequested = true; &#125;public void doWork() &#123; while (!shutdownRequested) &#123; // do stuff &#125;&#125;此时，很可能需要从外部（另一线程）调用 shutdown() 方法，那么就需要保证 shutdownRequested 的可见性。此时，显然使用 volatile 关键字会更好一次性安全发布当缺乏同步可见性时，可能会出现一个线程获取到了一个不完全构建的对象，从而出现更新值和旧值同时存在。此时，可以将该对象的引用定义为 volatile 类型，然后在使用前通过检查该引用就可以知道对象是否安全发布了。12345678910111213141516171819public class BackgroundFloobleLoader &#123; public volatile Flooble theFlooble; public void initInBackground() &#123; // do lots of stuff theFlooble = new Flooble(); // this is the only write to theFlooble &#125;&#125;public class SomeOtherClass &#123; public void doWork() &#123; while (true) &#123; // do some stuff... // use the Flooble, but only if it is ready if (floobleLoader.theFlooble != null) doSomething(floobleLoader.theFlooble); &#125; &#125;&#125;注意使用的条件在于，该对象一经发布就不可修改，或者是线程安全对象如果需要对该对象进行异步更改，那么就需要 synchronized 等进行额外的同步操作。独立观察volatile 变量可以定期的发布一些观察结果供程序内部使用，或者收集必要的统计信息1234567891011121314// Record the last login user's accountpublic class UserManager &#123; public volatile String lastUser; public boolean authenticate(String user, String password) &#123; boolean valid = passwordIsValid(user, password); if (valid) &#123; User u = new User(); activeUsers.add(u); lastUser = user; &#125; return valid; &#125;&#125;这个模式和上述的模式稍有不同，使用该值的代码需要清除该值可能会随时变化。volatile bean 模式这是 Java Bean 模式的一种。它要求，所有的数据成员都是 volatile 的，同时， getter &amp; setter 必须非常简单，不包含其他复杂代码该模式为一些易变数据提供了容器，但是要求放入这些容器的对象必须是线程安全的12345678910111213141516171819202122 @ThreadSafe public class Person &#123; private volatile String firstName; private volatile String lastName; private volatile int age; public String getFirstName() &#123; return firstName; &#125; public String getLastName() &#123; return lastName; &#125; public int getAge() &#123; return age; &#125; public void setFirstName(String firstName) &#123; this.firstName = firstName; &#125; public void setLastName(String lastName) &#123; this.lastName = lastName; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125;高级应用——开销较低的读——写锁策略当对于一个变量的读操作远远超过写操作时，我们就可以使用 volatile 关键字修饰该变量，用于保证可见性，同时对 setter 方法采取 synchronized 修饰保证同步性，实现较低开销的读和写锁123456789101112@ThreadSafepublic class CheesyCounter &#123; // Employs the cheap read-write lock trick // All mutative operations MUST be done with the 'this' lock held @GuardedBy("this") private volatile int value; public int getValue() &#123; return value; &#125; public synchronized int increment() &#123; return value++; &#125;&#125;7. final 变量如果一个域被声明为 final，那么对于该变量将不会出现线程安全问题。其他线程将在 final 变量被赋值成功后才能见到此变量。注意，只有变量是线程安全的，其指向的数组、对象等仍然需要同步操作。8. 死锁Java 并不能在语言层次上避免或打破死锁的发生，这是程序设计的工作。9. 线程局部变量如果要避免线程间共享变量，那么可以使用 ThreadLocal 辅助类为各个线程提供各自的实例。例如，如果要让每个线程都拥有自己的 SimpleDateFormat 变量，那么只需要123456public static final ThreadLocal&lt;SimpleDateFormat&gt; dateFormat = new ThreadLocal&lt;SimpleDateFormat&gt;() &#123; protected SimpleDateFormat initalValue() &#123; return new SimpleDateFormat("yyyy-MM-dd"); &#125; &#125;;如果要访问具体线程的格式化方法，可以调用1String dateStamp = dateFormat.get().format(new Date());在一个给定线程中首次调用 get() 方法时，会调用 initialValue() 方法。在此之后， get() 会返回属于当前线程的那个实例$\Delta$ 对于随机数生成器，如果需要线程独享的随机数生成器，那么可以使用1int random = ThreadLocalRandom.current().nextInt(upperBound);current() 会返回特定于当前线程的 Random 类实例。另外还有个 set() 和 remove() 方法，分别用于为当前线程设置新值和删除当前线程的值。10. 锁测试与超时如果要使用这一特性，就要使用 Lock/Condition 架构。由于尝试获取锁会导致阻塞，使用 tryLock 可以试图申请一个锁，成功则返回 true, 失败返回 false，同时，线程可以立即离开做其他事情12345678910if (myLock.tryLock()) &#123; // now the thread owns the lock try &#123;...&#125; finally &#123; myLock.unlock(); &#125;&#125;else &#123; // Do something else&#125;同时，还可以设置超时参数1if (myLock.tryLock(100, TimeUnit.MILLSECONDS));注意， tryLock() 会忽略锁的公平性lock() 方法不能被中断，如果一个线程在等待获取锁时被中断，那么就有可能会造成死锁但是，如果采用 tryLock()，如果线程在等待期间被中断，将抛出 InterruptedException ，此时就可以用这个特性来跳出死锁问题。同时，await() 方法也可以设定超时。11. 读/写锁如果很多线程从一个数据结构读取数据而很少修改其中数据的话，那么我们使用另一种锁 ReentrantReadWriteLock 来提高性能此时，允许读线程共享访问，写线程为互斥访问这里有点像 volatile 的高级应用；不同的点在于，volatile 用于一个变量，而 ReentrantReadWriteLock 用于一个数据结构11.1 使用步骤构建 ReentrantReadWriteLock 对象1private ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();抽取读锁和写锁12private Lock readLock = rwl.readLock();private Lock writeLock = rwl.writeLock();1对所有的 getter 加读锁1234567public double getTotalBalance() &#123; readLock.lock(); try &#123;...&#125; finally &#123; readLock.unlock(); &#125;&#125;对所有 setter 加写锁1234567public void transfer(...) &#123; writeLock.lock(); try &#123;...&#125; finally &#123; writeLock.unlock(); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 泛型通配符和类型限定]]></title>
    <url>%2FJava%2FJava%20%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6%E5%92%8C%E7%B1%BB%E5%9E%8B%E9%99%90%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[1. 概述对于泛型系统而言，最重要的就是能够领过的使用；所以，Java 增加了 类型通配符(?)；使用 ? 来表示 任何类型；例如：1Pair&lt;? extends Employee&gt;表示 任何 是 Empolyee 的子类；2. 与类型参数 T 的不同类型参数 T 和 通配符 ? 似乎都是用于实现泛型灵活性的工具；但是，实际上它们有着很大的不同2.1 使用位置不同在泛型中，类型参数 T 是一个 确定的 类型，通常用于泛型类和泛型方法的 定义，不能用于调用代码。12public static &lt;T extends Number&gt; voidcopy(List&lt;T&gt; dest, List&lt;T&gt; src)而通配符是一个 不确定 的类型，通常用于泛型方法的 调用代码 和形参，不能用于定义类和泛型方法1Pair&lt;? Empolyee&gt; wildcardBuddies = managerBuddies;2.2 类型参数保证形参一致性基于 T 是一个确定的类型，那么就可以通过 T 来 确保 泛型参数的一致性；例如上面的 copy() 方法，使用泛型参数 T 就 确保了 两个 List 的元素类型是 一致的；但是，如果使用如下的代码：12public static voidcopy(List&lt;? extends Number&gt; dest, List&lt;? extends Number&gt; src)由于通配符是 不确定的，所以这个方法不能保证两个 List 具有相同的元素类型2.3 类型参数可以多重限定而通配符不行类型参数 T 可以进行多重限定，如：1T extends A &amp; B &amp; C但是通配符不能进行多重限定，因为它不是一个确定的类型。2.4 通配符可以使用超类限定而类型参数不行类型参数 T 只具有 一种 类型限定方式：1T extends A但是通配符 ? 可以进行 两种限定：12? extends A? super A3. 通配符类型限定和继承对于泛型来说，即使它的类型参数具有继承关系，泛型类之间也是 没有 任何关联的；但是，通过通配符的限定，就让泛型类之间具有了公有的父类；例如：Pair&lt;? extends Empolyee&gt; 是 Pair&lt;Manager&gt; 和 Pair&lt;Empolyee&gt; 的 公共超类；事实上， Pair&lt;? extends Empolyee&gt; 是 Pair&lt;Empolyee&gt; 和所有以 Empolyee 子类 为类型参数的泛型类的超类。对于超类型限定，同理；1? super Empolyee表示类型参数可能是 Empolyee 的 某个超类；和子类型限定同理，超类型限定也可以为泛型类建立联系：如上，Pair&lt;? super Manager&gt; 是 Pair&lt;Empolyee&gt; 和 Pair&lt;Object&gt; 的共同超类。需要注意的是，在 Pair&lt;? super Manager&gt; 之上，还有一个 无限定通配符，指代任何的类型。4. PECS 原则PECS 原则，指的就是 Producer Extends Consumer Super意思就是，对于生产者，采用 ? extends；对于消费者，采用 ? super；对于既可能是生产者有可能是消费者的对象，则 不做类型限定。首先说明所谓的生产者和消费者的主语都是 数据结构；例如：1List&lt;? extends Number&gt; producer;那么，List 就是 生产者，提供数据，调用 get() 方法，外部使用者提取其内部数据。反过来，对于1List&lt;? super Number&gt; consumer;那么此时，List 就是 消费者，接收数据，调用 add() 方法，外部使用者将数据注入结构中。实际上，这个原则是为了能够在泛型中提供尽可能的类型安全的写法。4.1 生产者的读方法1List&lt;? extends Number&gt; numbers;这个就是很典型的生产者；由于使用了上界限定，那么它 保证 其中的元素 一定 是 Number；所以它可以调用 get() 方法；4.2 生产者的写方法但是此时，生产者不可以使用写方法；这是因为 ? extends Number 只是限定了上界；换句话说也就是 Number 的某个 子类型；由于不知道具体是 哪个 子类型，所以，也就无法对其进行写入。那么是否可以写入 Number 对象呢？很可惜，这也是不可以的，因为 Number 是上界，很可能由于多态的原因变成了它的某个子类；所以对于 ? extends 来说，禁止所有的写入操作。4.3 消费者的读方法根据原则，具有下面类型的是消费者：1List&lt;? super Number&gt; numbers;对于消费者来说，它接受的是 Number 的某个超类型；那么，由于不清楚是 哪个 超类型；所以，实际上返回的是最终的 Object 对象；这显然对于读取没有什么帮助，如果读到一个 Object 类型，用户还需要将其转化为对应的子类型；这显然是多此一举的。注意，消费者 并非是禁止 读操作的访问4.4 消费者的写操作那么对于写操作如何呢？1List&lt;? super Integer&gt; numbers = new ArrayList&lt;Integer&gt;;此时，对于 numbers 来说，可以使用 add() 方法加入 Integer；但是，能否加入 Number 元素呢？(Number 是 Integer 的超类)；很遗憾，这是 不行的！；numbers 目前只能写入 Integer 及其子类；因为 Integer 的子类也是 Integer ，数据结构将子类当成 Integer 来处理实际上，你 无法加入任何的超类！如果允许加入 Number 甚至是 Object，那会造成什么结果呢？就是一个 Integer 的列表中混入了 Object；显然这是不合理的。那么为什么有必要使用 ? super 这种多此一举的声明呢？从超类限定的关系图中我们可以看出，它在泛型类关系中，处于 超类 的地位；所以，我们就可以通过它所提供的 多态，来将我们目前存储的数据，加入到一个 更抽象通用的 数据结构中。例如：123456789101112131415161718public static void count(Collection&lt;? super Integer&gt; ints, int n)&#123; for (int i = 0; i &lt; n; i++) ints.add(i);&#125;public static void main(String[] args) &#123; List&lt;Integer&gt;ints = new ArrayList&lt;&gt;(); count(ints, 5); assert ints.toString().equals("[0, 1, 2, 3, 4]"); List&lt;Number&gt;nums = new ArrayList&lt;&gt;(); count(nums, 5); nums.add(5.0); assert nums.toString().equals("[0, 1, 2, 3, 4, 5.0]"); List&lt;Object&gt;objs = new ArrayList&lt;&gt;(); count(objs, 5); objs.add("five"); assert objs.toString().equals("[0, 1, 2, 3, 4, five]");&#125;虽然我们的 count() 方法 只能 提供 Integer 数据；但是，由于使用了 &lt;? super Integer&gt;，所以我们的数据可以被放入到 List&lt;Number&gt; 和 List&lt;Object&gt; 中。由 ? super 提供的 多态支持，正是我们采用 Consumer Super 的关键。4.5 不做限定当一个类既可能是生产者，又可能是消费者时；就不对它的类型作出限定。注意这里所说的 不是 无限定的通配符，而是指的是普通的类型参数形式(T)。1public class Stack&lt;T&gt;&#123;&#125;5. 无限定通配符有时候我们会使用无限定的通配符。例如：1Pair&lt;?&gt;此时，它的 get() 返回值类型只能是 Object；同时， 不能 调用 set()，即使通过 Object 也不能调用。那么这时有什么用处呢？我们可以用它实现一些与类型 无关 的操作；如123public static boolean hasNulls(Pair&lt;?&gt; piar) &#123; return p.getFirst() == null || p.getSecond() == null;&#125;因为 hasNulls() 方法不需要关心类型是什么；这个时候我们就可以使用无限定的通配符。6. 通配符捕获有时候，当我们需要实现一个无限定通配符方法的时候；有可能遇到需要使用类型参数的问题。例如：1public static void swap(Pair&lt;?&gt; pair)但是，由于 ? 不是类型参数，所以我们需要使用一个辅助方法来实现。12345public static &lt;T&gt; void swapHelper(Pair&lt;T&gt; pair) &#123; T t = pair.getFirst(); pair.setFirst(p.getSecond()); pair.setSecond(t);&#125;那么我们就可以通过下面的方法实现 swap() 方法：123public static void swap(Pair&lt;?&gt; pair) &#123; swapHelper(pair);&#125;但是，对于这个例子来说，实现一个辅助方法的确是多此一举；我们本来就可以通过辅助方法直接实现需求；那么为什么需要这个技巧呢？在使用了通配符的时候，不可避免的需要使用到这个技巧：123456public static voidmaxminBonus(Manager[] a, Pair&lt;? super Manager&gt; result)&#123; minmaxBonus(a, result); PairAlg.swap(result);&#125;由于使用了通配符，那么这个捕获技巧就不可避免的需要了。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 语言和本地化]]></title>
    <url>%2FAndroid%2FAndroid%20%E8%AF%AD%E8%A8%80%E5%92%8C%E6%9C%AC%E5%9C%B0%E5%8C%96%2F</url>
    <content type="text"><![CDATA[1. 概述虽然 Android 已经内置了 string.xml 来进行本地化和国际化的功能；但是，由于在 7.0 以前，string.xml 的 fallback 存在较大问题；所以，即使拥有了一个 i18n 的机制，也还是需要谨慎规划 Locale 的 fallback 问题。本文就来提出一些最佳实践。2. 默认 string.xml 设置为英语英语作为世界使用范围最广的语言，是名副其实的通用语。当应用没有为地区提供本地化内容时，系统就会自动 fallback 到默认的 string.xml；只要有些文化的人就能看懂大部分的英语；所以，string.xml 设置为英语是最为妥当的。3. 地区语言-默认覆盖范围最广的语种对于地区语言，则应该使用覆盖范围最广的语种作为此 Language 的默认本地化内容。例如，对于中文地区(zh)，香港、澳门、台湾采用繁体中文，中国和新加坡采用简体中文；那么，就应该采用覆盖范围最广的 繁体中文 作为地区默认语言；而 单独 给 中国和新加坡 设置简体中文内容。整体设置如下：123res/value-zh: 繁体中文res/value-zh-rCN: 简体中文res/value-zh-rSG: 简体中文原因自然是 Android 的 Buggy 语言 fallback 机制；在 7.0 以前，如果用户语言区域和内置的本地化内容匹配失败；那么就会直接 fallback 到 默认配置(/res/value/string.xml)；如果我们上面只提供 zh-rCN 的话，那么港澳台地区的同胞就只能看英语界面了。7.0 以后，Android 修复了这一问题；API 24 之后可以匹配到和语言最为接近的本地化内容；例如上面的例子，在没有繁体的应用，在 7.0 上，港澳台地区就可以看到简体中文。但是由于 7.0 目前使用人数过于低下，还是得进行上面所讲的 workaround4. Android Studio 设置语言地区虽然目前 Android Studio 中内置了 Translation Editor；但是，目前这个好用的工具还不能实现对语言地区(region) 的设定。例如，对于中文，有简体中文(zh-CN) 和 繁体中文(zh-{HK, TW})；但是， Translation Editor 目前并不能指定语言的 Region；只能选择默认的 value-zh。对于这种情况，我们不得不暂时抛弃这个好用的工具；自行在 Project Window (就是最左边的窗口):New -&gt; Value Resource -&gt; Choose Locale -&gt; Select Region；例如选择 zh，然后地区选择 CN，创建 strings.xml；此时，Android Studio 就创建了 value-zh-rCN/strings.xml；然后，我们把默认的 string.xml 复制到 string.xml(zh-rCN) 中；这样，我们就能够在 Translation Editor 中编辑简体中文了。5. 获取当前使用的语言一般来说，这个需求可以通过直接取 Preference 的值来实现；但是，对于应用第一次安装时，则不能通过直接取 Preference；因为应用可能会在多个国家和地区使用，在提供了本地化资源的情况下，Android 会自动匹配到这些本地化资源；那么，我们如何能确保设置里面的语言和应用第一次启动时默认显示的语言是一致的呢？首先，不能通过 Configuration 取到的 Locale 来实现；应用可以通过 Resource.getConfiguration() 来获取到 Configuration；在这里就可以查看和修改应用的各项设置，包括 Locale原因有两个：不适用于多地区，少语言的情况例如大陆和新加坡使用简体中文，港澳台使用繁体中文；使用 getDisplayLanguageTag() 则会得到 『中文（香港）』、『中文（台湾）』之类的内容；但是，我们只需要提供 两门语言选项 就足够了getDisplayLanguageTag() 在 API 24 (6.0) 以上才被引入，不能兼容老版本真正的做法，是在每个本地化资源 strings.xml 里面，写上该资源的 locale_code，如：123456&lt;!-- filename: value-zh-rCN/strings.xml --&gt;&lt;resource&gt; &lt;string name="locale_code"&gt;zh-CN&lt;/string&gt; &lt;!-- 剩下的资源 --&gt;&lt;/resource&gt;通过利用 Android 自身的适配机制，获取到 真正显示的 语言类型。1String localeCode = getString(R.string.locale_code);也就是说，locale_code 实际上就 对应了 语言类型；这样，我们只要在 zh-HK 和 zh-TW 都写入同一个 locale-code；然后通过 locale-code 来进行设置页面的语言类型显示；这样就实现了显示语言和设置中的语言的同步。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 类基础]]></title>
    <url>%2FJava%2FJava%20%E7%B1%BB%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[1. 概述△Java语言就是基于类的语言，许多术语与C++稍有区别C++Java函数方法构造函数构造器析构函数析构器类中的数据实例域静态数据静态域例如 String a;C++ 称 String 为类，而 a 为对象，C++ 在此时就分配了内存，构建了对象Java 称 String 为类，a 为引用，而当使用 new 请求，分配了空间，构建出的数据块称为对象类对象必须使用new来构建，单纯的声明类仅仅只是声明了类的引用，并没有分配空间2. 自定义类一个源文件只能拥有一个 public 类，且必须与文件名一致通过在类的 class 前缀上 public 获得这一特性包含 main() 方法的类才能成为启动类，每个类都可以拥有 main()方法通常用作类的普通测试Java不支持析构函数，反之，会自动进行垃圾回收所有的方法都要在类的内部进行定义实际上，任何一个Java程序都是从类开始的如果需要返回一个可变对象的引用，应该对其进行克隆（clone）※这是由于变量都是一个指向对象的“类似指针的”引用，有可能会使得数据封装性遭到破坏final 修饰符在使用时大多应用于不可修改的类，当应用在可变的类的时候，并不意味着类的内容不可修改1234567891011class Employee&#123; private final String name; private final Date hiredate: 2017-03-16&#125;/*** 此时，name引用和对象都不能被修改【String类是不可变的类】* hiredate: 2017-03-16* 这里的hiredate: 2017-03-16*/通过 static 声明静态域和静态方法静态域和 C++ 类中的静态变量没有什么区别静态公有常量可以通过类名来直接调用，由于有 final 限制，所以不会造成封装性破坏如Math.PI就是一个静态公有变量其实也可以通过对象引用来调用，不过一般通过类名调用使得易读性更强静态方法可以通过类名和对象引用直接调用，但一般使用类名调用增强易读性如 Math.pow(x,y)静态方法只能对对象静态域实施操作，而不能对实例域实施操作通常只有在接受外来参数和调用静态域的时候才使用静态方法对象的构造可以直接在构造器内初始化实例域，即使是包含关系通过使用this来实现传参和实例域同名，甚至调用另一个构造器1234567891011public Class(String name, double salary)&#123; this.name = name; this.salary = salary;&#125;public Class(double s)&#123; this("Class * " + nextId, s); nextId++;&#125;默认将所有数值初始化为0，布尔值初始化为false，引用初始化为null如果没有提供显式构造器，则系统自动生成隐式（无参）构造器完成上述工作如果提供了显式构造器，则系统将不再自动生成无参构造器，上述操作将被视为非法初始化块※这个不常用，通常使用构造器完成工作可以使用一个代码块对实例域进行初始化操作12345678910class Class&#123; private int id; .... &#123; id = 1; &#125;&#125;初始化块在所有构造器执行之前执行。通过标记关键字static可以对静态域进行初始化块操作1234static&#123; id = 1;&#125;类的基本结构数据域构造器（constructor）访问器（getter）更改器（setter）3. 方法参数Java总是按值传参，对象引用也是一个值方法不能修改传递给它的实参方法可以通过调用传入对象引用的对象的方法，实现对对象的修改方法不能让对象参数引用一个新的对象方法能够直接访问和修改相同类作为参数的对象实例的私有域1234567class Foo &#123; private String text; public void doStuff(Foo f) &#123; System.out.println(f.text); &#125;&#125;4. 包（package）※类似于C++的名称空间通过import语句来导入Java包添加static指令可以直接导入静态方法和静态域，使用的时候就无需使用类名来调用【UnRecommended】通过使用包名来具体访问一个类通过package语句来将类放入包中，通常在开头加入1package com.myapp.corejava;注意包名的命名要与目录树相匹配，即上述类文件必须位于 com/myapp/corejava 中，否则，最终的程序将无法运行包作用域如果实例域没有指定访问控制符，则这一个部分可以被同一个包的所有方法访问在编写类的时候，必须为实例域添加上访问控制符类路径（※好像只有使用Shell编译才会遇到这个问题？）javadoc文档注释以 /** 开头，以 */ 结尾可以使用 HTML 修饰符还有各种注释，这里不一一说明5. 类设计技巧保证数据私有一定要对数据初始化，可以直接提供默认值，也可以在构造器中提供不要在类中使用过多的基本类型，可以通过一个封装类来减少使用123private String street;private String city;private String state;这个可以通过一个 Address 类来解决并不是所有的数据都需要访问器和更改器将职责过多的类进行分解如果一个类能被拆分成两个或者多个独立的概念，那就进行拆分注意这里是概念的拆分，而不是单纯将方法拆分类名和方法名要能够体现它们的职责类名常用一个名词或者有定语修饰的名词访问器使用小写的get开头更改器使用小写的set开头]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 类继承]]></title>
    <url>%2FJava%2FJava%20%E7%B1%BB%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[1. 概述C++Java基类父类、超类派生类子类2. Java 只允许一重继承※可以有多个继承链，但是不能有多个基类3. 使用 extends 来表明继承关系1234class Derived extends Base&#123; ....&#125;;4. 使用 super 来调用超类方法12345class Derived extends Base &#123; public Derived() &#123; super(); &#125;&#125;5. 构造器可以使用 super 实现对超类构造器的调用如果没有显式调用超类构造器，将自动调用超类构造器的隐式版本;如果没有隐式版本（即超类构造器只定义了显示版本）则报错6. 多态可以将超类引用指向子类对象，但不能反过来基类指针可以指向派生类对象数组可以进行相反的赋值，所以必须注意元素类型的监督public 方法默认为动态绑定，无需添加 vitual 或者类似的关键字private、static、final方法为静态绑定子类方法覆盖超类方法时，其访问权限不能严格于超类方法※注意不要遗漏public关键字，否则将会被解释成为更严格的访问权限覆盖允许返回类型协变（超类可以协变为子类）7. final 阻止继承final 类123final class Excutive extends Manager &#123; ...&#125;这种类型被称为final类，不允许定义子类，即无法继承final 方法1public final String getName() &#123;...&#125;这种方法称为final方法，这种方法不允许子类覆盖它，确保其不会在子类中改变语义注意 final 的位置不同值得提到的是， Effective Java 中明确指示，如果不事先设计好一个良好的继承结构模型，那么就 禁止继承8. 强制类型转换在继承链上不允许进行由上到下的转换（超类不能转换成子类）使用 instanceof 进行转换检查，返回布尔值，表示是否能够成功转换语法：(要转换的对象) instanceof (转换目标)强制转换语法类似 C 语言，执行过程类似 dynamic_cast 操作，不成功则抛出一个异常，而不是生成 null 对象9. 抽象类12abstract class Person &#123;...&#125; // 抽象类public abstract String getDescription(); // 抽象方法抽象类不一定要有抽象方法，但是包含抽象方法的类必须声明为抽象类抽象类可以包含具体数据和具体方法抽象类不能被实例化（即不能创建对象）10. 谨慎的使用protectedprotected 的可见性是超类和子类之间11. Object类11.1 equals()方法特性自反：x.equals(x) return true对称：y.equals(x) = x.equals(y)传递：if (x.equals(y) &amp;&amp; y.equals(z)) then x.equals(z);一致：The return value of x.equals(y) should be stable;对于非空引用 x, x.equals(null) return false;Object 类 equals：判断两个对象是否具有相同的引用11.2 equals() 方法的设计理念接受一个Object类参数（为了覆盖Object类的equals方法）检测是否为自身this == otherObject检测传参是否为null比较是否为同一个类如果子类有特有的equals概念，则使用getClass方法if(getClass() != otherObject.getClass()) return false;如果子类没有特有的equals概念，则使用instanceof方法if(!(otherObject instanceof ClassName)) return false;转换为相应的类变量由于接受的是一个Object变量，所以必须进行强制类型转换才能进行具体实例域的相等判定此时已经判别类型相同了，可以进行转换判别实例域如果在子类中重新定义equals，则先调用超类的equals11.2 hashCode() 方法如果重新定义了 equals() 方法，则必须重新定义 hashCode() 方法equals() 与 hashCode() 的定义必须一致；如果 x.equals(y) return true, 则，x.hashCode() 就必须与 y.hashCode() 返回一样的值11.3 toString() 方法一般形式：类名 + 方括号括起来的阈值调用 x.toString() 可以用 &quot;&quot;+x 代替应该为每一个自定义类提供 toString() 方法。12. 泛型数组列表（ArrayList&lt;&gt;）构造1ArrayList&lt;ClassName&gt; staff = new ArrayList&lt;&gt;();优点：可以实现动态更改数组大小使用 add() 方法添加元素，remove() 方法删除元素使用 get() 方法访问元素，set() 方法设置元素【而不是使用[]语法】13. 对象包装器和自动装箱一般用于将基本类型转换成类对象首字母大写即为相应的包装器包装器的比较应使用 equals()方法，而不是 ==包装器为 final 类，不可以用来修改基本数据类型的数值应使用 holder 类型来修改基本数据类型的值14. 不定参数1public static double max(double... values)其中的 double... 相同于double[]，其实就是接受了一个 double 数组可以将数组传递给可变参数方法的最后一个参数。15. 枚举类这里的枚举类是一个类对象，而不是一种类型16. 继承设计的技巧将公共操作和域放在超类不要使用受保护的域使用继承实现 “is-a” 关系覆盖方法时，不要改变预期的行为这里说的是不要偏离设计，并不是不能改变基类方法的操作能使用多态就使用多态不要过多的使用反射]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 泛型基础]]></title>
    <url>%2FJava%2FJava%20%E6%B3%9B%E5%9E%8B%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[1. 概述泛型类似于 C++ 中的模板，使得编写的代码可以被多种不同的对象所使用。在 Java 增加泛型类之前，泛型实际上是以继承方式实现的泛型使用类型参数来指示元素的类型1234ArrayList&lt;String&gt; files = new ArrayList&lt;String&gt;();// Java SE 7 之后可以省略构造函数中的泛型类型ArrayList&lt;String&gt; files = new ArrayList&lt;&gt;();2. 泛型类单个参数12// 其中 T 为类型参数public class Pair&lt;T&gt; &#123;&#125;多个参数12// 多个类型参数用逗号隔开public class Piar&lt;T, U&gt; &#123;&#125;3. 泛型方法泛型方法不仅只存在于泛型类中，也可以在非泛型类中定义泛型方法12345678class ArrarAlg &#123; /** * 这是一个泛型方法， * &lt;T&gt; 表示其为泛型方法 */ public static &lt;T&gt; T getMiddle(T... a) &#123;&#125;&#125;调用泛型方法时，通过在方法名前的尖括号中放入具体的类型来将其实例化1String middle = ArrayAlg.&lt;String&gt;getMiddle("John", "Q.", "Public");其实大多数情况下，编译器都能推断出正确的类型，所以方括号可以省略4. 类型变量的限定有时候我们需要对类型变量进行一定的约束:比如，当我们需要对变量进行比较操作时，我们需要确保变量都实现了 Comparable 接口。对于类型变量的限定有两种方式限定上界1public static &lt;T extends Comarable&gt; T min(T[] a) ...这里我们限定了 T 必须是实现了 Comarable 接口的变量。如果 Comarable 是一个类，那么 T 必须是它，或者它的子类限定下界1public static &lt;T super Child&gt; T doSomeThings(T[] a) ...这里限定了 T 必须是 Child 的超类，或者它本身。使用 &amp; 分隔限定类型，使用逗号来分隔 类型参数1T extends Comparable &amp; Serializable5.泛型类的实例化5.1 类型擦除Java 中的泛型类采用 类型擦除 方式来进行实例化。类型擦除即为，擦除类型参数，并将其替换为限定的类型。例如上面的 T extends Comparable 则在类中的 T 会被替换为 Comparable如果类型没有被限定，则替换为 Object需要注意的是，虚拟机中没有泛型类型变量，任何的泛型类在需要实例化的时候，都会先进行类型擦除，然后替换为实例化的类型。例如， Pair&lt;T&gt; 的原始类型如下1234567891011121314151617public class Pair &#123; private Object first; private Object second; public Pair() &#123; first = null; second = null; &#125; public Object getFirst() &#123; return this.first; &#125; public Object getSecond() &#123; return this.second; &#125;&#125;通过类型擦除的方法，Java 使得泛型类就好像一个普通的类，从而避免了 C++ 模板实例化所造成的代码膨胀。5.2 翻译泛型表达式当程序调用泛型方法时， Java 采用强制类型转换（Cast）来返回或调用正确的类型例如12Pair&lt;Employee&gt; buddies = ...;Employee buddy = buddies.getFirst();此时，编译器自动插入强制类型转换使得 getFirst() 方法返回 Employee 类型5.3 泛型方法的实例化和桥方法泛型方法在实例化过程中也使用 类型擦除但是这在继承中会导致方法的冲突。例如：12345678class DateInterval extends Pair&lt;Date&gt; &#123; public void setSecond(Date second) &#123; ... &#125;&#125;// 经过类型擦除之后class DateInterval extends Pair &#123; public void setSecond(Date second) &#123; ... &#125;&#125;当使用基类指针实现多态性的时候12Pair&lt;Date&gt; pair = interval;pair.setSecond(aDate);此时，存在一个从 Pair 继承而来的方法1public void setSecond(Object second)由于形式参数的改变，使得这是一个不同的方法；但是我们对 pair 的多态性描述显然是要调用 setSecond(Date second) 方法；此时，编译器就会自动生成一个桥方法，用来保证多态的正确使用。1234// 桥方法public void setSecond(Objedt second) &#123; setSecond((Date) second);&#125;6. 约束和局限性6.1 不能用基本类型实例化类型参数由于泛型使用类型擦除来实现，所有的未限定类型均会被替换成 Object；而 Object 不能储存基本类型此时一般使用对象包装器来实现基本类型的实例化6.2 运行时的类型查询只适用于原始类型由于使用了类型擦除，所有的类型查询都只对泛型类的原始类型适用，而对泛型版本不适用。instanceof 和 getClass() 返回的都是原始类型6.3 不能创建参数化类型的数组创建泛型类的数组是不合法的。由于类型擦除的存在，所有的未限定泛型类都会被替换成 Object。例如123Pair&lt;String&gt;[] table = new Pair&lt;String&gt; [10]; // ERROR// After erasePair[] table = new Pair[10];此时，如果有下面的一条语句1234Object[] objects = table; // OK, Pair is a type of Object// But, if edit one of the elementsobjects[0] = "Hello"; // ERROR, because the objects[0] is Pair, not String当需要收集参数化类型对象时，使用 ArrayList 来代替数组实现如果实在需要创建泛型类的数组，那么就必须使用 强制转换。1Pair&lt;String&gt; p = (Pair&lt;String&gt;[]) new Object[10];6.4 Varargs 警告当使用可变参数的泛型类作为形参时，由于可变类型是一个数组，此时违反了上面一条规则。但是对于这种情况，规则有所放松，使用这个会得到一个警告，可以用 @SafeVarargs 注解来压制这个警告12@SafeVarargspublic static &lt;T&gt; void addAll(Collection&lt;T&gt; coll, T... ts)6.5 不能实例化类型变量所谓的类型变量指的是 T不能使用 new T(...) 类似这样的表达式而是通过反射调用 Class.newInstance 来构造新的 T 对象；不过，很遗憾的是，不能通过 T.class.newInstance() 来实现；调用 newInstance() 的 Class 对象必须由 外部传入：12345678public static &lt;T&gt; Pair&lt;T&gt; makePair(Class&lt;T&gt; clazz) &#123; try &#123; return new Pair&lt;&gt;(clazz.newInstance(), clazz.newInstance()); &#125; catch (Exception e) &#123; return null; &#125;&#125;6.6 不能构造泛型数组指的是不能构造 T[]；1T[] array = new T[2]; // ERROR!如果一定要使用数组，则必须进行强制转换：1T[] array = (T[]) new Object[2];需要注意的是，这种数组不能作为返回值：12345public static &lt;T&gt; T[] minmax(T... a) &#123; Object[] mm = new Object[2]; ... return (T[]) mm;&#125;在调用的时候，会出现 ClassCastException：12// Exception！String[] ss = minmax("Tom", "Dick", "Harry");这是因为类型擦除的问题；对于虚拟机而言，虚拟机知道每个元素的具体类型，所以做元素层次的强制转换是没有问题的：1234public T get(int index) &#123; // T[] items return items[index]; // OK&#125;但是对于数组本身而言，由于类型擦除导致实际上的数组的 声明 是 Object[]，可以接受任何的类型，所以无法将其强制转换为特定类型的数组。也就是说，对于一个 String 数组，可以将其转换为 Object 数组再转换回去；但是由于类型擦除导致 一开始 数组的声明就是 Object[]；所以无法将其转换为特定类型。对于这种情况，就需要使用泛型的 Array.newInstance()；通过 Class.getComponentType() 来获取到元素的真实类型。123public static &lt;T&gt; T[] minmax(T... a) &#123; T[] mm = (T[]) Array.newInstance(a.getClass().getComponentType(), 2);&#125;6.7 泛型类静态成员类型参数无效在泛型类中，不能在静态域或者方法中引用类型变量。123public class Singleton&lt;T&gt; &#123; private static T singleInstance; // ERROR&#125;这也是因为类型擦除，Singleton&lt;String&gt; 会恢复为 Singleton；而对于一个所有实例都共享的方法或者域，它不能仅仅依赖于某一个类型。6.8 不能抛出或捕获泛型类对象不能抛出和捕获 泛型类，同时，也不允许泛型类扩展 Throwable。1234// ERRORpublic class Problem&lt;T&gt; extends Exception &#123; /* ... */&#125;同时，catch 块中也不能使用类型变量 T123456try &#123; // do work&#125;catch(T e) &#123; // ERROR&#125;不过可以在 throws 中使用类型变量 T123456@SuppressWarnings("unchecked")public static &lt;T extends Throwable&gt; void throwAs(Throwable e)throws T&#123; throw (T) e&#125;在这种情况下，编译器会认为 T 是一个 未检查异常6.9 注意擦除后的冲突类型擦除很可能会引发和超类型的冲突；例如有这么一个方法：12345public class Pair&lt;T&gt; &#123; public boolean equals(T value) &#123; return first.equals(value) &amp;&amp; second.equals(value); &#125;&#125;这个方法在类型擦除之后，会变成：1boolean equals(Object value)然而，这个方法和超类继承而来的：12// Object 继承而来的！boolean equals(Object)出现冲突。此时，只能改名解决。同时，还必须注意类和它的子类不能实现两个不同 类型参数 T 的接口：12345class Calendar implements Comparable&lt;Calendar&gt; &#123;...&#125;class GregorianCalendar extends Calendarimplements Comparable&lt;CregorianCalendar&gt;&#123;...&#125;这里，Calendar 类和它的子类 GregorianCalendar 实现了两个不同类型参数的接口；这会导致合成的桥方法出现错误；对于实现了 Comparable&lt;X&gt; 的类，可以获得一个桥方法：123public int comparaTo(Object other) &#123; return compareTo((X) other);&#125;但是，由于 GregorianCalendar 同时实现了两个类型参数不同的同一个泛型接口；所以就会有两个 相同签名 的桥方法，而这是不允许的。7. 泛型类的继承在使用泛型类时，需要注意的是它的继承规则和直觉不同；例如， Employee 和 Manager 是父类和子类；但是 Pair&lt;Manager&gt; 不是 Pair&lt;Employee&gt; 的子类这里体现出来泛型和数组的一个重要区别；对于一个数组来说，可以将 Manager[] 赋给 Employee[]。不过如果尝试将一个低级别的 Employee 插入到多态的 Employee[] 中，则会抛出 ArrayStoreException]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工厂模式]]></title>
    <url>%2FDesignPattern%2F%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1. 概述工厂模式，是将构造类的责任从类或者子类本身委托到一个新的类进行的模式；通过将类的构建转移到一个新的类，减少了耦合度，在具体的产品需要进行修改时，只需要修改该类即可。这个新的类被称为工厂，或者创建者(Creator)它分为三种：简单工厂工厂方法抽象工厂2. 简单工厂简单工厂，顾名思义，就是 简单地 将构建产品的步骤搬到另一个类中去。需要说明的是，简单工厂在 GOF 《设计模式》中不被视为一个独立的设计模式；但是，由于实际编程中十分常用，所以依旧有需要说明一下；例如，一个比萨店，原来需要做比萨，烤比萨，切比萨和包装比萨：12345678910111213141516171819202122public class PizzaStore &#123; public Pizza orderPizza(String type) &#123; Pizza pizza; // 创建比萨 if (type.equals("cheese")) &#123; pizza = new CheesePizza(); &#125; else if (type.equals("pepperoni")) &#123; pizza = new PepperoniPizza(); &#125; // 其余剩下工作 pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); return pizza; &#125;&#125;现在，我们使用一个简单工厂，来承接创建比萨的职能：123456789101112131415161718192021222324252627282930313233343536public class PizzaStore &#123; SimpleFactory simpleFactory; public PizzaStore(SimpleFactor simpleFactor) &#123; this.simpleFactor = simpleFactor; &#125; public Pizza orderPizza(String type) &#123; Pizza pizza; // 通过工厂创建比萨 pizza = simpleFactory.createPizza(type); pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); return pizza; &#125;&#125;public class SimpleFactory &#123; public Pizza createPizza(String type) &#123; Pizza pizza = null; if (type.equals("cheese")) &#123; pizza = new CheesePizza(); &#125; else if (type.equals("pepperoni")) &#123; pizza = new PepperoniPizza(); &#125; return pizza; &#125;&#125;3. 静态工厂事实上，如果工厂方法无需改变；那么我们可以将其设置为静态的：123456789101112131415public class Pizza&#123; public static Pizza createPizza(String type) &#123; Pizza pizza = null; if (type.equals("cheese")) &#123; pizza = new CheesePizza(); &#125; else if (type.equals("pepperoni")) &#123; pizza = new PepperoniPizza(); &#125; return pizza; &#125;&#125;实际上，静态工厂是 《Effective Java》中推荐使用的对象创建方式；由于静态工厂拥有更为语义化的命名方式；而且这里可以看出，静态工厂可以根据参数生成相应的子类；而如果使用 new 关键字，则不能实例化子类。4. 工厂方法简单工厂虽然将产品的构建过程从客户中分离了出去；但是，并没有解决根本问题；比萨店还是依赖于具体的比萨类，当我们需要不同风味的比萨时，会让我们的简单工厂臃肿不堪：123456789101112131415161718192021222324public class SimpleFactory &#123; public Pizza createPizza(String style, String type) &#123; Pizza pizza = null; if (style.equals("NewYork")) &#123; if (type.equals("cheese")) &#123; pizza = new NYCheesePizza(); &#125; else if (type.equals("pepperoni")) &#123; pizza = new NYPepperoniPizza(); &#125; &#125; else if (style.equals("Chicago")) &#123; if (type.equals("cheese")) &#123; pizza = new ChicagoCheesePizza(); &#125; else if (type.equals("pepperoni")) &#123; pizza = new ChicagoPepperoniPizza(); &#125; &#125; return pizza; &#125;&#125;一个更好的方法是，通过派生出不同的工厂子类，让子类来实例化相应的产品：首先，我们将 PizzaStore 设置为抽象的，并将 createPizza() 设置为抽象方法：12345678910111213141516public abstract class PizzaStore &#123; public Pizza orderPizza(String type) &#123; Pizza pizza; pizza = createPizza(type); pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); return pizza; &#125; abstract Pizza createPizza(String type);&#125;这样，PizzaStore 类就成为了 抽象的 创造者；我们就可以通过继承 PizzaStore 来实现不同的比萨创建方式。工厂方法模式定义了一个创建对象的接口，然后由子类来决定要实例化的类。工厂方法让类把实例化推迟到 子类5. 依赖倒置原则工厂方法显著地减少了代码对于具体类的依赖；事实上，我们应该尽量减少对具体类的依赖，由此得到新的设计原则：要依赖抽象，不要依赖具体类这个原则听起来很像 『针对接口编程』，不过与之不同的是，该原则更强调 抽象；也就是说，不能让高层组件(比萨店)依赖于低层组件(具体的比萨)；而是要让高层组件和低层组件 都依赖于抽象(抽象的 Pizza 类)这里的 倒置 指的就是高层和低层组件都依赖于一个抽象类形成的依赖图倒置情况。当我们考虑类设计时，可以先从低层组件开始设计，然后考虑抽象层，最后再考虑高层组件。由于高层和低层组件都共同依赖于一个抽象类，所以高低层组件得到了解耦。6. 执行倒置原则的方针变量不可以持有具体类的引用使用工厂来代替持有的具体类不要让类派生自具体类如果派生自具体类就会产生依赖请派生自一个接口或者抽象类不要覆盖基类中已经实现的方法基类的方法是所有具体子类共享的例外：对于 不可变类(immutable)，可以使用 new 来进行具体类的实例化；这是因为 不可变类 不具备改变的能力。7. 抽象工厂7.1 定义抽象工厂模式提供一个 接口，用于创建相关或依赖对象的 家族，而不需要明确指明具体类。简单的来说，抽象工厂就是 工厂的工厂；通过创造具体的工厂来创建不同的产品家族；然后将这个产品家族提供给客户使用。7.2 产品族产品族指的是位于不同的产品等级结构中， 功能相关联 的产品组成的家族。就比萨店的这里例子来说，我们具有 酱汁、面团、芝士和蛤蜊 四种不同的配料；这 四种不同的配料 共同组成了配料产品族。对于某一种配料本身，有不同的风味；如芝加哥风味和纽约风味7.3 使用条件系统或者客户一次只能使用 一个 产品族；产品之间具有良好的分级和产品族分类7.4 重写比萨店事实上，不同风味的比萨只是使用了不同的原料；所以，我们只需要使用某一个地区的原料产品族就可以做出那个地区风味的比萨；所以，我们可以使用抽象工厂重写比萨店。首先，重写 Pizza 类，让其采用原料产品族。1234567891011121314public abstract class Pizza &#123; String name; // 原料产品族 Dough dough; Sauce sauce; Veggies veggies[]; Cheese cheese; Peppperoni pepperoni; Clams clam; // 不同的比萨品种具有不同的准备方法 abstract void prepare();&#125;在具体的比萨类中，采用原料工厂。12345678910public class CheesePizza extends Pizza &#123; PizzaIngredientFactory ingredientFactory; @Override public void prepare() &#123; dough = ingredientFactory.createDough(); sauce = ingredientFactory.createSause(); cheese = ingredientFactory.createCheese(); &#125;&#125;在比萨店客户中，我们只需要指定某个原料工厂，即可制造出不同风味的比萨。12345678910111213141516public class NYPizzaStore extends PizzaStore &#123; protected Pizza createPizza(String item) &#123; Pizza pizza = null; PizzaIngredientFactory ingredientFactory = new NYPizzaIngredientFactory(); if (item.equals("cheese")) &#123; pizza = new CheesePizza(ingredientFactory); pizza.setName("New York Style Cheese Pizza"); &#125; else if (item.equals("veggie")) &#123; pizza = new VeggiePizza(ingredientFactory); pizza.setName("New York Style Veggie Pizza"); &#125; &#125;&#125;8. 总结工厂模式是常用的对高低层平行组件进行解耦的设计模式；通过使用 工厂 和 抽象产品，使得客户类（高层组件）不再需要依赖于具体的产品（低层组件），而依赖于抽象产品（抽象层）；同时，低层组件通过工厂，也依赖于抽象产品，实现高低层组件的解耦。其中，工厂方法是通过将 方法 视为工厂，将具体产品的创建职责交给子类解决；而抽象工厂则是抽象出 工厂接口，通过不同的 具体工厂 来制作 产品族；有趣的是，工厂接口和具体工厂之间，也是使用了工厂方法模式。]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
      <tags>
        <tag>DesignPattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2FDesignPattern%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1. 概述单例模式，顾名思义，它可以保证在系统运行中，整个系统只存在某个类的 一个对象；该对象在系统中是 唯一的2. 经典实现需要注意的是，虽然这个实现很经典，但是它是错误的，在实际中不应该使用；但是，由于它较为简单，所以拿这种实现来说明单例的原理。123456789101112131415public class Singleton &#123; // 存储自身的引用 private static Singleton instance = null; private Singleton() &#123; // 不允许外界通过构造器构建 &#125; private static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125;该实现中，最为核心的就是 getInstance() 方法；通过 if 的判断，如果实例为空，那么进行构造；当实例构造完毕后，instance 就不为空了，直接返回自身。这样就保证了在普通情况下，对象只会有一个。但是，这种实现在多线程时不成立！当有两个线程同时尝试获取单例实例时，就会造成对象的重复构建：这是由于两个线程可能同时进入 if 区域中，导致两个线程分别执行对象的构建，最后就会出现两个单例对象。3. 懒汉式由于经典实现的缺陷是因为多线程导致的；那么我们只要把 getInstance() 设置为同步方法不就完了吗？1234567private static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance;&#125;但是，这种实现方法具有很严重的 性能缺陷；由于每次获取单例实例都需要先获取锁，导致性能低下；而实际上，只需要在单例的构建过程进行同步即可；没有必要在每次获取对象的时候都进行同步。4. 饿汉式既然多线程造成的问题是在 getInstance() 时发生的；而使用 synchronized 关键字又存在性能缺陷；那么，为什么不在类加载的一开始就进行实例构建呢？这样，既避免了多线程问题，又没有同步损失。123456789101112public class Singleton &#123; private Singleton() &#123; &#125; private static final Singleton instance = new Singleton(); public static Singleton getInstance() &#123; return instance; &#125;&#125;这样虽然解决了同步损失，但是，单例的构建很可能是一个耗时操作；它并不是一个懒加载操作，同时，如果单例的构建需要外部参数的话，这个方法就用不上了。5. 双检锁单例这种单例实现是目前用的比较多的形式；既然单例的多线程同步只需要在对象构建时进行，那么，我们就可以通过对 instance 进行两次检查。12345678910111213private static Singleton getInstance() &#123; // 检查对象是否已经构建 if (instance == null) &#123; synchronized(Singleton.class) &#123; // 防止两个线程同时进入第一个 if 造成的对象重复构建 if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance;&#125;这里着重解释第二个判断：当两个线程通过第一个 if 进入同步区后；线程一先获取锁，进行对象构建；线程一完毕后，线程二进入同步区；如果此时没有第二个 if，那么对象就会进行重复构建。当对象构建完毕后，外部的 if 将会跳过，不会再进行同步过程；这样就解决了同步的性能损失。看起来这个实现已经很完美了，但是还是有问题；问题就在于，instance = new Singleton() 不是一个原子操作这个操作分为三步：给 instance 分配内存调用 Singleton 的构造函数进行对象构造将 instance 指向分配的内存空间而在 JIT 即时编译优化中，会出现指令重排；最终的执行顺序很可能不是 1-2-3 而是 1-3-2；那么在 3 完成后，线程二抢占锁，此时 instance 不为空，于是线程二返回，报错。一个改进则是对于 instance 变量采用 volatile 进行修饰，防止指令重排；volatile 变量在赋值操作后会存在 内存屏障，防止读操作在赋值操作之前进行。所以，双检锁单例的正确实现形式如下：12345678910111213141516171819public class Singleton &#123; private static volatile Singleton instance = null; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized(Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125;6. 静态内部类可以看到，上面的双检锁单例的实现过于繁琐；有没有一种既线程安全，又采用懒加载而且实现简单的实现方法呢？有的，我们可以采用静态内部类来实现单例。12345678910111213public class Singleton &#123; private Singleton() &#123; &#125; private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; public static Singleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125;&#125;首先看到，我们把单例的实例放入了它的静态内部类中；这种实现方法的难度比双检锁单例下降了许多；其原理在于，我们不再 自行实现 线程安全；通过将实例交给静态内部类，我们可以让 JVM 保证天生的线程安全。当 Singleton 被加载时，其内部类并不会初始化；而当 getInstance() 调用时，其内部类被 加载 入内存中；JVM 保证所有对类的读写操作均在类加载 之后 进行；这样，就保证了线程安全；同时，由于 getInstance() 不是同步方法，也不会有同步损失。7. 序列化和反射攻击那么，我们的单例实现是否已经没有问题了呢？并不是！由于我们都是通过设定 访问修饰符 来达到将构造函数封装的目的；但是，当其他使用者使用 反射 来进行对象构建时，单例模式就会被破坏了！12Constructor&lt;?&gt;[] cons = getDeclaredConstructors();cons. setAccessible(true);其中，一个很常见的问题就是单例的序列化；当我们采用 Serializable 接口时；对象在序列化和反序列化的过程中，会使用 反射 调用无参构造方法进行对象构造。那么，我们该如何防止对象被反射攻击呢？一种方法是采用 flag，如果对象被反射攻击，那么就抛出异常；123456789101112public class Singleton &#123; private static boolean flag = false; private Singleton() &#123; if (Singleton.flag == false) &#123; Singleton.flag = true; &#125; else &#123; throw new RuntimeException("Reflect Attack!"); &#125; &#125;&#125;而对于序列化造成的对象的重复构建，我们可以采用重载 readResolve() 的方法进行。123private Object readResolve() &#123; return INSTANCE;&#125;8. 枚举实现(Best Practice)可以看到，当我们把所有问题都考虑到之后，单例的实现已经变得非常复杂了。所以有没有一种更为简单的方法能满足上面的所有要求呢？这就是枚举实现：1234567public enum Singleton &#123; INSTANCE; public void doSomeThing() &#123; // operations &#125;&#125;使用：123public static void main(String[] args) &#123; Singleton.INSTANCE.doSomeThing();&#125;它满足：线程安全无性能损失防反射攻击防止序列化重复构建而且是最为简单的一种单例实现方法。]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
      <tags>
        <tag>DesignPattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成器模式(Builder Pattern)]]></title>
    <url>%2FDesignPattern%2F%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F(Builder%20Pattern)%2F</url>
    <content type="text"><![CDATA[1. 概述生成器模式(Builder Pattern) 听起来很像 工厂模式(Factory Pattern)，不过两者有着很大的不同。工厂模式的目标是利用多态，减少类之间的耦合度；而生成器模式的目标在于， 一步一步地构建一个复杂产品，同时解决由于复杂参数造成的构造器数量爆炸。同时，生成器需要一个指导者来一步一步地指定产品构建的参数或者产品构建的步骤；而工厂模式不需要指导者。2. 结构类图3. 构造复杂产品所谓的复杂产品就是一个产品中有很多子类，而且每个子类都有相应的构造流程。例如，一个蛤蜊比萨，拥有面饼，酱料，芝士，蛤蜊等其他食材。123456public class ClamPizza &#123; Dough dough; Sauce sauce; Cheese cheese; Clam clam;&#125;对于这样一个复杂产品，我们就将其构造的过程委派给一个建造者(Builder)来完成。12345678public interface ClamPizzaBuilder &#123; ClamPizzaBuilder prepareDough(); ClamPizzaBuilder prepareSauce(); ClamPizzaBuilder prepareCheese(); ClamPizzaBuilder prepareClam(); ClamPizza build();&#125;然后，我们对接口进行实现。注意，这里有两种具体类的实现方法：在构建实际建造者时，就 立即 创建一个 默认的产品对象；由实际建造者储存创建产品的参数，当调用 build() 方法时，才返回产品对象在这里，需要指明的就是方法二更好；因为方法二符合语义，只有调用 build() 才真正的构建了对象；而且也适合于不可变对象（构造之后对象的属性不能发生改变）。方法一：123456789101112131415161718192021public class ConcreteClamPizzaBuilder implements ClamPizzaBuilder&#123; ClamPizza clamPizza = null; public ConcreteClamPizzaBuilder() &#123; clamPizza = new ClamPizza(); &#125; @Override public ClamPizzaBuilder prepareDough(Dough dough) &#123; // 准备面团，可以直接放入，也可以进行处理后放入 return this; &#125; // 剩下的 prepare 方法 @Override public ClamPizza build() &#123; return clamPizza; &#125;&#125;方法二：123456789101112131415161718192021222324252627282930public class ClamPizza &#123; // fields public ClamPizza(ClamPizzaBuilder builder) &#123; this.dough = builder.dough; // etc. &#125;&#125;public class ConcreteClamPizzaBuilder implements ClamPizzaBuilder&#123; // fields public ConcreteClamPizzaBuilder() &#123; clamPizza = new ClamPizza(); &#125; @Override public ClamPizzaBuilder prepareDough(Dough dough) &#123; this.dough = dough; return this; &#125; // 剩下的 prepare 方法 @Override public ClamPizza build() &#123; return ClamPizza(this); &#125;&#125;生成器模式和工厂模式最大的不同就是拥有一个指挥者来指挥产品的构建过程；1234567891011public class ClamPizzaDirector &#123; private ClamPizzaBuilder builder; // 指挥者用于指定产品建造的步骤 public ClamPizza construct() &#123; builder.prepareDough(); builder.prepareCheese(); builder.prepareClam(); builder.prepareSauce(); &#125;&#125;当然，有些比萨并不需要芝士，这个时候，我们就可以去除掉 prepareCheese() 的这一个步骤。4. 内部生成器减少构造器生成器模式除了能构造复杂产品以外，一个很重要的作用就是能解决由于构造参数的组合过多所导致的构造器爆炸。4.1 构造器爆炸假如一个类拥有 4 个属性，那么它 理想状态 下的构造函数就有 0 个参数，一个参数，两个参数，三个参数和四个参数。也就是说，它的构造器数量W = C_4^0 + C_4^1 + C_4^2 + C_4^3 + C_4^4当类的属性为 $n$ 时，有\begin{aligned} W &= C_n^0 + C_n^1 + C_n^2 + \cdots + C_n^{n-1} + C_n^n \\ &= 2^n \end{aligned}所以，类的属性和理想状态下的构造器数量为 指数关系4.2 实现123456789101112131415161718192021222324252627282930313233343536public class Pizza &#123; Dough dough; Cheese cheese; Sauce sauce; private Pizza(Pizza.Builder builder) &#123; this.dough = builder.dough; this.cheese = builder.cheese; this.sauce = builder.sauce; &#125; public static class Builder &#123; private Dough dough = defaultDough; private Cheese cheese = null; private Sauce sauce = null; public Builder prepareDough(Dough dough) &#123; this.dough = dough; return this; &#125; public Builder prepareCheese(Cheese cheese) &#123; this.cheese = cheese; return this; &#125; public Builder prepareSauce(Sauce sauce) &#123; this.sauce = sauce; return this; &#125; public Pizza build() &#123; return new Pizza(this); &#125; &#125;&#125;这样，即使 Pizza 有三个属性，但是我们通过使用一个内置的 Builder，成功地将构造器限制在了一个；同时，由于每个 prepare 方法都会返回 Builder；也就是说，我们可以在任何一个准备阶段进行 build()；这样，也就满足了不同的参数组合的需求；同时，由于 Pizza 的构造函数是 private 的，所以这就限定了只能通过生成器来建造对象。使用：1234567public static void main(String[] args) &#123; Pizza Pizza = new Pizza.Builder() .prepareDough(dough) .prepareSauce(sauce) .prepareCheese(cheese) .build();&#125;5. 模式扩展当只有一个具体建造者时，可以直接省略生成器接口；例如上面的静态内部生成器。有时候可以直接省略指挥者对象，而由 客户 直接充当指导者；例如，客户自己冲泡咖啡。6. 与抽象工厂的不同抽象工厂模式生产的是一个产品族，而生成器模式所生产的 一个 复杂产品；形象的说明就是，抽象工厂生产的是 汽车的零部件；而生成器是将零部件 组装 成为一辆汽车。7. 优缺点7.1 优点良好的封装性，客户端不必知道产品的内部细节建造者是独立的，容易扩展可以使用其他的对象进行构造辅助，而普通的产品构造方式不容易获取到7.2 缺点产生多余的 Builder 对象建造的过程暴露在外]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
      <tags>
        <tag>DesignPattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搜索算法的应用]]></title>
    <url>%2FAlgorithm%2F%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1. 寻找重复元素在排序应用中也可以寻找重复元素，但是使用符号表则更为高效（特别是散列实现）。将数组遍历一遍，随后查找表内是否存在这一元素，如果不存在则添加进表中，如果存在，则说明找到了重复元素分析：遍历一遍数组所需要的时间是 $O(N)$，由于散列表的查找和插入都是常数级别的，所以整体的复杂度是 $O(N)$排序则需要 $O(NlogN)$ 的时间，在最坏情形下需要遍历一遍整个数组($O(N)$)，时间复杂度是 $O(N + NlogN)$ 比符号表稍大。2. 字典实现符号表的键值对特性最适合实现的就是一个字典类，其中包括电话黄页、字典、账户信息 等等3. 过滤器可以用符号表过滤重复元素，建立黑名单和白名单等。这主要是依赖于符号宝的高效的查找操作。4. 反向索引可以将键和值互换，建立反向索引，实现相互搜索。5. 矩阵乘法矩阵乘法中的 0 是无用的，所以我们可以通过构建一个 向量类 ，使用一个符号表， 键值为向量中不为零元素的数组索引和相应的值。所以，我们就可以使用一个 向量数组 来代表矩阵；通过向量点乘的结果，来得到新矩阵的某个元素的值。进行点乘时，只需要查找出元素，再依照储存的索引找到相应的值相乘即可12345678910111213141516171819202122232425262728293031public class SparseVector &#123; private HashST&lt;Integer, Double&gt; st; public SparseVectro() &#123; st = new HashST&lt;Integer, Double&gt;(); &#125; public int size() &#123; return st.size(); &#125; public void put(int i, double x) &#123; st.put(i, x); &#125; public double get(int i) &#123; if (!st.contains(i)) &#123; return 0.0; &#125; else &#123; return st.get(i); &#125; &#125; public double dot(double[] that) &#123; double sum = 0.0; for (int i : st.keys()) &#123; sum += that[i] * this.get(i); &#125; return sum; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[散列表(Hash Table)]]></title>
    <url>%2FAlgorithm%2F%E6%95%A3%E5%88%97%E8%A1%A8(Hash%20Table)%2F</url>
    <content type="text"><![CDATA[1. 概述散列表是使用散列函数，将相应的键值对映射到数组的某个位置的数据结构。它在一般情况下相对于其他的数据结构要效率更高，你甚至可以实现在常数时间内进行查找和插入操作的符号表。但是它也有相应的缺点，下面将会详细讲述2. 散列函数散列表一个重要部分就是散列函数的计算，我们使用散列函数将键值转换为数组的索引。计算散列值一个很重要的方面就是让键值尽量分布到整个表中去，以避免碰撞的发生。如果我们拥有一个大小为 $M$ 的数组，那么我们需要返回$[0, M - 1]$ 的散列值。散列值的计算与类型相关。2.1 Java 的约定对于 Java 来说，比较幸运的是，Java 对于内置类型都实现了一个 hashCode() 方法，返回一个 32 位的 int 作为 hashCode；我们可以直接使用这个 hashCode 来实现我们自己的散列值计算。需要注意的是，Java 要求如果 x 和 y 相等，那么它们两者的 hashCode 也相等。2.2 散列计算方法常用的散列方法是除留余数法。我们选择大小为 $M$ 的数组，对于任意的正整数 k，计算 k % M，这样就能有效的将键分布于 $[0, M - 1]$$M$ 最好选择使用质数。虽然现在给不出严谨的数学证明，但是工程实践中说明使用质数作为除数可以更好地利用键值的信息。2.3 使用 hashCode 的计算问题下面是一个实现的例子：123private int hash(Key x) &#123; return (Math.abs(x.hashCode())) % M;&#125;在这个例子中，因为 Java 的 hashCode 返回的是一个 int 值；这说明 hashCode 的范围是 $-2^{31} \sim 2^{31} - 1$；但是我们需要的散列值要位于 $[0, M - 1]$；所以我们首先要将 hashCode 取绝对值。通常来说，取绝对值一般使用 Math.abs()；但是，由于 hashCode 可以取到整个 32 位整形的范围；当 hashCode 为 $-2^{31}$ 时，Math.abs() 是使用 -1 与之相乘；此时，数值变为 $2^{31}$，出现 上溢，便会回绕至 $-2^{31}$；所以，$-2^{31}$ 的绝对值是其本身！正确的做法如下：123private int hash(Key x) &#123; return (x.hashCode() &amp; 0x7fffffff) % M;&#125;通过忽略整形中的符号位来达到取绝对值的作用。2.4 浮点数对于 0 到 1 浮点数，我们可以将它乘以 $M$ 并四舍五入得到索引。但是这种方法下，浮点数的高位作用更大，所以我们可以先将浮点数转为二进制数，随后使用除留余数法2.5 字符串对于字符串，我们也可以使用除留余数法。通过 chatAt() 来返回一个 char 值。以下的代码使用 Horner 算法来生成散列值1234int hash = 0;for (int i = 0; i &lt; s.lengh(); i++) &#123; hash = (R * hash + s.charAt(i)) % M&#125;2.6 组合键如果键的类型含有多个整型变量，那么我们就可以将它们结合起来进行计算。例如：1int hash = (((day * R + month) % M) * R + year) % M;2.7 缓存如果散列值的计算很耗时，那么我们或许可以将每个键的散列值缓存起来Java 内置的 String 就使用了这种方法来减少计算量。2.8 结论为一个数据类型实现散列函数需要满足三个条件：一致性——等价的键必定产生相等的散列值高效性均匀性3. 碰撞处理散列表的另一个重要部分是碰撞处理。无论如何设计散列函数，总会出现两个不同的键得到同一个散列值的情况，这就叫做碰撞。此时，我们就需要对碰撞进行处理。3.1 拉链法一种处理碰撞的方法就是拉链法，实际上就是使用链表储存碰撞的元素。每个数组元素都是一个链表头，随后跟着与其碰撞的元素此时，我们的数组大小 $M$ 可以小于键值数量 $N$3.1.1 实现12345678910111213141516171819202122232425262728293031public class SeparateChainingHashST&lt;Key, Value&gt; &#123; private int N; // 键值对总数 private int M; // 散列表的大小 private SequentialSearchST&lt;Key, Value&gt;[] st; // 存放链表的数组 public SeparateChainingHashST() &#123; this(997); &#125; public SeparateChainingHashST(int M) &#123; // Create linked list this.M = M; st = (SequentialSearchST&lt;Key, Value&gt;[]) new SequentialSearchST[M]; for (int i = 0; i &lt; M; i++) &#123; st[i] = new SequentialSearchST(); &#125; &#125; private int hash(Key key) &#123; return (key.hashCode() &amp; 0x7fffffff) % M; &#125; private Value get(Key key) &#123; return (Value) st[hash(key)].get(key); &#125; private void put(key, val) &#123; st[hash(key)].put(key, val); &#125;&#125;关于删除操作，拉链法的删除操作相对简单，只需要找到 SequentialSearchST 对象，直接调用 delete() 方法即可。实际上就是链表的删除操作。3.1.2 性能在一张含有 $M$ 条链表和 $N$ 个键的散列表中，任意一条链表的键的数量均在 $N/M$ 的常数范围内的概率无限趋向 $1$在一张含有 $M$ 条链表和 $N$ 个键的散列表中，未命中查找和插入操作所需的比较次数为 $\sim N/M$这里可以看到，散列表的效率是很高的，一般情况下只需要常数级别的时间即可完成搜索和插入3.2 开放地址法另一种碰撞处理方法啊就是开放地址法，它倾向于利用数组中的空位来解决冲突。所以如果使用这种方法来进行碰撞处理，那么就要求数组的数量 $M$ 大于键值数量 $N$。3.2.1 实现开放地址的最简单实现叫做线性探测法：当碰撞发生时，直接检查数组的下一个位置。这会产生三种结果：命中未命中（为空）未命中（该位置的键与被查找的键不同）特别重要的一点是，我们要在到达数组结尾时返回开头。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class LinearProbingHashST&lt;Key, Value&gt; &#123; private int N; private int M; private Key[] keys; private Value[] vals; public LinearProbingHashST() &#123; keys = (Key[]) new Object[M]; vals = (Value[]) new Object[M]; &#125; private int hash(Key key) &#123; return (key.hashCode() &amp; 0x7fffffff) % M; &#125; private void resize() [ /* resize method*/ &#125; public put(Key key, Value val) &#123; if (N &gt;= M / 2) resize(2 * M); int i; for (i = hash(key); keys[i] != null; i = (i + 1) % M) &#123; if (keys[i].equals(key)) &#123; vals[i] = val; return; &#125; &#125; keys[i] = key; vals[i] = val; N++; &#125; public Value get(Key key) &#123; for (int i = hash(key); keys[i] != nul; i = (i + 1) % M) &#123; if (keys[i].equals(key)) &#123; return vals[i]; &#125; &#125; return null; &#125; public void delete(Key key) &#123; if (!contains(key)) &#123; return; &#125; int i = hash(key); while(!key.equals(keys[i])) &#123; i = (i + 1) % M; &#125; keys[i] = null; vals[i] = null; i = (i + 1) % M; while (keys[i] != null) &#123; Key keyToRedo = keys[i]; Value valToRedo = vals[i]; keys[i] = null; vals[i] = null; N--; put(keyToRedo, valToRedo); i = (i + 1) % M; &#125; N --; if (N &gt; 0 &amp;&amp; N == M / 8) resize(M /2); &#125;&#125;关于删除操作：我们不能直接将键的位置设置为 null，这会导致剩下的键无法被找到，所以我们需要将被删除键的右侧的键重新插入3.2.2 性能在一张大小为 $M$ 并含有 $N = \alpha M$ 个键的基于线性探测的散列表中，命中和未命中的查找所需要的探测次数分别为：\sim \frac{1}{2}(1 + \frac{1}{1 - a})\sim \frac{1}{2}(1 + \frac{1}{(1 - a)^2})所以，如果要维护线性探测法的最佳性能；应尽量保证数组是半满的4. 结论散列表在一般情况下可以实现常数级别的查找和插入操作性能保证来自于散列函数的质量这会导致散列表性能的不稳定，同时容易受到外部攻击。一些特殊的数据在经过散列计算后会映射到同一个位置，此时散列表的性能就会急剧下降。当需要性能保证时，优先考虑平衡二叉树（红黑树）散列计算可能复杂而且昂贵难以支持有序性相关的符号表操作经过散列计算后，键值对会随机地分布于数组中，不能保持其插入顺序。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2-3 树]]></title>
    <url>%2FAlgorithm%2F2-3%20%E6%A0%91%2F</url>
    <content type="text"><![CDATA[1. 介绍2-3 树是一种平衡二叉树，具有自动平衡能力2-3 树是一种拥有 2 种不同节点的树，称为 2-节点 和 3-节点2-节点，拥有一个键值和两个链接（左子树和右子树），实际上就是普通的二叉搜索树节点3-节点，拥有两个键值和三个链接，左子结点比最小的键值小，右子结点比最大的键值大，中子节点介于两者之间2. 搜索2-3 树的搜索和 BST 一样，根据比较结果来进入子树进行搜索。3. 插入2-3 树的插入稍微有些复杂，我们分情况来讨论。3.1 在 2-节点 中插入这是最简单的一种情况，只需将 2-节点 变为 3-节点即可。3.2 在只有 3-节点的树中插入在这种情况下，我们可以构建一个暂时的 4-节点，然后将其分裂为三个 2-节点。这个操作会增加树的高度3.3 在父节点为 2-节点 的 23-节点 插入这种情况就更加复杂了，此时，我们 将 3-节点 变为临时的 4-节点，然后将其分裂。分裂 4-节点 时，将中间节点向上传递到父节点中，将剩下的两个节点作为 2-节点3.4 在父节点为 3-节点 的 3-节点 插入这种情况和上一个稍微有点像，我们只需要将 3-节点 替换为临时的 4-节点，然后将其分裂。此时父节点成为 4-节点，所以我们递归地进行分裂操作，直到到达根节点位置。如果根节点仍然是 4-节点，那么我们就将根节点分裂，增加树的高度。4. 性能2-3 树能保证 2-节点 的完美平衡，在 BST 中，操作时间复杂度和树的高度成对数关系，所以：2-3 树能保证任何的相关操作均在对数级别；在最坏情况下，当所有的节点都是 2-节点 时，2-3 树的性能是 $log_2N$ 级别；在最好情况下，当所有的节点都是 3-节点时，2-3 树的性能是 $log_3N$ 级别在一个 $N$ 个节点的 2-3 树，搜索和插入只需要访问不超过 $logN$ 个节点。5. 结论2-3 树能保证树在插入时的完美 2-节点 平衡，不会出现 BST 的最坏情况。然而，2-3 树十分难以实现，在实际工程中，我们需要对代码尽量小的改动，从而达到性能优化的结果。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左斜红黑树]]></title>
    <url>%2FAlgorithm%2F%E5%B7%A6%E6%96%9C%E7%BA%A2%E9%BB%91%E6%A0%91%2F</url>
    <content type="text"><![CDATA[1. 介绍红黑树是 2-3 树的一种简易实现方式，它拥有两种链接，红链接和黑链接。黑链接是普通的二叉查找树链接，红链接表示了一个 3-节点在这里，我们使用的是左斜的红黑树，它满足以下条件：红链接永远在左边（向左倾斜）一个节点不能同时链接两个红链接红黑树是完美黑链接平衡的需要注意的是，如果红黑树满足以上条件，那么其和 2-3 树就是等价的。事实上，如果把红链接画平，那么红黑树就是一个 2-3 树。2. 新的节点定义为了表示链接的颜色，我们需要定义一个新的节点，或者说向原有节点增加新的属性——颜色。123456pravite class Node &#123; Key key; Value val; int N; boolean color;&#125;在这里，我们为原有的节点增加一个布尔值来表示指向它的链接的颜色，这样定义能省去一些麻烦，具体在下面的内容中会讨论到。3. 变形当我们往红黑树插入节点时，需要进行一些变形来让红黑树满足以上条件，就像我们对 2-3 树插入节点时做的处理一样。3.1 旋转第一个重要的变形是旋转变形。当我们在插入节点的时候，不可避免的会破坏红黑树的条件，有时会出现红色的右链接，或者两个连续的红链接等。对于这些情况，我们需要对红黑树做适当的旋转变换来让它重新满足红黑树的条件。3.1.1 向左旋转由图可以注意到，所谓的旋转主要做了两件事：交换根节点将中间子树调换父亲剩下就是转换颜色，修改子树节点数目等。抓住这个根本操作，就不会出错。12345678910111213Node rotateLeft(Node h) &#123; Node x = h.right; h.right = x.left; // Link the middle x.left = h; // x ship to the root x.color = h.color; // Change color h.color = RED; // Change color x.N = h.N; // Ship amount // Calculate the amount of left subtree h.N = 1 + size(h.left) + size(h.right); return x; // Return new root&#125;注意，我们采用了和二叉查找树一样的递归返回引用的方法，这样有利于重用原有代码和维护树的链接性。3.1.2 向右旋转这个方法和向左旋转大同小异，核心的思想就是转换根节点和中间子树。关于必要性：有些时候遇到复杂的红链接情况，就首先要将连接向右旋转，随后在进行其他变形操作。虽然红黑树条件中不允许红色右链接的存在使得此方法显得无意义，但是此方法的用意在于构建一个便于处理的中间状态。3.2 颜色转换当我们在进行旋转的过程中，很可能会遇到两个子节点的链接都是红色的情况。由于红链接代表了 3-节点，显然 2 个红链接就代表了一个 4-节点，在 2-3 树插入中，我们需要将临时的 4-节点 分裂，在红黑树中就是第二种变形——颜色转换。步骤如下：将两个红链接变成黑链接将父节点的链接颜色变为红色12345void filpColors(Node h) &#123; h.color = RED; h.left.color = BLACK; h.right.color = BLACK;&#125;这很好地体现了 4-节点 的分裂过程。首先，我们将红链接变为黑色，事实上增加了两个新节点，也就是将 4-节点 分裂了其次，将父节点的链接变为红色，此时父节点就会变为上层 3-节点 的一部分，也满足了在分裂过程中，将中间节点向上传递的思想。假如父节点是根节点时，由于没有任何链接指向根节点，所以根节点的颜色变得无关紧要了这也是为什么我们在定义新节点的时候要将其颜色定义为指向其链接的颜色的原因4. 插入最后，我们终于进入了真正的插入环节，根据 2-3 树的插入思想，红黑树的插入步骤如下：新节点的颜色是红色的由于 2-3 树在插入之后一定会形成至少一个 3-节点（有时还会有临时的 4-节点）如果右子结点是红色，左子结点是黑色，那么向左旋转右子结点为红色，左子结点为黑色，说明红黑树中存在红色的右链接，将其向左旋转如果左子结点和它的左子结点都是红色的，那么将当前节点向右旋转这种情况说明红黑树中存在两个连续的红色链接，说明存在一个内部的 4-节点，此时我们将其向右旋转，变为可以进行颜色转换的状态，随后通过颜色转换来将 4-节点 分裂如果左子结点和右子结点都是红色的，那么进行颜色转换此时说明存在 4-节点，通过颜色转换将其分裂123456789101112131415161718192021222324252627282930313233public void put(Key key, Value val) &#123; root = put(root, key, val); root.color = BLACK;&#125;private Node put(Node h, Key key, Value val) &#123; if (h == null) return new Node(key, val, 1, RED); // 插入位置的搜寻过程 int cmp = key.compareTo(h.key); if (cmp &lt; 0) h.left = put(h.left, key, val); else if (cmp &gt; 0) h.right = put(h.right, key, val); else h.val = val; // 旋转和颜色转换 // 注意以下顺序不可改变 if (isRed(h.right) &amp;&amp; !isRed(h.left)) h = rotateLeft(h); if (isRed(h.left) &amp;&amp; isRed(h.left.left)) h = rotateRight(h); if (isRed(h.left) &amp;&amp; isRed(h.right)) flipColors(h); h.N = size(h.left) + size(h.right) + 1; return h;&#125;需要注意的是，有可能存在需要多次变换的情况，所以上述检测需要依次进行一遍比如折线式的红链接（红色的左链接 + 红色的右链接），此时就需要先将右链接向左旋转，变为连续的红链接，再将上面的链接进行右旋转，变为两个红色的子链接，随后进行颜色转换。这样做的原因在于，我们可以按照图示那样， 逐步减少需要讨论的情况，从而节省代码同时，为了能让父节点也能进行正确的变形，变形操作要放置在递归方法之后，也就是修改值之后再进行变形操作。5. 删除删除通常来说是符号表实现的一个比较难的部分。对于红黑树来说， 我们不能直接删除一个黑节点，这样会导致黑节点出现不平衡。一般的红黑树实现中，通常是对红黑树做一个 BST 的删除操作，随后再进行恢复，不过这样在实践中会导致代码过于冗长。在左斜红黑树中，我们以 删除一个红节点 作为目标；在删除完成后，我们通过递归向上对链接进行修复。5.1 删除最大最小元素为了能够让我们所删除的元素成为红节点，当出现连续两个子节点都是黑的时，我们就必须通过颜色变换将红链接向下传递；否则红链接的特性就会断绝但是，这样有可能导致两个连续的红链接，如下图所示；b 节点并不在我们的递归路线中，我们无法对这种非法的 4-节点进行修复；所以我们要对这种情况进行处理。可以看到，我们首先将 a 节点进行颜色反转，从而将 c 染红；但是此时，由于 b 也是红节点，所以造成了两个连续的红链接；所以我们通过先将 c 向右旋转，再将 a 向左旋转，将其变为平衡态；再通过颜色反转避免了连续的红链接出现。实现如下：12345678910111213private Node moveRedLeft(Node h) &#123; //红链接向下传递 colorFlip(h); // 出现红色后继 if (isRed(h.right.left)) &#123; h.right = rotateRight(h.right); h = rotateLeft(h); colorFlip(h); &#125; return h;&#125;完整的删除最小元素的代码如下：12345678910111213141516171819202122232425262728293031323334353637383940public void deleteMin() &#123; // 如果根节点的两个子节点都是黑色的，那么将根节点设为红 // 以求能够有红链接属性向下传递 if (!isRed(root.left) &amp;&amp; !isRed(root.right)) root.color = RED; root = deleteMin(root); // 递归结束，将根节点恢复颜色 if (!isEmpty()) root.color = BLACK;&#125;private Node deleteMin(Node h) &#123; if (h.left == null) return null; // 如果连续两个子节点都是黑链接，那么将红链接性质传递 if (!isRed(h.left) &amp;&amp; !isRed(h.left.left)) h = moveRedLeft(h); h.left = deleteMin(h.left); // 递归向上修复链接性质 return balance(h);&#125;// 实际上就是插入时使用的性质修复private Node balance(Node h) &#123; if (isRed(h.right)) h = rotateLeft(h); if (isRed(h.left) &amp;&amp; isRed(h.left.left)) h = rotateRight(h); if (isRed(h.left) &amp;&amp; isRed(h.right)) flipColors(h); h.size = size(h.left) + size(h.right) + 1; return h;&#125;同理，在删除最大元素和删除通常元素的时候，我们也会出现由于红链接向下传递引起的连续红链接问题，如图所示：其中 d 不处在我们的递归路线上，所以就必须进行处理。实现如下：123456789101112private Node moveRedRight(Node h) &#123; // 红链接向下传递 flipColors(h); // 出现连续左斜红色 if (isRed(h.left.left)) &#123; h = rotateRight(h); flipColors(h); &#125; return h;&#125;完整实现如下：1234567891011121314151617181920212223242526272829public void deleteMax() &#123; // 保证有红链接存在 if (!isRed(root.left) &amp;&amp; !isRed(root.right)) root.color = RED; root = deleteMax(root); // 恢复根节点的黑链接 if (!isEmpty()) root.color = BLACK;&#125;private Node deleteMax(Node h) &#123; // 由于是左斜红黑树，所以需要将左边的红链接右转 // 以能够向下传递 if (isRed(h.left)) h = rotateRight(h); if (h.right == null) return null; // 如果没有连续的红链接，那么就将红链接向下传递 if (!isRed(h.right) &amp;&amp; !isRed(h.right.left)) h = moveRedRight(h); h.right = deleteMax(h.right); return balance(h);&#125;5.2 通常节点的删除对于通常内部节点的删除，由于红黑树的特殊特性，我们直接使用 BST 的删除方法需要考虑的问题颇多；但除此之外，我们可以使用一个巧妙的方法：将节点设置为其后继节点将其后继节点删除这样既符合 BST 删除原理，同时我们可以重用现有的代码；因为一个节点的后记节点，就是 其右子树的最小节点(min(h.right))；因为我们已经实现了 deleteMin() 方法；所以只需要简单的将节点交换，同时将后继删除即可。完整的实现如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public void delete(Key key) &#123; if (key == null) throw new IllegalArgumentException("argument to delete() is null"); if (!contains(key)) return; // 保证红链接向下传递 if (!isRed(root.left) &amp;&amp; !isRed(root.right)) root.color = RED; root = delete(root, key); // 递归结束，将根节点恢复 if (!isEmpty()) root.color = BLACK;&#125;private Node delete(Node h, Key key) &#123; if (key.compareTo(h.key) &lt; 0) &#123; // 在左子树 // 如果没有连续的红链接，则将红链接向下传递 if (!isRed(h.left) &amp;&amp; !isRed(h.left.left)) h = moveRedLeft(h); h.left = delete(h.left, key); &#125; else &#123; // 在右子树或者命中 // 左斜红黑树 // 将左边的红链接向右转，以向下传递 if (isRed(h.left)) h = rotateRight(h); // 到达最大节点 if (key.compareTo(h.key) == 0 &amp;&amp; (h.right == null)) return null; // 没有连续的红链接，将红链接向下传递 if (!isRed(h.right) &amp;&amp; !isRed(h.right.left)) h = moveRedRight(h); // 内部节点 if (key.compareTo(h.key) == 0) &#123; // 后继 Node x = min(h.right); // 将节点交换为后继 h.key = x.key; h.val = x.val; // 删除后继节点 h.right = deleteMin(h.right); &#125; else h.right = delete(h.right, key); &#125; return balance(h);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉查找树]]></title>
    <url>%2FAlgorithm%2F%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%2F</url>
    <content type="text"><![CDATA[1. 介绍为了解决线性结构下的二分查找无法支持高效的插入和删除操作的问题，同时提高插入和删除的效率；我们采用二叉查找树来进行符号表的实现。二叉查找树是一种树，它满足：每个节点都拥有一个 Comparable 键每个节点都大于它的左子节点，小于它的右子节点2. 数据结构的实现我们使用链式结构来实现这个树。一个节点包含了：左子结点的链接右子结点的链接以这个节点为根节点的树的节点总数节点的键和值The Node of Binary Search TreeNode leftChildKey keyValue valint NNode rightChildCode:123456789101112131415// The inner class of Nodeprivate class Node &#123; private Key key; private Value val; private Node left, right; // 以该节点为根的子树的节点个数，包括根节点 private int N; public Node(Key key, Value val, int N) &#123; this.key = key; this.val = val; this.N = N; &#125;&#125;3. API 实现这一节主要介绍数据的形式和相应的方法操作。这些方法都是基于二分查找发展而来的它们是：get(), put()min(), max(), floor(), ceiling()delete(), deleteMin(), deleteMax()3.1 搜索下面是 get() 方法的基本实现思路使用二叉搜索树来搜索数据与二分查找十分相像。首先从根节点开始，做以下操作：如果根节点和所给的键值相等，那么命中如果所给的键值比根节点小，那么就在其左子树搜索如果所给的键值比根节点大，那么就在其右子树搜索假如最终找到了 null，那么说明所给键值不在符号表中，返回 nullCode:12345678910111213141516171819public Value get(Key key) &#123; return get(root, key);&#125;private Value get(Node x, Key key) &#123; if(x == null) &#123; return null; &#125; int cmp = key.compareTo(x.key); if(cmp &lt; 0) return get(x.left, key); else if(cmp &gt; 0) return get(x.right, key); else return x.val;&#125;注意这里使用了递归的方法来深入子树中进行搜索。关于递归在下面的 put() 方法中也有运用。3.2 插入比起之前基于有序数组的二分查找，二叉搜索树的最大改进之处在于二叉搜索树拥有效率更高的元素插入操作。事实上，进行元素的插入是十分简单的，仅仅只是定位元素位置，连接上新元素，就完成了。需要注意的是，二叉搜索树是有序的，你必须事先定位元素的插入位置，也就是说，你不能将元素随便地插入到一些错误的地方。对于 put() 方法，主要完成两项工作：如果键值已经存在于符号表中，那么就更新它的值如果键值不在符号表中，那么就创建一个新的节点存储键值对下面是 put() 方法的代码1234567891011121314151617181920212223public void put(Key key, Value val) &#123; root = put(root, key, val);&#125;private Node put(Node x, Key key, Value val) &#123; if (x == null) return new Node(key, val, 1); int cmp = key.compareTo(x.key); if (cmp &lt; 0) x.left = put(x.left, key, val); else if (cmp &gt; 0) x.right = put (x.right, key, val); else x.val = val; // 更新节点个数 x.N = size(x.left) + size(x.right) + 1; return x;&#125;注意到，put() 方法是递归的，这也是它的主要工作原理之一。通过这个递归的方法，它才能深入树去进行搜索定位。而最重要的一点是，此方法必须将我们传入的 Node 引用返回如果我们传进去的是一个正常的节点，也就是一些我们不应该去修改的内部节点，那么此方法必须将这个引用原样返回，而且返回值要让原始的引用去捕获。这样，我们才能维持树的基本结构，否则树的结构就会被损坏。如果我们传进去的不是一个正常的节点，比如 null 值，那么方法会自动生成一个新的节点，并将其返回，那么原有的链接就能连上一个新的节点。一件非常有趣的事是，不只是公有方法，而且递归的私有方法也出现了同样的代码结构，即 x = put(x, key, val), 我们将 x 传递进去，然后最终它却返回出来被原有的引用捕获了。这是合理的，因为只有采用这种方式，我们才能保持树的结构然后更新链接，而不是毁掉它。事实上，递归方法不返回引用也是可以的，只不过需要在函数内部将链接连上。123if (x == null) &#123; x = new Node(key, val);&#125;3.3 删除删除操作是最为复杂的 BST 操作。它拥有很多情况，让我们逐步分析。3.3.1 删除 最小/最大 值这是删除操作中最为简单的情况，我们只需删除最左或者最右边的节点，然后链接上它剩下的子树即可我们使用 delMin() 作为例子，将其反过来做，就变成了 delMax()下面是相应的操作：一直深入左子树去查找，然后定位到最小的节点将它的右子树和它的父节点连接由于原有的连接最小节点的链接被其右子树占据，没有指向最小节点的引用，那么它就会被垃圾回收机制回收。在这里，我们依旧使用递归的方法来深入树进行查找12345678910111213public void deleteMin() &#123; root = deleteMin(root);&#125;private Node deleteMin(Node x) &#123; if (x.left == null) return x.right; x.left = deleteMin(x.left); x.N = size(x.left) + size(x.right) + 1; return x;&#125;与 put() 方法一样， delMin() 方法采用了递归的方法来深入树进行查找所以，它需要返回我们传入的链接，然后让原有链接捕获它来保持整个树的结构。这也是更新链接的方式。但是最有趣和最重要的一点是，当我们找到最小的节点之后，我们要将其右子树返回。由于递归操作，最小节点的父节点的左链接会连接到最小节点的右子树上。这个操作事实上 FREE 了最小的节点，而且保持了结构的完整。这个操作在我们删除具有两个子节点的元素的时候也很有用。那么在这里递归方法能不能不返回引用呢？答案是不行！delMin() 方法和 put() 方法不同的一点是它要回溯到上一个节点，当需要回溯到上一个节点的时候，我们就需要采用返回一个引用的方法，否则无法回溯。所以建议统一采用返回引用的做法3.3.2 通常节点的删除我们可以使用类似 delMin() 的方法来删除只具有一个子节点的节点但是删除具有两个子节点的节点会更为复杂。这种情况下需要解决的最重要的问题是，我们需要找到一个节点来替代其位置，否则链接将会损坏。为了解决这个问题，我们采用它的后继来替代它。下面是找到所需删除元素 x 之后的步骤：将 x 保存一个副本 tt 即所需要删除的元素让 x 指向其后继 min(x.right)后继即比 x 大的下一个节点，也就是其右子树中最小的节点此时 x 已经指向后继。让 x.right 指向 delMin(t.right)这一步较为关键和难以理解。delMin(t.right) 主要做了如下几件事：将后继从下层的链接释放出来t 是原有 x 的副本，所以 delMin(t.right) 最后会查找到其后继，并释放出来。保持后继释放后的链接完整性。delMin() 在查找到最小节点之后会返回右链接，由于调用递归性，右链接会被上层捕获，从而保持了链接性。这里将后继释放出来后，会让其父节点来负责链接上其右子树。更新计数，并将传入的链接原样返回这是最为重要的，首先将计数更新了，保证计数正确性。其次，delMin(x) 在最后退出递归的时候会返回 x。也就是 delMin(t.right) 的返回值是 t.right。那么 x.right = delMin(t.right) 也就相当于 x.right = t.right。正好是使用了 x 来替代 t（注意此时 x 已经是后继了）让 x.left 指向 t.left更新计数器，递归方法返回传入值来保持链接完整性Code:12345678910111213141516171819202122232425262728293031323334353637public void delete(Key key) &#123; root = delete(root,key);&#125;private Node delete(Node x, Key key) &#123; // Notice that, we use recursive way // to locate the Node which will be delete // Also, we need to renew the counter // Therefore, in this method, we need to // retrun the link of the node itself, to // miantain the connectivity if (x == null) return null; int cmp = key.compareTo(key); // if not hit, // deep into subtree and continue search if (cmp &lt; 0) x.left = delete (x.left, key); else if (cmp &gt; 0) x.right = delete(x.right, key); else &#123; // hit // The deletion of one or none child if (x.right == null) return x.left; if (x.left == null) return x.right; // Two child Node t = x; x = min(t.right); // refer to the special notice x.right = deleteMin(t.right); x.left = t.left; &#125; // renew counter x.N = size(x.left) + size(x.right) + 1; return x; // return itself to maintain the conectivity&#125;3.4 其他的有序方法3.4.1 最小和最大找到最小或者最大的元素是很简单的，只需要深入左子树或者右子树就可以了。12345678public Key min() &#123; return min(root).key;&#125;private Node min(Node x) &#123; if (x.left == null) return x; return min(x.left);&#125;3.4.2 向下取整/向上取整这两个方法的目的是寻找到一个不大于或者不小于输入节点的节点我们使用向下取整来举个例子：这个方法的核心思想就是：如果所给的键值比根节点小，那么所需的节点就肯定在左子树中如果所给的键值比根节点大，那么所需的节点可能在右子树中也就是说，如果我们在右子树中找不到所需节点，那么根节点就是所需节点123456789101112131415public Key floor(Key key) &#123; Node x = floor(root, key); if (x == null) return null; return x.key;&#125;private Node floor(Node x, Key key) &#123; if (x == null) return null; int cmp = key.compareTo(x.key); if (cmp == 0) return x; if (cmp &lt; 0) return floor(x.left, key); Node t = floor(x.right, key); if (t != null) return t; else return x;&#125;3.4.3 选择和排序这两个方法是关于节点在树中的排位问题的。这也是为什么我们需要维护一个子树的节点总数的原因。select() 和 rank() 是一对互逆方法，一个给排名，返回键值，另一个给键值，返回排名下面用 rank() 方法举个例子，此方法的步骤是：如果键值和根节点相等，那么根节点的左子树的总数就是所给节点的排名如果所给的键值比根节点小，那么就在左子树中寻找如果所给的键值比根节点大，那么在右子树中寻找，此时，所给节点的排名为：Rank = Size(left\ subtree) + Rank(right\ subtree) + 1左子树中的节点都比根节点小，既然所给节点都比根节点大，那么理应比左子树的节点都要大。所以排名还要加上左子树中的节点个数。其中的 $1$ 表示的是根节点本身。1234567891011121314151617181920212223public Key select(int k) &#123; return select(root, k).key;&#125;private Node select(Nodex, int k) &#123; if (x == null) return null; int t = size(x.left); if (t &gt;k) return select(x.left, k); else if (t &lt; k) return select(x.right,k - t - 1); else return x;&#125;public int rank(Key key) &#123; return rank(key, root);&#125;private int rank(Key key, Node x) &#123; if(x == null) return 0; int cmp = key.compareTo(x.key); if (cmp &lt; 0) return rank(key, x.left); else if (cmp &gt; 0) return 1 + size(x.left) + rank(key, x.right); else return size(x.left);&#125;由方法的步骤可以看出，这两个方法都具有浓重的递归特质，使用递归类型的方法会简便得多3.4.4 范围keys() 方法的主要算法思想就是要返回在一个特定范围内的所有键值我们使用队列来保存这些键值如果根节点比范围小，那么找右子树如果根节点比范围大，那么找左子树如果根节点在范围内，将其入列，然后分别找左子树和右子树这么做的目的是，如果一个节点在范围内，那么它的左子树和右子树也有可能在范围内123456789101112131415161718192021public Iterable&lt;Key&gt; keys() &#123; return keys(min(), max());&#125;public Iterable &lt;Key&gt; keys(Key lo, Key hi) &#123; Queue&lt;Key&gt; queue = new Queue&lt;Key&gt;(); keys(root, queue, lo, hi); return queue;&#125;private void keys(Node x, Queue&lt;Key&gt; queue, Key lo, Key hi) &#123; if (x == null) return; int comlo = lo.compareTo(x.key); int cmphi = hi.compareTo(x.key); // Notice that there is no *eles*, // that's because we need to traversal the subtree if (cmplo &lt; 0) keys(x.left, queue, lo, hi); if (cmplo &lt;= 0 &amp;&amp; cmphi &gt;= 0) queue.enqueue(x.key); // Within range if (cmphi &gt; 0) keys(x.right, queue, lo, hi);&#125;4. 性能BST 的性能是依赖于输入模型的。最好的情况是 BST 完美平衡，也就是说所有叶节点到根节点的距离是$\sim lgN$最坏的情况是 BST 中的每一个节点都在同一侧，此时搜寻效率将会减少到 $O(N)$ 在平均情况下，一个有 $N$ 个随机键值的二叉树中，插入和未命中搜索需要 $\sim 2lnN$ (大约是 $1.39lgN$) 次的比较;对于删除操作，在平均情况下，则需要 $\sqrt{N}$ 次比较5. 结论使用 BST 可以很好地解决数组插入和删除引起的性能问题。事实上，在 BST 中进行搜索需要大约 $39\%$ 的额外性能，但是由于插入的开销被减少到了对数级别，所以这一额外的花销是值得的。但是，BST 没有时间复杂度上的性能保证，在最坏情形下，它搜寻一个键仍然需要线性级别的时间]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[符号表]]></title>
    <url>%2FAlgorithm%2F%E7%AC%A6%E5%8F%B7%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[1. 符号表符号表是一个储存键值对的表，同时还有插入和删除的功能。1.1 符号表的设计符号表不允许重复的键键值对是唯一的，一个键只对应一个值符号表不允许空键和空值这是因为空键会导致 Runtime Exception不允许空值可以让我们通过更少的 API 来实现更多的类似插入删除的操作我们可以通过 get() 来测试一个键是否是空键通过 put() 的空值来删除这个键只通过 compareTo() 方法来去判断两个键的相等性如果我们混合使用 equal() 和 compareTo() 方法，那么这将会导致很多不必要的浪费为了避免这种使用不同方法所造成的浪费，我们决定只使用 compareTo() 来去判断相等性1.2 API这里展现了我们应该使用在符号表的 API ，这些 API 主要对键值对进行操作；之后的内容将基于这里给出的 API 来进行。1.2.1 关键的 API最为关键的符号表 API 是 put() 和 get()12345678910111213/*** Put the key and value pair into the symbols table.* @parma key The key you want to insert, when it is null, delete the key from table.* @parma value The value you want to insert*/void put(Key key, Value value)/*** Get the value of the specfic key in the table.* @parma key The key you specify* @return The value of the specific key, if the value doesn't exist, return null*/Value get(Key key)1.2.2 在有序符号表中的其他方法这些 API 是应用于有序符号表的这里只展示了一些关键方法，还有一些冗余方法用于更方便的操作，这里不予展示API 包括：min() 和 max()floor() 和 ceiling()rank() 和 select()keys()这里只展示了 rank(), select() 和 keys() 方法，其他的方法比较简单，而且其作用也很容易通过名字进行推断。所以在这里不予显示123456789101112131415161718192021222324252627282930// Rank &amp; Select/*** Get the number of the keys which are less than the specific one. Also called the RANK* @parma Key key The specific key* @return The number of keys in the table which are less than the specific one.*/int rank(Key key)/*** Get the key which is rank k* @parma int k The rank of the key* @return The specific key*/Key select(int k)// keys()/*** Get the all keys inside the table.* @return An Iterable Set of keys, such as List or Queue*/Iterable&lt;Key&gt; keys()/*** Get the set of the range of [lo..hi]* @parma Key lo The low range of the keys.* @parma Key hi The high range of the keys.* @return The Iterable Set of the keys.*/Iterable&lt;Key&gt; keys(Key lo, Key hi)2. 在无序表中的顺序查找当我们实现一个符号表的时候，我们通常使用链表的形式来实现；使用这样的一个数据结构时，我们只能以顺序的形式进行搜索，仅仅通过在单链接链表中遍历所有的节点2.1 实现123456789101112131415161718192021222324252627282930313233343536373839public class SequentialSearchST&lt;Key, Value&gt; &#123; private Node first; private class Node &#123; // The linked List Node Key key; Value val; Node next; &#125; public Node (Key key, Value val, Node next) &#123; this.key = key; this.val = val; this.next = next; &#125; public Value get(Key key) &#123; // get the specific key, return the corrsponding value for(Node x = first; x != null; x = x.next) &#123; if(key.equals(x.key)) &#123; return x.val; // hit &#125; &#125; return null; // Not hit &#125; public void put(Key key, Value value) &#123; for(Node x = first; x != null; x = x.next) &#123; if(key.equals(x.key)) &#123; x.val = val; return; // hit &#125; &#125; // Not hit, create new node // Add at the beginning first = new Node(key, val, first); &#125;&#125;2.2 性能在一个具有 $N$ 个节点的符号表中，使用顺序查找方法，在最坏情况下，需要 $N$ 次的比较。特别的是，插入 $N$ 个节点，需要 $\sim N^2/2$ 次的比较2.3 结论我们可以看到，使用链表实现符号表时，它需要使用顺序查找方法，这样子使得查找的效率变得很低下；这样子的实现方式，并不能满足我们现今对大数据处理的需求。3. 在有序符号表中的二分查找为了实现更快的查找性能，我们需要转用数组来实现符号表；对于一个有序符号表来说，我们可以使用二分查找的方法来进行搜索；后面会看到，使用二分查找将会大大提高我们的搜索效率3.1 实现我们使用两个平行的数组来分别储存键和值；然后我们使用 rank() 方法来帮助我们找到一个特定的键值对12345678910111213141516171819202122232425262728293031323334/*** These method all base on the rank() method* Which return the number of the keys which are less than the spcific one* Or the right position of the specific key*/public Value get(Key key) &#123; if (isEmpty()) return null; int i = rank(key); if (i&lt; N &amp;&amp; keys[i].compareTo(key) == 0) &#123; return vals[i]; // hit &#125; else &#123; return null; // Not hit &#125;&#125;public void put(Key key, Value value) &#123; // The specific position of the key int i = rank(key); if (i &lt; N &amp;&amp; keys[i].compareTo(key) == 0) &#123; // Update: 2017-02-12 vals[i] = val; return; &#125; // Not hit, create new key-value pair for (int j = N; j &gt; i; j--) &#123; // MOVE THE DATA FORWARD keys[j] = keys[j - 1]; vals[j] = vals[j - 1]; &#125; keys[i] = key; vals[i] = val; N++;&#125;对于 rank() 方法的一些需要注意的点：这个方法的返回值是小于这个键的所有键的个数换句话来说就是这个键在数组中的排名，也就是它的位置重要的是，由于 get() 和 put() 方法也使用了12345678910111213141516171819202122/*** Using the Binary Searching method, due to the ordered talbe.*/public int rank(Key key) &#123; // Notice that, the lo, hi, mid is the // POSITION of the array int lo = 0, hi = N - 1; while (lo &lt;= hi) &#123; int mid = lo + (hi - lo) / 2; // Use this format to avoid the overflow int cmp = key.compareTo(keys[mid]); if (cmp &lt; 0) &#123; hi = mid - 1; &#125; else if(cmp &gt; 0 ) &#123; lo = mid + 1; &#125; else &#123; return mid; &#125; &#125; return lo;&#125;二分查找是很简单的，通过在一个有序的序列中比较中间位置的数据元素，从而逐步缩减查找范围，达到减少比较次数的作用。需要注意的是：使用 mid = lo + (hi - lo) / 2; 来避免溢出为了理解这点，你需要明白，lo, hi 和 mid 只是键值的位置，而不是键值的值。我们只需要获取中间元素的位置，如果一个数组的元素总数很大，那么使用 hi + lo 就会导致溢出，使得 mid 的结果甚至都不在 [lo...hi] 之间。为了防止溢出，或者说为了保证 mid 的结果落在 [lo...hi] 之间，那么我们就需要使用另一种计算方式；即，通过步长的方式来获取中间位置，通过使用 lo + 步长 的方式，可以有效的避免溢出的出现。所以，我们使用 mid = lo + (hi - lo) / 2 来获取中间位置。当数据元素小于 5 时，使用顺序查找来降低出错率顺序查找比二分查找更不容易出错。当数据元素小于 5 的时候，顺序查找和二分查找并没有什么大的性能差异，此时使用顺序查找来降低出错率是可以接受的。3.2 性能在一个 $N$ 个键值的符号表中，使用二分查找，需要不超过 $lgN + 1$ 次的比较但是在同时需要插入和删除的操作的时候，二分查找的效率还是远远不能满足我们的需求如果你需要在一个 $N$ 个元素个数组中插入一个元素，你需要 $\sim 2N$ 次的数组访问；而且如果你需要插入 $N$ 个元素到一个空表里，你需要 $\sim N^2$ 次的数组访问。3.3 结论在有序符号表中使用二分查找，可以将时间复杂度减少到 $logN$ 级别。对于一个静态的符号表（即不允许插入和删除元素的表），在查找之前将其进行排序是值得的；但是这种形式的查找还是不能满足我们对于快速的查找的同时支持快速的插入和删除操作。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优先队列和堆排序]]></title>
    <url>%2FAlgorithm%2F%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[1. 介绍优先队列是一种类似队列的数据结构，但是支持删除最大或最小元素以及插入元素最重要的一点是，优先队列能存储很大的数据量，或者当你的内存很小的时候进行一些队列的操作2. 基本实现数组实现（无序）当次序不重要的时候，我们可以重用栈这一数据结构。insert() 方法就类似栈的 push() 方法对于 deleteMax() 方法，我们可以采用将最大的元素交换到栈顶的方法实现数组实现（有序）当需要次序的时候，我们使用数组用于保持元素的次序为了维持这一次序，我们可以在插入的是偶将大的元素往右移动，这样，整个数组就会都是有序的。这时，我们只需要简单的调用 pop() 方法即可实现删除最大元素链表实现由于上面使用了栈和队列这几种数据结构，我们可以使用更高效的链表来实现他们。具体的算法思想和数组实现一致。3. 二叉堆实现3.1 二叉堆的定义二叉堆是一个满足堆有序的完全二叉树堆有序：当所有的二叉树节点都大于或等于他们的两个子节点时，称二叉树堆有序推论：二叉堆的根节点比任何节点都要大3.2 二叉堆的表示法因为二叉堆是一个完全二叉树；所以，我们可以轻松的使用数组来表示一个二叉堆。需要注意的是，为了与参数上的索引对应，我们不使用 a[0]3.3 原理主要的原理是如何去重新排序一个二叉堆当我们进行比较和交换的时候，二叉堆的顺序将会被打破，所以我们需要重建二叉堆(reheapifying)主要的算法思想是上浮和下沉当一个节点获得了更高的优先级的时候，我们将其上浮，通常是由于我们在二叉堆的底部插入了一个新节点导致的。当一个节点优先级降低时，我们将它下沉，通常是我们用一个低优先级的节点替换了根节点的时候（其实是进行了删除操作）上浮当一个节点比他的父节点大的时，我们将它和它的父亲交换以恢复二叉堆的次序这是一个递归的操作，如果上浮后还存在二叉堆次序损坏，那么就继续上浮下沉当一个节点比它的两个子节点都要小的时候，我们将它与较大的子节点交换以恢复二叉堆的次序 如果下沉之后仍存在此情况，继续下沉1234567891011121314151617181920212223private void swim(int k) &#123; while(k &gt; 1 &amp;&amp; less(k / 2, k)) &#123; exch(k, k / 2); k = k / 2; &#125;&#125;private void sink(int k) &#123; while(k * 2 &lt; N) &#123; int j = k * 2; if (less(j, j + 1)) &#123; j ++: &#125; if (!less(k, j)) &#123; break; &#125; exch(k, j); k = j; &#125;&#125;3.4 实现插入元素我们将一个新元素插入到数组尾部，增大堆的大小，然后将元素上浮删除最大元素我们将位于数组尾部的元素和根节点交换，然后删除原来的根节点，将新的根节点下沉123456789101112public void insert(Key v) &#123; pq[++ N] = v; swim(N);&#125;public Key delMax() &#123; Key max = pq[1]; exch(1, N--); pq[N + 1] = null; // Prevent the object free sink(1); return max;&#125;4. 索引优先队列索引优先队列是一种带了索引的优先队列；这里的索引指的是，队列中的元素 在队列的位置。至于优先队列为何需要索引，实际上是为了方便修改队列里的数据。有了这个索引，我们就可以处理一些大型的输入数据（甚至可能都没办法一次性读入内存的数据），或者在一些小内存机器上工作主要的改变有：我们将元素和它的索引一起插入我们删除最大元素的时候，返回它的索引4.1 实现使用 3 个数组：pq[]优先队列的堆，下标是堆的位置，值是 索引qp[]索引数组，是 pq[] 的反转，值是堆的位置keys[]对象数组，下标是索引，值是对象本身4.2 使用优先队列的多项归并1234567891011121314151617181920212223242526272829303132333435363738public class Multiway &#123; public static void merge(In[] streams) &#123; int N = streams.lenth; // Notice tha the N is the number of the STREAM, // not the input strings. IndexMinPQ&lt;String&gt; pq = new IndexMinPQ&lt;String&gt; (N); for (int i = 0; i &lt; N; i++) &#123; if (!streams[i].isEmpty()) &#123; // That is a Stream // Insert the stream pq.insert(i, streams[i].readString()); &#125; &#125; while (!pq.isEmpty()) &#123; // Output the Min element StdOut.println(pq.min()); int i = pq.delMin(); // Keep reading next String if (!streams[i].isEmpty()) &#123; pq.insert(i, streams[i].readString()); &#125; &#125; &#125; public static void main(String[] args) &#123; int N = args.lenth; In[] streams = new In[N]; for (int i = 0; i &lt; N; i++) &#123; streams[i] = new In(args[i]); &#125; merge(streams); &#125;&#125;5. 堆排序堆排序是优先队列的一种应用；它将元素插入到优先队列中，然后通过删除最大元素或者删除最小元素来达到排序的目的这个算法由于使用了优先队列，它能处理一些特别大型的数据，或者在一些小内存机器上使用。它包含了两个步骤，建立二叉堆和销毁二叉堆5.1 实现原理5.1.1 建立二叉堆需要注意的是，数组其实就是一个二叉堆！所以我们只需要对数组进行二叉堆重建(reheapifying)，那么建立的步骤就完成了123for (int k = N / 2; k &gt;= 1; k--) &#123; sink(pq, k, N);&#125;5.1.2 销毁二叉堆（排序）二叉堆可以帮助我们获取最大或者最小的元素，所以我们只需要将其删除出二叉堆，然后插入到一个新数组就可以了。但是要注意的是，我们应该如何去删除最大的元素呢？实际上，我们不需要真正的“删除”这个元素（即释放它的内存）；我们只是在进行排序，所以我们只需要将它交换，或者说将它放到正确的位置，即可。1234while (N&gt;1) &#123; exch(a,1, N--); sink(a, 1, N);&#125;5.2 实现12345678910111213141516171819public static void sort(Comparable[] a) &#123; int N = a.lenth; /** * Build the heap * We only need to traversal the nodes * who contains children. * As the heap's theory, we convince that the k = N/2 */ for (int k = N/2; k &gt;= 1; k--) &#123; sink(a, k, N); &#125; // Destory the heap while (N&gt;1) &#123; exch(a,1, N--); sink(a, 1, N); &#125;&#125;注意，如果需要升序，应该使用删除最大元素的二叉堆；同理，如果需要降序，应该使用删除最小元素的二叉堆；因为交换使得删除的元素被交换到了数组尾部。需要注意的是，我们这里使用的是 1-base 的堆，而普通的数组是 0-base 的；所以需要在索引计算上小心谨慎。5.3 性能进行 $N$ 个数据元素的排序，堆排序仅仅需要 $(2NlgN + 2N)$ 次的比较和一半的交换虽然它的时间复杂度是线性级别的，但是它需要很少的内存就可以处理很大型的数据。同时，堆排序在最坏情况下可以保证 $NlogN$ 的复杂度，而且是原地排序（不需要多余空间）尽管如此，堆排序的应用仍然没有快速排序广泛和频繁，主要是因为：堆排序的内循环比快速排序要复杂循环技术和各种需要注意的地方较快速排序多堆排序不能有效利用缓存堆排序载入大数组时，数组的引用会很可能布满整个内存，而快速排序是递归调用，保留着很多局部的引用，所以快速排序在利用缓存的效率上比堆排序高。现代机器的缓存命中率一般都会在 95% 以上，所以有效的利用缓存是很重要的。同时和归并排序相比，堆排序是不稳定的，在开发一些要求排序稳定性的程序时，显然应该选择归并排序]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法的应用]]></title>
    <url>%2FAlgorithm%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1. 多种排序方式使用 Comparator 接口，我们可以定义不同的 sort() 方法或者使用不同的键来对数据进行排序。Comparator 接口：123public interface Comparator &#123; int compare();&#125;注意，此接口是被排序类提供的，排序方法只需要调用接口的 compare方法即可为了使用此接口，我们可以通过重载 sort() 方法来实现12345678910111213141516// The original sort() methodpublic void sort(Comparable[] a) &#123; /* The sort method body */&#125;// Now we use new sort which comes wit Comparatorpublic void sort(Object[] a, Comparator c) &#123; /* The new sort method body */&#125;// Also, we need to changge other// assistant method to use Comparatorprivate int less(Comparator c, Key v, Key w) &#123; // Invoke the interface method return c.compare(v, w);&#125;对于被排序类的实现，可以通过使用内部类的方式来提供 Comparator1234567891011121314151617public class Student &#123; public static final Comparator&lt;Student&gt; BY_NAME = new ByName(); public static final Comparator&lt;Student&gt; BY_SECTION = new BySection(); private class ByName implements Comapator&lt;Student&gt; &#123; pubic int compare(Student v, Student w) &#123; // By name &#125; &#125; private class BySection implements Comparator&lt;Student&gt; &#123; public int compare(Student v, Student w) &#123; // By Section &#125; &#125;&#125;2. 稳定性稳定性指的是，在排序过程中，算法会保留具有相同键值的元素的相对顺序。如果能够保留，就说明排序算法是稳定的，如果不能够保留，则不稳定。排序算法稳定与否，在于在排序过程中，是否改变了相同键值元素的位置3. 排序算法的比较AlgorithmStable?Inplace?Grow Rate to Sort N ItemsNotesRunning TimeExtra SpaceSelection SortNoYes$N^2$1Insertion SortYesYesBetween $N$ and $N^2$1Base on the inputShell SortNoYes$N^{6/5}$1Quick SortNoYes$NlogN$$lgN$The efficiency is guaranteed by the posibility3-way PartitioningQuick SortNoYesbetween $N$ and $NlogN$$lgN$The efficiency is guaranteed by the posibility, meanwhile it also depens on the inputMerge SortYesNo$NlogN$$N$Heap SortNoYes$NlogN$$N$4. 结论快速排序是最快的排序算法快速排序的时间复杂度为 $\sim cNlogN$ 级别，同时它的 $c$ 也比其他排序算法要小如果稳定性很重要，而空间并不是很紧张，那么归并排序是最好的选择如果空间非常小，那么堆排序是一个不错的选择]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序]]></title>
    <url>%2FAlgorithm%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[1. 介绍快速排序是一种特殊的归并排序，它基于分治策略，将数组分成左和右两部分，然后将他们分别独立排序。数组的切分是很关键的快速排序和归并排序在原理上的唯一不同就是，快速排序的真正比较工作在 递归之前 完成，而归并排序在递归之后完成。2. 切分这是快速排序真正做比较的部分，也就是真正起作用的部分。切分的目标是找到一个元素：它的左边的所有元素都不大于它它的右边的所有元素都不小于它2.1 实现流程一般来说，我们并不能找到这样的元素，所以我们进行以下的操作：随机的选择元素通常来说，选择数组的第一个元素从数组的两端同时开始扫描数组i, j 分别指向数组的两端；i 自增，直到 i 所指元素 a[i] 不小于切分元素 a[lo]；j 自减，直到 j 所指元素 a[j] 不大于切分元素 a[lo]如果元素不在正确的位置，那么就交换它上述的 i, j 都停止后，交换 a[i] 和 a[j]直到这两个指针相遇或者跨越对方，然后将切分元素放到相遇位置。事实上，此时 j 所指的元素就是不大于切分元素的元素；因此，将切分元素 a[lo] 和 a[j] 交换即可让切分元素放入正确位置2.2 实现1234567891011121314151617181920212223242526272829303132333435363738private static int partition(Comparable[] a, int lo, int hi) &#123; int i = lo, j = hi + 1; // The scanner Comparable v = a[lo]; while (true) &#123; // 指针 i 的扫描过程 while (less(a[++i], v)) &#123; if (i == hi) &#123; break; &#125; &#125; // 指针 j 的扫描过程 while (less(v, a[--j])) &#123; // 实际上这个 if 是多余的， // 因为我们的切分元素就在 lo 的位置， // 当 j 位于 lo 的位置时，由于不满足条件， // j 就会停止扫描 if (j == lo) &#123; break; &#125; &#125; //两指针相遇，完成扫描过程 if (i &gt;= j) &#123; break; &#125; // 此时两指针停止，说明 a[i] 和 a[j] 都不在正确位置 // 所以将 a[i] 和 a[j] 交换 exch(a, i, j); &#125; // 扫描完成，将切分元素放入正确位置 exch(a, lo, j); return j;&#125;2.3 注意事项切分在原本的数组中发生事实上， 也可以使用一个辅助数组；但是这样就丧失了相对于归并排序的不需要额外空间的优势不要越界注意检查扫描指针和边界的关系注意保持随机性在快速排序中保持随机性是保证此算法性能的关键注意循环的终止条件 一个程序员常犯的错误就是没有考虑到数组可能包含与切分你元素的值相同的元素，从而导致了循环无法结束；所以在上面的实现中，即使扫描到相同元素也会停止扫描，保证了不会因为重复元素而影响性能注意递归的终止条件如果你不能把切分元素放入到正确的位置（放入到了错误的位置），那么就有可能引起一个无法终止的递归，这是要极力避免的。3. 基本实现1234567891011121314151617public class Quick &#123; public static void sort (Comparable[] a) &#123; // Disable the dependency to the input String // It's very important. StdRandom.shuffle(a); sort(a, 0, a.lenth - 1); &#125; private static void sort (Comparable[] a, int lo, int hi) &#123; if (hi &lt;= lo) return; int j = partition(a, lo, hi); sort(a, lo, j - 1); sort(a, j + 1, hi); &#125;&#125;可以看到，和归并排序一样，快速排序中真正做比较和交换的，实际上是切分这一个过程，而不是 sort() 方法4. 性能快速排序需要 $\sim 2NlnN$ 次的比较和 $1/6$ 的交换在最坏情况下，当输入数组本身就是有序时，快速排序需要 $N^2 / 2$ 次的比较但是通过打乱输入保证随机性可以防止这种情况的发生5. 改进5.1 切换到插入排序对于一些小型数组，插入排序会比快速排序要快，这是由于快速排序使用了递归方法进行排序123456789101112private static void sort (Comparable[] a, int lo, int hi) &#123; if (ho &lt;= lo + M) &#123; Insertion.sort(a, lo, hi); return; &#125; int j = partition(a, lo, hi); sort(a, lo, j - 1); sort(a, j + 1, hi);&#125;5.2 三取样切分快速排序基于切分，如果切分元素选择的好，那么就可以减少切分所用的时间，从而提高算法性能在实践中，我们一般使用三取样，然后取其中位数的形式来选取切分元素1234567891011121314151617private static void sort (Comparable[] a, int lo, int hi) &#123; // 小数组使用插入排序 if (ho &lt;= lo + M) &#123; Insertion.sort(a, lo, hi); return; &#125; // 三取样获取切分元素 int m = medianOf3(a, lo, lo + (hi - lo) / 2, hi); swap(a, lo, m); int j = partition(a, lo, hi); sort(a, lo, j - 1); sort(a, j + 1, hi);&#125;三取样，即选取数组头部、尾部和中间位置的元素6. 三向切分的快速排序对于有大量重复性元素的数组，我们采用这个算法，实际上属于快速排序的一种改进形式。6.1 实现原理使用 2 个指针 (lt,gt)来维护数组的 3 个部分：小于切分元素的指针 lo 和 lt 之间属于这个部分等于切分元素的指针 lt 和 gt 之间属于这个部分大于切分元素的指针 gt 和 hi 之间属于这个部分指针 lt 的左边都是小于切分元素的元素指针 gt 的右边都是大于切分元素的元素指针 lt 和 gt 之间都是等于切分元素的元素6.2 实现过程指针 i 实际上的作用是进行数组扫描；而 lt 和 gt 的工作是进行数组区域的划分。初始状态，lt 在数组头部，i 位于 lt 的后一个位置， gt 在数组尾部当 a[i] 小于切分元素时，交换 a[i] 和 a[lt]，并自增lt 和 i交换过后，i 所指的元素已经被检查过；而为了满足 lt 左边的元素都是小于切分元素的，所以 lt 要增加当 a[i] 大于切分元素时候，交换 a[i] 和 a[gt]，并自减 gt此时，由于 i 所指的元素是从数组尾部交换来的；并没有经过检查；所以不能自增 i当 a[i] 等于切分元素时候，自增 i由于任何时候， i 都会在 lt 的前面；这种情况下，说明 a[i] 已经处于正确位置；不必进行交换操作当 i 与 gt 相遇时，切分完成此时，所有的元素都经过了 i 的检查，切分完成6.3 具体实现123456789101112131415161718192021222324252627282930public class Quick3way &#123; private static void sort(Comparable a, int lo, int hi) &#123; if (hi &lt;= lo) return; int lt = lo, i = lo + 1, gt = hi; Comararble v = a[lo]; // 切分元素 while (i &lt;= gt) &#123; int cmp = a[i].compareTo(v); if (cmp &lt; 0) &#123; // i 比 v 小 exch(a, lt++, i++); &#125; else if (cmp &gt;0) &#123; // i 比 v 大 exch(a, i, gt--); &#125; else &#123; i++; &#125; &#125; sort(a, lo, lt - 1); sort(a, gt + 1, hi); &#125;&#125;6.4 性能对于含有重复元素的数组，我们有一个值来描述这个数组的信息含量，它叫做香农信息量($H$)H = -(p_1lgp_1 + p2lgp_2 + \cdots + p_klgp_k)$H - The \ Shannon\ information$$p_i - The\ posibillty\ of\ the\ ith\ key\ was\ selected$对于含有重复元素的数组，不存在任何基于比较的排序算法能够保证在 $NH - N$ 次比较之中将 $N$ 个元素排序。其中 $H$ 是由主键值概率定义的香农信息量所以，它证明了三向切分的快速排序是最好的基于比较的算法，信息量最优事实上，对于拥有大量重复键值的数组来说，三向切分的快速排序的时间复杂度是 线性级别的]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速选择算法解 Top K 问题]]></title>
    <url>%2FAlgorithm%2F%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95%E8%A7%A3%20Top%20K%20%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1. Top K 问题Top K 问题就是在序列中寻找到 第 K 个大（或者小）的元素对此，我们可以研究一下它的上界和下界：上界为 $NlogN$Top K 问题只要使用排序就一定能解决，所以其最坏的时间复杂度就是排序的复杂度当 $k$ 的值较小时，如 $1, 2, 3$，则上界为 $N$显然，当 $k = 1$ 时，我们只需要遍历一次数组就能获取最小或者最大元素；当 $k = 2$ 时，我们只需要遍历两次数组就可以完成工作下界为 $N$由 2 可知，我们可以有一个 $N$ 级别的算法；与此同时，我们至少需要遍历一次数组，才能获取到足够的信息来进行 Top K 判断综上所述，我们可以拥有一个 $O(N)$ 级别的算法来解决 Top K 问题，这就是这里介绍的快速选择算法。2. 快速选择算法快速选择算法实际上是快速排序的一个变种，通过使用快速排序的 切分 来达到选择 Top K 的目的。事实上，由于快速排序的切分保证了：所有左边的元素都不大于切分元素所有右边的元素都不小于切分元素因此，实际上切分元素的所处位置，就指示了其 Top K 特性，也就是说：如果切分元素位于第 $h$ 个位置，那么切分元素就是数组中的 Top $h$2.1 算法过程完成切分过程，获取到切分元素位置 $j$若 $k &gt; j$，则对切分元素的右半边数组进行切分若 $k &lt; j$，则对切分元素的左半边数组进行切分重复上述过程，直到 $k = j$2.2 实现123456789101112131415161718192021222324public static Comparable select(Comparable[]a, int k) &#123; StdRamdom.shuffle(a); int lo = 0; int hi = a.length - 1; while(hi &gt; lo) &#123; int j = partition(a, lo, hi); if (k &gt; j) &#123; lo = j + 1; &#125; else if (k &lt; j) &#123; hi = j - 1; &#125; else &#123; return a[k]; &#125; &#125; // 此时我们只有一个元素可以选择 // 说明此时的 a[k] 就是 Top K return a[k];&#125;3. 性能快速选择算法的平均时间复杂度是 线性级别的（即 $O(N)$）其复杂度来源于切分过程，而对于切分过程，每次切分大约会将数组等分，所以需要：$(N + N/2 + N/4 + \cdots + 1 )\sim 2N$ 次的比较一个更精确的公式如下：C_N = 2N + 2kln(N/k) + 2(N - K)ln(N / (N - k))当 $k = N / 2$ 时，有 $C_N = (2 + 2ln2) N$但是与快速排序一样，快速选择的最坏情况下的时间复杂度是 平方级别 的，不过在上面的实现中，由于我们进行了随机洗牌，从而保证了性能。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[归并排序]]></title>
    <url>%2FAlgorithm%2F%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[1. 介绍归并排序是一种递归算法；其主要思想是分而治之策略，通过将一个大数组分成一个个小数组，通过递归地分割，最后归并成一个有序的数组。需要注意的是，比较是在归并的过程中实行的，真正实施比较和排序的方法是归并方法，所以才被称为归并排序。2. 归并过程复制原数组内容到一个新的辅助数组中将辅助数组分为两半分别遍历两半部分，将其元素进行比较，按顺序复制回原数组中2.1 实现1234567891011121314151617181920212223242526272829private static void merge(Comparable[] a, Comparable[] aux, int lo, int mid, int hi) &#123; // i 表示左半边，j 表示右半边 int i = lo, j = mid + 1; // Copy the a[lo...hi] to the assistant array for (int k = lo; k &lt;= hi; k++) &#123; aux[k] = a[k]; &#125; for (int k = lo; k &lt;= hi; k++) &#123; if (i &gt; mid) &#123; // 左边空了 a[k] = aux[j++]; &#125; else if (j &gt; hi) &#123; // 右边空了 a[k] = aux[i++]; &#125; else if (less(auk[j], auk[i])) &#123; // j 比 i 小，将 j 归并到数组中 a[k] = aux[j++]; &#125; else &#123; // i 比 j 小，将 i 归并到数组中 a[k] = aux[i++]; &#125; &#125;&#125;3. 自顶向下的归并排序分治法思想，先排序左半边，后排序右半边，然后将两半归并。3.1 实现12345678910111213141516171819public class Merge &#123; private static Comparable[] aux; public static void sort(Comparable[] a) &#123; aux = new Comparable[a.lenth]; sort(a, 0, a.lenth - 1); &#125; private static void sort(Comparable[] a, Comparable[] aux, int lo, int hi) &#123; if (hi &lt;= lo) return; int mid = lo + (hi - lo) / 2; sort(a, aux, lo, mid); // Sort the left side sort(a, aux, mid + 1, hi); // Sort the right side merge(a, aux, lo, mid, hi); // Merge the result &#125;&#125;在这里 sort() 方法只是对数组进行了简单的分割，而没有进行真正的排序过程在一些改进版本中，会在数组较小时，采用其他排序方法进行排序。3.2 性能对于自顶向下的归并排序，需要 ${1 \over 2} NlogN \sim NlogN$ 次比较和 $6NlogN$ 次数组访问3.3 改进3.3.1 小数组使用插入排序由于对于小数组来说，归并会产生不必要的复制消耗；所以，我们在数组较小时，采用插入排序进行排序过程，而不是全程使用归并算法。123456789101112public static void sort(Comparable[] a, int lo, int hi) &#123; if (hi &lt;= lo + CUTOFF - 1) &#123; Insertion.sort(a, lo, hi); return; &#125; int mid = lo + (hi - lo) / 2; sort(a, lo, mid); // Sort the left side sort(a, mid + 1, hi); // Sort the right side merge(a, lo, mid, hi); // Merge the result&#125;3.3.2 避免不必要的归并过程如果前半边数组和后半边数组 正好构成有序；那就可以直接跳过归并过程，从而节省时间。1234567891011121314151617181920public static void sort(Comparable[] a, int lo, int hi) &#123; if (hi &lt;= lo + CUTOFF - 1) &#123; // 小数组使用插入排序 Insertion.sort(a, lo, hi); return; &#125; int mid = lo + (hi - lo) / 2; sort(a, lo, mid); // Sort the left side sort(a, mid + 1, hi); // Sort the right side if (less(a[mid], a[mid + 1])) &#123; // 如果已经有序，则跳过归并过程 return; &#125; merge(a, lo, mid, hi); // Merge the result&#125;3.3.3 转换数组角色节省拷贝时间由于归并需要先将原数组的内容拷贝到辅助数组中；为什么不直接将原输入数组当成辅助数组呢？所以，我们可以通过将数组的角色调换，以节省拷贝的时间。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051private static void merge(Comparable[] a, Comparable[] aux, int lo, int mid, int hi) &#123; // i 表示左半边，j 表示右半边 int i = lo, j = mid + 1; // 原来的拷贝数组的代码不见了 // 现在，aux 和 a 角色互换 for (int k = lo; k &lt;= hi; k++) &#123; if (i &gt; mid) &#123; // 左边空了 aux[k] = a[j++]; &#125; else if (j &gt; hi) &#123; // 右边空了 aux[k] = a[i++]; &#125; else if (less(auk[j], auk[i])) &#123; // j 比 i 小，将 j 归并到数组中 aux[k] = a[j++]; &#125; else &#123; // i 比 j 小，将 i 归并到数组中 aux[k] = a[i++]; &#125; &#125;&#125;private static void sort(Comparable[] a, Comparable[] aux, int lo, int hi) &#123; if (hi &lt;= lo) return; int mid = lo + (hi - lo) / 2; // 注意，下面 aux 和 a 的顺序互换了 sort(aux, a, lo, mid); // Sort the left side sort(aux, a, mid + 1, hi); // Sort the right side merge(a, aux, lo, mid, hi); // Merge the result &#125;&#125;public static void sort(Comparable[] a) &#123; aux = new Comparable[a.length]; for (int i = 0; i &lt; a.length ; i++) &#123; aux[i] = a[i]; &#125; sort(a, aux, 0, a.length - 1);&#125;4. 自底向上的归并排序它的主要思想是通过不断归并小数组，从而得到一个有序的大数组。注意与其不同的是，自顶向下是将整个数组分为左右半边分别处理，而这里的方法是将整个数组都打散为小数组之后再行合并。4.1 实现1234567891011121314public class MergeBU &#123; private static Comparable[] aux; public static void sort(Comparable[] a) &#123; int N = a.lenth; aux = new Comparable[N]; for (int sz = 1; sz &lt; N; sz = sz + sz) &#123; for (int lo = 0; lo &lt; N - sz; lo + = sz + sz) &#123; merge (a, log, lo + sz - 1, Math.min(lo + sz + sz - 1, N - 1)); &#125; &#125; &#125;&#125;注意这里使用了循环的版本，而不是递归的版本4.2 性能对于一个长度为 N 的数组，自底向上的归并排序需要 ${1 \over 2} NlogN \sim NlogN$ 次比较和最多 $6NlogN$ 次的数组访问5. 比较当数组长度为 2 的幂的时候，这两个方法需要的开支是相同的它们的时间复杂度的增长级别是相同的，数组访问的增长级别也是相同的自底向上的归并排序适合于使用链表作为数据结构的数据，由于它只需要调整数组链接即可，而不需要去创建新的链表节点由于自底向上使用的是循环算法，一般来说都要比使用递归算法的自顶向下的归并排序要快6. 展望归并排序是基于比较的排序算法中渐进最优的归并排序确保了 即使在最坏情况，所需要的最少比较次数都是 $\sim NlogN$。由于没有一个基于比较的排序算法能保证所需要的最少次数都比 $log(N!)$ 要少，由于 $log(N!) \sim NlogN$，所以归并排序是渐进最优的基于比较的排序算法基于比较的排序可以由决策树来描述。树的高度 $h$ 即为所需要进行的比较次数，由排列原理可知，$N$ 个元素有 $N!$ 中排序方式，一个决策树的叶子个数必须要能容纳下 $N!$ 中排序结果，否则将无法完成排序。因为如果不能容纳下所有的结果，一旦输入改变，那么得出的排序结果就可能是错误的。所以一棵比较算法的决策树，至少有 $N!$ 个叶节点，而高为 $h$ 的树具有最多叶节点个数为 $2^h$，则有：2^h \ge leaves \ge N! \\ \Rightarrow \ h \ \ge \ lg(N!) \sim NlogN]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Graham Scan 解决凸包问题]]></title>
    <url>%2FAlgorithm%2FGraham%20Scan%20%E8%A7%A3%E5%86%B3%E5%87%B8%E5%8C%85%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[输入一个点集，输出一个构成能容纳所有点的最小多边形的顶点集合1. Graham scan选择一个具有最小 y 坐标的点 p，如果有多个点，则选择最左边的点（x 坐标最小）将其他点按照 p -&gt; i 向量的极角(polar angle) 排序极角即为向量与 X 轴正向 的夹角按顺序考虑其余点，如果出现顺时针的拐角则将该点忽略2. 要点2.1 寻找原点将点按照 y 坐标优先进行排序；即，先看 y 坐标，后看 x 坐标。2.2 按照极角排序使用基于逆时针转角（CCW）的方法如果 $q_1$ 在 $p$ 上方，$q_2$ 在 $p$ 下方，则 $q_1$ 极坐标较小如果 $q_1$ 在 $p$ 下方，$q_2$ 在 $p$ 上方，则 $q_1$ 极坐标较大否则，根据 $p \to q_1 \to q_2$ 的逆时针转角(ccw(p, q1, q2)) 确定极坐标大小上述函数中，ccw(p, q1, q2) 返回 1，则 $q_2$ 较大；返回 -1 则 $q_1$ 较大3. 确定逆时针转角(CCW)使用三角形有向面积进行判定2 \times Area(a, b, c) = \begin{vmatrix} a_x & a_y & 1\\ b_x & b_y & 1\\ c_x & c_y & 1\\ \end{vmatrix} = \\ \begin{vmatrix} b_x - a_x & b_y - a_y \\ c_x - a_x & c_y - a_y \\ \end{vmatrix}如果面积为正，则为逆时针如果面积为负，则为顺时针如果面积为 0，则三点共线原理：根据空间向量的右手系可知，当法向量为负时，三点为顺时针；当法向量为正时，三点为逆时针。而平面法向量和两个向量的叉乘正负一致，则可以通过求两个向量的叉乘判断顺逆时针的情况。由向量叉乘的物理含义可知，向量的叉乘就是两个向量所在的平行四边形的面积在三维条件下，叉乘为|a \times b| = \begin{vmatrix} i & j & k\\ a_x & a_y & a_z\\ b_x & b_y & b_z \end{vmatrix}取 $z = 0$ 这一平面，则|a \times b| = \begin{vmatrix} a_x & a_y\\ b_x & b_y\\ \end{vmatrix}到这一步不难看出，上面两倍三角形有向面积的二维行列式表达正是二维空间中向量的叉乘。所以，三角形有向面积的正负就表明了三角形三个点的顺时针和逆时针的特性。4. Corner Case主要出现的 Corner Case 有：点数量不够只有至少不共线的 3 个点才能构成凸包共点问题有多个点重合共线问题有多个点的共线问题点集为空等其他情况5. 实现流程对于以上 Corner Case 有如下处理方法：检查 null检查点集数量3 个点及以上才有可能产生凸包遍历排序后的点集，直到第一个不与第一个点重复的点，如果所有点都重复，则退出由此可去除原点重复问题遍历剩下的点集，直到第一个与前两个不共线的点，将其的前一点作为凸包第二顶点前一点 即与原点共线的 最后一个点通过 CCW 来计算逆时针转角，抛弃小于等于 0 的点由于 CCW 可以表示共线情况，可以通过只要大于零的点即可避免途中出现的共线情况实际上，由于 CCW 使用三角形面积进行计算，所以，也可以解决共点问题]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本排序算法]]></title>
    <url>%2FAlgorithm%2F%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[成本模型：一般为元素比较和交换的次数。如果不需要比较和交换，那么我们计算数组访问的次数1. 选择排序找到最小元素把它和第一个元素相交换在剩下的元素中寻找最小元素将其和第二个元素交换重复以上步骤，直到数组排序完毕（元素指针走到数组末尾）1.1 性能在一个长度为 $N$ 的数组中，它需要 ${N^2}/{2}$ 次的比较和 $N$ 次的交换特点：所需时间和输入模型无关数据的移动是最少的2. 插入排序插入排序的主要思想是在数组的无序部分取元素插入到有序部分中，从而逐步构建有序。举一个按照升序排列的例子将 $a[i]$ 和 $a[0]$ 到 $a[i - 1]$ 中所有比它小的元素依次交换保证在 $a[i]$ 的左边，元素总是有序的当 $i$ 指针到达数组末尾的时候，排序就完成了。2.1 实现1234567891011public static void sort(Comparable[] a) &#123; int N = a.length; for (int i = 0; i &lt; N; i++) &#123; for (int j = i; j &gt; 0 &amp;&amp; less(a[j], a[j-1]); j--) &#123; // Compare a[i] with the items which is at its left side. exch(a, j, j-1); &#125; assert isSorted(a, 0, i); &#125; assert isSorted(a);&#125;2.2 性能此算法的性能和输入有关。如果输入的序列已经是部分排序的，那么使用这个算法将会比较快；但是由于存在嵌套的 for 循环，在最坏情况下仍然需要 $N^2$ 次交换2.3 优化2.3.1 使用移动代替交换可以在上述算法实现上进行进一步调优。可以简单的将大的元素往右移动，从而空出一个正确的位置，将所需元素插入即可；而不是每次都要交换一次元素。这个调优将能节省一半的数组访问开支12345678/*** Use this method to replace the exac(),* the spare space will be left,* when the movement was completed,* just insert the specific item into the room.*/a[j] = a[j - 1]2.3.2 使用二分查找由于是在有序部分寻找恰当位置插入，可以使用二分查找提高搜索效率12345678910111213public int binaryIndex(int[] arr, int lo, int hi, int key) &#123; int mid; while (lo &lt;= hi) &#123; mid = lo + (hi - lo) / 2; if (arr[mid] &lt; key) &#123; lo = mid + 1; &#125; else if (arr[mdi] &gt; key) &#123; hi = mid - 1; &#125; else &#123; return mid; &#125; &#125;&#125;3. 希尔排序希尔排序是基于插入排序的一种排序算法。其基本思想是让元素在 $h$ 步长中有序如果 $h$ 很大，那么我们就可以将一个元素一次性移动很远3.1 实现1234567891011121314151617181920212223242526public class Shell &#123; public static void sort(Comparable[] a) &#123; // Increasing order of a[] int N = a.lenth; int h = 1; while (h &lt; N/3) &#123; // From N/3 to reduce the h // 1, 4, 13, 40, 121, 364, 1093, ... h = 3 * h + 1; &#125; while(h &gt;= 1) &#123; // Make the array h ordered for(int i = h; i &lt; N; i++) &#123; // Insert the a[i] into the a[i - h], a[i - 2*h] , a[i - 3*h] for(int j = i; j &gt;= h &amp;&amp; less(a[j], a[j - h]); j -= h) &#123; // Replace j-- as the j -= h exch(a, j, j-h) &#125; &#125; h = h / 3; &#125; &#125;&#125;3.2 性能希尔排序比插入排序和选择排序都要快；但是我们并不能给出一个准确的数学分析证明它的精确增长函数但是一个重要的结论已经被证明：希尔排序的复杂度达不到平方级别]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Head 标签内容]]></title>
    <url>%2FHTML%2FHead%20%E6%A0%87%E7%AD%BE%E5%86%85%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[1. 概述&lt;head&gt; 标签中保存的是网页的 元数据 内容，不会在页面上展示；下面简单介绍几个 &lt;head&gt; 标签中比较重要的子标签。2. &lt;title&gt; 标签这个标签保存着网页的标题内容，一般是网页的名字；会显示在浏览器的标题栏，在收藏网页的时候作为默认名字进行存储。&lt;title&gt; 标签还可以用于 SEO，提升搜索排名3. &lt;meta&gt; 标签这是 &lt;head&gt; 中比较重要的一个子标签内容，包含了网站的元数据，其中主要包括：charset 编码，可以用 &lt;meta&gt; 的 charset 属性来指定1&lt;meta charset="utf-8"&gt;通过这种方法，可以硬指定网站使用的编码，如果浏览器强制使用的编码不正确，则可能无法正确渲染网页。元数据信息，通过 name 和 description 属性来描述name 描述的是元数据的名字，description 属性才是真正的元数据内容。可以使用元数据内容为网站进行 SEO，或者提供网站维护者的信息。特殊的元数据可以通过一些特别的元数据描述来对特定的网站链接进行富文本优化。如可以使用 og 前缀，让网站在 Facebook 的链接进行富文本化，显示网站 logo 和内容。4. &lt;link&gt; 标签&lt;link&gt; 标签主要有以下的作用：用于表示网站 logo可以使用 rel 属性指定为 icon，然后使用 herf 链接到图片用于链接外部 CSS属于最常用功能，通过 rel=&quot;stylesheet&quot; 和 herf 来指定需要链接的外部 CSS 表5. &lt;script&gt; 标签用于指定页面使用的 JS 内容可以直接包含 js 文本，也可以通过 src 属性来指定外部 .js 文件6. 指定语言这虽然不是 &lt;head&gt; 标签的内容，但是语言作为网页元数据的一种，有必要在这里说明。可以通过给任何的标签添加 lang 属性来设置语言，如果要给整个页面指定语言，则在 &lt;html&gt; 标签中添加 lang 属性即可。1&lt;html lang="zh_CN"&gt;]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并查集算法分析]]></title>
    <url>%2FAlgorithm%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[并查集算法是用于判断互联网中我们是否需要新建立一条连接来使整个网络连通。即，元素的连通性问题。1. 概念连接连接是一种等价关系，它意味着以下特点：自反性：$p$ 连接着 $p$对称性：如果 $p$ 和 $q$ 相连，那么 $q$ 与 $p$ 相连传递性：如果 $p$ 与 $q$ 相连，$q$ 与 $r$ 相连，那么 $p$ 与 $r$ 相连2. Union-Find 的实现1234567891011121314151617public static void main(String[] args) &#123; int N = StdIn.readInt(); //read the Number of CONTACTS UF UF = new UF(N); //Initialize the data structure while(!StdIn.isEmpty()) &#123; int p = StdIn.readInt(); int q = StdIn.readInt(); if(uf.connected(p,q)) &#123; //If it is connected, ignore it continue; &#125; uf.uinon(p,q); //Merge the contacts StdOut.println(p + " " + q); &#125;&#125;3. union() 和 find() 的实现基于 id[] 数组，他们的每一个索引都是一个节点3.1 Quick-Find 算法这个版本需要 $(N + 3)(N - 1) \sim N^2$ 次数组访问1234567891011121314151617181920212223public int find (int p) &#123; return id[p];&#125;public void union(int p, int q) &#123; // Merge p and q into the same component int pID = find(p); int qID = find(q); // If the p and q are at the same component, // do nothing and return. if(pID = qID) &#123; retrun; &#125; // Rename the p component to the q component for(int i = 0; i&lt; id.lenth; i++) &#123; if(id[i] == pID) &#123; id[i] = qID; &#125; &#125; count --; // Decrease the component counter&#125;3.2 Quick-Union 算法使用树作为基本结构以避免每次调用 union() 时，都要扫描整个数组3.2.1 基本概念使用树作为基本的数据结构每一个节点的 id[] 元素就是另一个节点的名字，我们认为它们之间建立了一个连接例如， $p$ 和 $q$ 是两个节点，如果 $p$ 和 $q$ 连接，那么 id[p] == q如果 id[p] == p，那么我们称 $p$ 是一个根节点3.2.2 实现123456789101112131415161718192021222324private int find(int p) &#123; // Find the root of the contact's component while (p != id[p]) &#123; p = id[p]; &#125; return p;&#125;public void union(int p, int q) &#123; // Merge the root contact of the p's component and the q's component int pRoot = find(p); int qRoot = find(q); // If the two components' root are the same, return. if (pRoot == qRoot) &#123; return; &#125; // Set the p's tree links with q's tree. // Now, the qRoot is the father contact of the qRoot. id[pRoot] = qRoot; count --;&#125;3.3.3 性能虽然一般来说，并查集算法比 Quick-Find 算法要快，但是在最坏情况下，并查集算法仍然需要 $2(1 + 2 + \dots + N) \sim N^2$ 次的数组访问原因在于， union() 方法是随机的连接两棵树，就有可能将大树连接到小树上，增加树的深度。如果所有的树都是大树连接到小树上，那么树就变成了线性表，此时即为最坏情况。4. 加权的并查集算法我们通过给树增加权值，从而可以避免上面的随机连接的情况。权值即为树的大小。4.1 实现1234567891011121314151617181920212223242526272829303132333435363738394041public class WeightedQuickUnionUF &#123; /** * We need a new array to count the tree's size * The index is the root contact * The value is the corresponding size of the tree * Baically, we use the root contact to stand for the tree */ private int[] sz; .... public WeightedQuickUnionUF (int N) &#123; ... sz = new int[N]; for (int i = 0; i &lt; N; i++) &#123; // Initialize the sz[] as 1. // No one was linked at the first. sz[i] = 1; &#125; &#125; ... public int find(int p) &#123; // Find the root contact while (p != id[p]) &#123; p = id[p]; &#125; retrun p; &#125; public void union(int p, int q) &#123; ... if (sz[i] &lt; sz[j]) &#123; // Link the smaller tree's root contact to the bigger one id[i] = j; sz[j] += sz[i]; // Adding the weight(or size) of the component &#125; else &#123; id[j] = i; sz[i] += sz[j]; &#125; &#125;&#125;4.2 性能通过使用加权算法，构造的森林中，任意节点的深度最多为 $logN$ footnote4footnote4. 在算法中 $logN$ 和 $log_2{N}$ 等价 &#8617;5. 路径压缩的并查集算法更进一步，我们可以在遍历到一个节点的时候，就和它的根节点连在一起，由于我们只检查连通分量（即根节点）是否相连，所以上述做法在 Union-Find 问题中是没有副作用的，同时可以极大地减少树的深度，从而提升算法性能。5.1 实现 1 ——两个循环使用第二个循环，将寻找根节点路径上的所有的点都与根节点直接连接。1234567891011121314151617public int find(int p) &#123; int pParent = p; int pRoot = p; // Find the p's root while(pRoot != id[pRoot]) &#123; pRoot = id[pRoot]; &#125; while (id[p] != p) &#123; pParent = id[p]; id[p] = pRoot; p = pParent; &#125; return pRoot;&#125;5.2 实现 2 ——将点指向其爷爷节点一个更为简单的实现，直接将节点与其爷爷节点连接即可；虽然效果没有 实现 1 好，但是在实际运用中，两者效果相差不大，而且实现 2 只需要一行代码即可，更具备工程意义。123456public int find(int p) &#123; while(p != id[p]) &#123; id[p] = id[id[p]]; p = id[p]; &#125;&#125;5.3 性能这个算法的性能是一个 $arc$ 函数，十分接近常数。6. 比较]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[背包，队列和栈]]></title>
    <url>%2FAlgorithm%2F%E8%83%8C%E5%8C%85%EF%BC%8C%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88%2F</url>
    <content type="text"><![CDATA[它们都是一些数据对象的集合1. 特点1.1 背包不支持 删除元素使用其来收集元素，遍历和递归它们元素的顺序是不确定的1.2 队列(先进先出)这里所说的队列指的是先进先出的队列。数据元素相对此集合的顺序是先进先出队列能收集数据，同时保持它们的相对顺序1.3 栈正好与队列相反，数据元素在栈中是后进先出的。栈也会保持数据元素的相对顺序1.4 例子：算数表达式的表示法使用两个栈来表达算数表达式当接收到一个算数表达式的时候：将数值压入数值栈将操作符压入操作符栈忽略左括号当遇到右括号的时候，弹出一个操作符，和所需要的数值，并且将计算结果压入数值栈2. 实现2.1 使用数组实现栈push() 方法需要检查当前栈是否是满的，如果满，则进行扩容resize() 方法会将当前数组的空间加倍（或减半）pop() 方法需要检查当前栈的大小是否小于数组的 1/4，如果成立，则将数组的空间减少为它的一半。需要防止对象游离，当数据对象被弹出后，将其声明为 null缺点时间复杂度与数组的大小相关所需要的空间是不可预知的如果当前栈的大小小于数组的 1/4，那么即使 pop() 方法使其减少了，它仍然比当前栈的大小还要大一倍，所以我们依旧有空间储存数据，为了防止空间的浪费，将数组的空间减少。当一个数据对象被弹出栈后，它就再也不会被栈使用了，但是数据的引用依旧存在，所以 Java 不会将这块内存回收。这种情况就被叫做对象游离2.2 链表链表是一个递归的数据结果，它可以是空，或者是一个指向一个节点的引用；这个节点储存一个数据元素和一个指向下一个节点或列表的引用；Node（节点）类经常被用于内部类。2.2.1 创建12345private class Node&#123; Item item; Node next;&#125;只要声明一个 Node 变量，我们就能表示一个链表因为 Node 被用作内部类，所以我们能直接地声明其成员。123456789101112Node first = new Node();Node second = new Node();Node thrid = new Node();//Itemsfirst.item = "to";second.item = "be";thrid.item = "or";//Nextsfirst.next = second;second.next = thrid;2.2.2 在头部插入使用另一个引用（例如 oldfirst） 来储存头结点，然后建立新节点来储存数据，然后将 next 指向头结点2.2.3 从头部删除将头指针first直接指向 first.next 即可Java 的 garbage collector 会将内存回收。2.2.4 在尾部插入就像在头部插入一样，用一个另外的引用 oldlast 来保存尾部节点，然后建立一个新的节点来储存数据，然后将 oldlast.next 声明为 last注意，对于单链表，尾部节点的引用可能要通过从头结点的层层遍历才能取到，这也是为什么一般仅使用头节点来作为主要的操作节点。2.2.5 在其他地方插入和删除进行这个操作，我们必须要拿到所需要插入位置的前一个节点的信息来辅助我们的插入删除操作，因此我们需要遍历 链表来取得指定插入位置的前一个位置。2.2.6 遍历一般来说，我们使用 foreach 语句来进行遍历操作。使用这个语句的类必须要实现 Iterable 和 Iterator 接口来返回一个迭代器和定义迭代方法。但是对于链表这种简单结构来说，我们只需要使用一般的 for 语句即可。123for(Node x = first; x != null; x = x.next) &#123; //handle x.item&#125;3. 链表的使用使用链表可以：处理任何数据需求的空间仅仅和集合的大小成正比时间复杂度和集合的大小无关链表的插入和删除操作仅仅是变量的赋值，以及对象的构建，它们的时间复杂度都是常数级别 的3.1 实现栈将链表的头部设定为栈顶当压入数据的时候，我们在头部插入数据元素当弹出数据的时候，我们在头部删除数据元素选择链表头部而不是尾部进行操作的原因：链表的插入和删除操作都是在一端进行的；链表的尾部元素一般不好获取，特别是对于单链表而言，如果采用尾部作为栈顶，那么当删除栈顶元素之后，我们无法很快的获取新的栈顶元素的引用（因为要从头部进行遍历，或者维护两个指针，这都是不必要的）；而采用头部作为栈的顶部，仅仅需要一句声明语句 newTop = top.next; 即可获取到新的栈顶元素。3.2 实现队列设定链表的头部为队列的头部，链表的尾部为队列的尾部。当插入元素时，在尾部插入数据。当删除元素时，在头部删除数据。由于队列插入和删除的位置不同，在尾部删除元素很麻烦，但是相应的插入操作却变得十分简单，仅需要改变其 next 域即可，而不是类似删除操作还要返回前一个数据的引用。3.3 背包的实现将栈或队列的 pop() 操作去掉，就是一个背包结构。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法分析]]></title>
    <url>%2FAlgorithm%2F%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[1. 观察运行程序，然后使用时间计算器来计算时间的使用。使用大数据来猜测和验证数学模型2. 时间模型时间使用的多少一般和以下因素有关：每个操作的所需时间每个操作使用的频率2.1 估计我们使用 $\sim f(N)$ 来代表，当 $N$ 增长时，所用时间的结果和 $f(N)$ 的比值为 $1$，使用 $g(N) \sim f(N)$ 来代表当 $N$ 增长时，结果和 $g(N)/f(N)$ 的比值为 $1$2.2 内循环内循环指的是程序执行时，最频繁的操作程序的时间复杂度一般都取决于内循环2.3 成本模型成本模型指的是基本的算法操作例如 3-Sum 问题，其成本模型是数组访问的次数2.4 确定成本模型的步骤确定输入模型和问题规模确定内循环根据内循环来确定成本模型根据输入模型，来确定操作的频率和次数2.5 增长级别的分类常数级别大多数的 Java 基本操作 都是常数级别的。对数级别比常数级别稍慢，例如 二分查找线性级别单独的 for 循环线性对数级别例如归并排序和快速排序平方级别两个嵌套的 for 循环，例如选择排序，插入排序，冒泡排序都是平方级别的立方级别三个嵌套的 for 循环是立方级别的，例如 3-sum 的暴力解法指数级别非常慢，尽量避免去使用这种级别的算法2.6 设计更快的算法使用分治策略例如 3-sum 问题，我们可以先尝试解决较为简单的 2-sum 问题3-sum 问题：即给出一个数和给定的数据集合，在数据集合中寻2-sum 问题2-sum 问题即为找到所有的数对，它们的和为 $0$，我们注意到，当 $A + B = 0$ 成立时，说明，两个数互为相反数，即 $A = -B$所以我们可以采取 二分查找 的方法来查找数据的相反数，从而查找到数对。这样，我们就将时间复杂度由 平方级别($O(N^2)$) 减少到了 线性对数级别($O(NlogN)$)注意，如果二分查找返回的 $j$ 在 $0$ 和 $i$ 之间，那么说明我们查找到了重复数据，（由于我们是对整个数组进行遍历，所以数据就会出现重复）应该不增加计数。3-sum 问题和 2-sum 问题一样，当 $-(a[i] + a[j])$ 在数组中（不是 $a[i]$ 也不是 $a[j]$ ）时，整数对 $(a[i], a[j])$ 是三元组的一部分。由此，通过分治策略和使用 二分查找，我们将 $N^3$ 级别的问题降低到了 $N^2logN$ 级别。2.7 根据增长数量级做出的预测| Describe | Function | Modulus is 2 | Modulus is 10 | Handle the 10N | Handle 10N in 10 times faster||————|———|———|———-|——-|—mathjax: true—-|| Linear| $N$|2|10| a day| couples of hours|| Linearrithmic|$NlogN$|2|10|a day | couples of hours|| Quadratic| $N^2$| 4| 100| a few weeks| a day|| Cubic| $N^3$ | 8 | 1000 | a few months | couples of weeks|| Exponential| $2^N$ | $2^N$ | $2^{10N}$ | forever | forever2.8 注意事项大常数一般来说，我们认为 $2N^2 + cN$ 是 $\sim 2N^2$ 的，但是当 $c$ 为 $10^3$，或者 $10^6$ 的时候，这种估计是不正确的。非决定性的内循环由于错误的内循环，导致了错误的成本模型，从而导致了错误的分析结果指令时间对于当今的现代计算机，由于缓存技术的使用，使得访问大数组的非相邻元素所需的时间可能会很长系统因素当你在运行算法分析程序的时候，可能你的电脑并不只是在运行这一程序，同时还运行着其他程序，这样的话就有可能导致算法分析的结果的不正确。不分伯仲比较执行相同任务的程序时，通常会出现一个情形下这个算法比较好，另一个情形下另一个算法比较好的情况。对于输入的强烈依赖在 3-sum 问题中，如果我们将问题改成 是否存在和为0的三个数？ 如果第一组的三个数都是 0，那么时间复杂度为常数级别，如果输入中不存在这样的数，则时间复杂度为 立方级别在这种情况下，我们通常使用 $Tw$ （最坏情况的时间复杂度） 和 $T{av}$ （平均时间复杂度） 来表示这种情况多个问题参量成本模型并不总是单因素函数，也有可能是多因素函数。例如使用二分查找来进行白名单问题分析时，时间复杂度和 $MlogN$ 成正比其中白名单有 $N$ 个整数，输入中有 $M$ 个整数3. 内存模型在 Java 中，内存的使用一般会被填充为 8的倍数3.1 对象Integer一共需要 24 byte16 bytes 为对象本身的开销4 bytes 的 int 值对象的引用，一般为 内存地址，使用 8 byte3.2 链表Node(inner class)一共 40 byte16 bytes 为对象的开销2 * 8 bytes 的引用（Node 中有两个引用）当作为内部类时，需要一个额外的指向外围类的引用数据的开销3.3 数组在 Java 中，数组被实现为了对象数组24 bytes 的头信息16 bytes 对象开销4 bytes 填补开销3.4 String40 bytesObject cost, 16 bytesreference, 8 bytes3 int, 12 bytesoffsetcounterhash$\Delta$ The subString当你调用 substring() 方法时， 它重新创建了 String 对象， 但是并没有创建 value[] 数组, 这个数组被存在常量区所以，subString() 所需的内存是一个常量4. 展望不成熟的优化是万恶之源Premature optimization is the root of all evil如果运行时间已经足够快了，那么对运行时间的改进就不值得了不值得花费 2 倍的开发时间来提高 10 % 的性能但是我们当我们处理大型问题的时候，我们的确需要好的算法，好的算法在大规模问题中能带来巨大的收益]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络考试速记]]></title>
    <url>%2FReviews%2FComputerNetwork%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E8%AF%95%E9%80%9F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1. OSI 参考模型从低到高：物理层通信信道的原始 比特，机械、电子、时序、物理介质数据链路层数据帧，控制对共享信道的访问（介质访问控制子层）网络层控制子网的运行，数据包的端到端传输，路由算法，处理拥塞传输层向会话层提供服务，为应用层提供抽象，与网络层一起处理拥塞会话层令牌管理，同步，崩溃恢复表示层传递信息的语法和语义，统一不同计算机的数据格式并提供抽象接口。应用层OSI 最顶层，通常包含用户需要的各种协议，如 HTTP2. TCP/IP 参考模型链路层实际上是一个接口，而不是层互联网层大致对应 OSI 网络层传输层OSI 中的传输层应用层TCP/IP 中没有会话层和表示层，应用层将其整合了。与 OSI 的对比OSITCP/IP应用层应用层表示层&nbsp;会话层&nbsp;传输层传输层网络层互联网层数据链路层&nbsp;物理层&nbsp;OSI 先有层级，后有协议；TCP/IP 先有协议，后有层级3. 信息传输介质磁介质低成本，短途运输速率高，延迟高双绞线即常用的网线。低噪声，低延迟，拥有足够的带宽，是目前应用最为广泛的信息传输介质同轴电缆带宽比双绞线大，抗噪性较好，主要用于 长距离信息运输电力线布置方便；但电源信号专用，频率不符，目前应用低光纤超高带宽，主要用于长距离通信光纤相对于铜线，具有高带宽，低衰减，重量轻，部署难，接口费用高 的特点4. 多路复用频分复用将频谱分为几个频段，每个用户 完全拥有 其中一个频段进行通信。OFDM 已经广泛应用于 802.11、有线电视网络和电力线网络时分复用用户以循环的方式轮流工作，周期性地获得 整个带宽 非常短的一个时间TDM 广泛用于电话网络和蜂窝网络中码分复用通过码片来提取叠加信号中的信息。通过不同的码片序列来提取对应的信息，并将其他的信息都当做噪声CDMA 被用于卫星通信和蜂窝网络以及有线电视网络5. 数据链路层数据链路层操作的对象是数据帧，向网络层提供服务，进行差错控制和流量控制。5.1 分帧字节长度通过计算字节长度来分帧不准确，很少使用填充字节标志帧变长某些情况会干扰帧分界填充比特确保最小转换密度，有助于物理层保持同步USB 使用该技术物理层编码违禁法通过使用一些物理层的违法编码或者冗余字节来进行分帧不需要填充数据802.11 和以太网综合使用了上述方法（不包括字节长度）5.2 差错检测和修正5.2.1 纠错码——不可靠信道(WIFI)海明码纠错存储器检测 $d$ 个错误，需要距离为 $d + 1$ 的编码方案卷积码GSM 使用里德罗门码纠错能力强，处理突发错误能力强应用于光盘，卫星通信低密度奇偶校验纠错性能最佳使用于 802.11，数字广播，万兆以太5.2.2 检错码——可靠信道(光纤)奇偶校验只能检查一处错误校验和16 位字节和，可以检验奇偶校验检查不出的错误循环冗余检验多项式检验最可靠，使用最广泛使用于局域网和点到点连接5.3 回退 N 步与选择重传停等协议直到接收到确认后才发下一帧回退 N 步不需要等到回报才发下一帧；而是直接发 $w$ 帧；如果 $w$ 个帧都没有回报，则堵塞。出错时，直接丢弃，发送方回退，重新发送错误之后的帧。错误多时，影响带宽选择重传相比回退 N 步，不是由发送方回退 N 个窗口后重发；而是由接收方缓存接下来的帧，直到错误帧重发后，进行合并。两者的流量控制通过滑动窗口来进行流量控制。只有接收方的窗口滑动时（回报），发送方的窗口才能滑动回报没有拿到，则发送方的窗口阻塞，如果超时，则尝试重发6. MAC 子层MAC： Medium Access Control，介质访问控制子层用途： 用于确定多道访问中的下一个使用者使用原因多个网络使用者交流无序会导致混乱和信道拥塞，为了确定消息发送和传输测序，保证信道畅通。6.1 信道分配静态分配用户固定一个信道无法解决突发流量问题动态分配假设单信道是核心；冲突可观察是最基本的的假设6.2 多路访问协议6.2.1 ALOHA6.2.1.1 纯 ALOHA发送不受限制冲突的帧将损坏等待随机时间后重发最好的信道利用率为 18%6.2.1.2 分槽 ALOHA用户只能在下一个时间槽的开始时刻发送帧即帧的发送必须等待时间槽利用率： 37% 空槽，37% 成功， 26% 冲突6.2.2 载波侦听多路访问称为 CSMA 协议。CSMA： Carrier Sense Protocol6.2.2.1 坚持和非坚持1-坚持侦听信道，直到信道空闲冲突发生，等待随机时间后重发冲突的发生概率和信道带宽延迟积有关非坚持侦听信道，如果信道忙，随机等待其余与 1-坚持 相同6.2.2.2 带冲突检测的 CSMA称为 CSMA/CD （CSMA with Collision Detection）冲突检测：传输时 侦听信道，如果读回的信号不同于其发出的信号特征，则发生了冲突。与普通 CSMA 的不同：CSMA/CD 会在检测到冲突后，立即停止帧的发送；而普通的 CSMA 不会6.2.3 无冲突协议位图协议通过在竞争槽中的对应槽插入位来向网络中广播站的发帧意愿高序号的站比低序号的站平均等待时间要短令牌协议令牌的拥有者具有发帧权限发帧与否，都必须将令牌传到下一站不存在高序号站和低序号站的差别二进制倒计数通过逻辑或来得到位时间站通过检测位时间和地址对应位的相同与否，来确定是否获取信道6.2.4 有限竞争协议低负载下，竞争有利于提高延迟；高负载下，采用无冲突技术能获取更好的信道效率。通过给某些站赋予更高的成功获取信道的概率，或者增减时间槽内的站数量来实现。6.2.5 无线局域网冲突问题由于无线覆盖范围的差别，站在开始传送时，无法知道接收方是否有无线电活动。隐藏终端问题由于竞争者离得太远，无法检测到潜在的竞争者暴露终端问题发送方相距太近，而接收方不在危险范围内，导致信道的浪费解决办法称为 MACA （Multiple Access with Collision Avoidance） 冲突避免多路访问。6.2.6 冲突避免多路访问发送方在发送帧之前，先发送一个 RTS 短帧；接收方回报一个 CTS 短帧。其他站检测到这两个帧，保持静默。RTS： Request To SendCTS: Clear To Send6.3 以太网6.3.1 MAC 协议MAC 地址有 6 字节， 48 位8 字节6620-15000-464前导码目标地址原地址类型数据填充校验和以太网限制有效帧至少 64 字节长防止由于帧过短导致传输时间短，从而引起冲突误判为非冲突二进制指数后退冲突后，在对应区间选择等待的时间槽数量 ($0 \sim 2^i -1 $)，最大为 1023冲突少时，确保低延迟；冲突多时，确保解决问题的时间间隔6.3.2 交换机和集线器的区别交换机：全双工电缆不存在冲突问题通过缓冲来解决输出端口的冲突问题6.4 802.11 WiFi MAC 协议无线电存在信号弱，半双工特性，冲突代价大，所以试图去避免冲突。采用冲突避免 CSMA (CSMA/CA)在发送前侦听信道，和冲突后指数后退(等待时间槽)通过 ACK 来确认推断冲突是否发生使用 NAV 来确认信道忙的时间段NAV 是在站自身管理的；在帧中夹带 NAV 信息，但是不单独传输 NAV帧结构：2 字节266620-23124帧控制持续时间接收地址发送地址远端地址序号数据帧检验序列帧控制结构：2 比特2411111111协议版本类型子类型去往 DS来自 DS更多段重传电源管理更多数据受保护的顺序WiFi 定义了关联服务和重新关联服务。关联服务用于连接 AP；重新关联服务用于改变首选 AP。WiFi 连接前必须验证，使用 WPA26.5 网桥6.5.1 网桥转发算法如果目标地址端口和源端口相同，丢弃该帧如果去往目标地址的端口与源端口不同，转发如果目标端口未知，进行泛洪，转发到除了源端口的所有其他端口6.5.2 生成树网桥是为了解决由于网桥间存在 冗余链路 导致的 泛洪循环 问题。通过确定根，通过根生成一个生成树来确保泛洪算法不出现循环。6.6 VLAN由于安全性，负载均衡，广播风暴问题，需要将 LAN 在内部分成多个 LAN 并进行动态调整，此时就出现了 VLAN。通过虚拟的网桥来进行连接和交换， VLAN 通过在帧中加上 VLAN 协议(包括优先级和 VLAN 标识符) 来确定设备位置。VLAN 兼容旧设备，在最后的 VLAN 端口处，有 VLAN 的帧会被还原为原来的普通数据帧。7. 交换设备网关工作在 应用层和传输层路由器工作在 网络层网桥和交换机工作在 数据链路层中继器，集线器工作在 物理层]]></content>
      <categories>
        <category>复习</category>
        <category>计网</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C# Class Basic]]></title>
    <url>%2FCSharp%2FCSharp%20Class%20Basic%2F</url>
    <content type="text"><![CDATA[1. 概述C# 类的基本语法和 Java 无异下面只具体讲讲有区别的地方2. 构造函数链Java 中可以通过在构造函数中使用 this 来调用另一个构造函数，从而实现构造函数的职责委托链条。C# 中则使用 冒号 来保证 this 的优先调用1234567891011// Javaclass Empolyee &#123; Empolyee() &#123; this("Unknown") &#125; Empolyee(String name) &#123; this.name = name; &#125;&#125;123456789// C#class Empolyee &#123; Empolyee(): this("Unknwon") &#123; &#125; Empolyee(string name) &#123; this.name = name &#125;&#125;3. 可选参数当然，在 .NET 4.0 以上可以在构造函数中使用可选参数。可选参数用法和其他方法相同4. 静态构造函数实际上就是 Java 中的 静态初始化块，具体的行为也区别不大。静态构造函数只能有一个静态构造函数不能重载，不接受任何参数静态构造函数在类实例构建和首次调用静态成员时调用静态构造函数会 先于所有构造函数执行不过语法上稍有不同，Java 采用 static 加大括号形式，而 C# 采用在构造函数前面加 static 来实现5.静态类Java 中没有的内容可以在类级别使用 static 关键字，这样的类是 Top-level 的 静态类，具有如下特性：不能使用 new 关键字构建实例只能拥有 static 成员实际上，就是 Java 中的工具类写法。]]></content>
      <categories>
        <category>CSharp</category>
      </categories>
      <tags>
        <tag>CSharp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C# Const and Readonly Field]]></title>
    <url>%2FCSharp%2FCSharp%20Const%20and%20Readonly%20Field%2F</url>
    <content type="text"><![CDATA[1. 概述C# 提供了两种 常量级别 数据，相当于 Kotlin 中的 const 和 lazy value；使用 const 和 readonly 来进行修饰2. Constconst 类型是 编译时常量。const 必须被初始化！与 Kotlin 不同的是 C# 中的 const 除了字面常量以外，还允许使用 null 应用。除此之外，C# 的 const 还允许在局部作用域使用，而 Kotlin 的 const 只允许在 Top-level 使用3. Readonly Field只读字段是一种特殊的 lazy 常量。和 Kotlin 的 lazy-value 不同的是：只读字段可以不被初始化只读字段 只能被显式初始化，或者构造函数初始化如果不被初始化，那么显式字段拥有默认值4. 两者区别C# 中 const 和 readonly 的主要区别在于：const 是 隐式静态的，即可以直接通过类名来调用 const而 readonly 不是隐式静态的。]]></content>
      <categories>
        <category>CSharp</category>
      </categories>
      <tags>
        <tag>CSharp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C# Object Initialization]]></title>
    <url>%2FCSharp%2FCSharp%20Object%20Initialization%2F</url>
    <content type="text"><![CDATA[1. 概述为了简化对象初始化的流程，C# 提供了 对象初始化语法。简单的来说就是通过类似 数组初始化 的方法来对变量进行初始化操作。2. 语法1Point p = new Point &#123;x = 1.0, y = 2.0&#125;;3. 原理此语法实际上是一个语法糖，其原理就是先调用 默认构造函数，然后再对每个属性或者字段 依次赋值。和以下代码行为相同。123Point point = new Point();point.x = 1.0;point.y = 2.0;4. 调用自定义构造函数对象初始化块除了调用默认的构造函数以外，还可以调用自定义的构造函数。1Point point = new Point("This is a point") &#123;x = 1.0, y = 2.0&#125;;5. 初始化内部引用属性由于自动属性默认为引用类型赋值为 null ，所以内部的属性必须经过正确的初始化之后才能使用。为了简化繁琐的声明语句， C# 也提供了对内部引用属性的初始化语法12345Rectangle rect = new Rectangle&#123; TopLeft = new Point &#123; X = 10, Y = 10 &#125;, // 注意逗号 BottomRight = new Point &#123; X = 200, Y = 200 &#125;&#125;; // 注意分号其行为和如下代码相同：1234567891011Rectangle rect = new Rectangle();Point p1 = new Point();p1.X = 10;p1.Y = 10;rect.TopLeft = p1;Point p2 = new Point();p2.X = 200;p2.Y = 200;rect.BottomRight = p2;]]></content>
      <categories>
        <category>CSharp</category>
      </categories>
      <tags>
        <tag>CSharp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C# Properties and Fields]]></title>
    <url>%2FCSharp%2FCSharp%20Properties%20and%20Fields%2F</url>
    <content type="text"><![CDATA[1. 概述C# 相对于 Java 的一个较大的改进就是提供了类的 属性访问 语法。在这里，将和 Kotlin 来比较学习。2. 定义属性这是 C# 和 Kotlin 的第一个不同，C# 的普通属性需要 自定义后备字段(backing field)；而 Kotlin 不允许字段，只在 getter 和 setter 中使用 field 来指代字段。12345678910111213// C#class Point &#123; private int x; public X &#123; get &#123; return x; &#125; set &#123; x = value; &#125; &#125;&#125;注意上面的 value 指代的是传入 setter 的值而与之相反的是，Kotlin 允许 setter 使用括号来进行传入参数命名1234567class Point &#123; var x: Int = 0 get() = field set(value) &#123; field = value &#125;&#125;3. 静态属性Kotlin 实际上没有这个语法，只能使用伴生对象来实现。C# 支持静态属性，不过只能应用于静态字段。12345678class Bank &#123; private static int interest; public static Interest &#123; get &#123; return interest; &#125; set &#123; interest = value; &#125; &#125;&#125;4. 自动属性如果一个属性不包括具体逻辑，只负责简单获取返回，那么定义一大堆私有后备字段是极其不方便的，所以 C# 提供了 自动属性，使用一个 私有的后备字段 和 简单的 getter 和 setter。1234567891011class Point &#123; public X &#123; get; set; &#125; public Y &#123; get; set; &#125;&#125;由于后备字段不可见，所以整个类都必须使用 属性 来进行操作，而不能直接操作字段。这点和 Kotlin 的行为很像有一点需要注意的地方，自动属性会使用默认值来填充私有后备属性；这说明任何 引用类型 默认为 null，使用时需要注意。在 C# 6.0 后可以对自动属性进行初始化1public double X &#123;get; set;&#125; = 1.05. 只读只写属性忽略属性中对应的 set 或者 get 可以让属性成为 只读只写属性当进行写入操作时，编译器会报错。而 Kotlin 使用 var 和 val 来区分可读可写，如果需要做严格限制，可以将 getter 或者 setter 设置为私有]]></content>
      <categories>
        <category>CSharp</category>
      </categories>
      <tags>
        <tag>CSharp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C# 分部类]]></title>
    <url>%2FCSharp%2FCSharp%20%E5%88%86%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[当开发大型项目时，会出现某个类非常长的情况。C# 对此提供了一个 partial 关键字；可以用它将一个类分割成多个文件，以期分隔经常改动的内容和不经常改动的内容。例如 Empolyee.cs ：12345678910class Employee&#123; // 字段 // 构造函数 // 方法 // 属性&#125;可以将其分割为两个文件，然后使用 partial 进行标记。12345678// Employee.cspartial class Employee&#123; // 方法 // 属性&#125;1234567// Employee.Internal.cspartial class Employee&#123; // 字段 // 构造函数&#125;需要注意的是，文件的名字是可以随便取的，并没有特别的限制。]]></content>
      <categories>
        <category>CSharp</category>
      </categories>
      <tags>
        <tag>CSharp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OSX Mono Halal Installation]]></title>
    <url>%2FMono%2FOSX%20Mono%20Halal%20Installation%2F</url>
    <content type="text"><![CDATA[在开发时，总想保证自己的开发平台得到及时的更新；但是使用官方安装包的安装不方便进行快速更新，而且安装下来一大堆版本堆积也不够清真。所以，在这里使用 Homebrew Cask 可以让 mono-mdk 得到及时，清真的安装和更新。1brew cask install mono-mdkHomebrew 也有 mono 包，但是不知道为什么那个包一般的软件认不出来有一点需要注意的地方就是，Visual Studio For Mac Preview 使用的是比较新的 mono，此时我们需要 tap caskroom/versions 仓库来获取 mono-mdk 的 preview 版本。12brew tap caskroom/versionsbrew cask install mono-mdk-preview]]></content>
      <categories>
        <category>Mono</category>
      </categories>
      <tags>
        <tag>Mono</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C# Visibility Modifiers]]></title>
    <url>%2FCSharp%2FCSharp%20Visibility%20Modifiers%2F</url>
    <content type="text"><![CDATA[1. 概述C# 的访问修饰符比 Java 多了两个 internal 和 protected internal默认行为也不同2. InternalC# 新增的 internal 访问修饰符，指的是，该类型的可见范围为 当前程序集(即 .dll 和 .exe 中)注意和 Java 的 package 级别的可见性区分，internal 指示的是整个程序集的可见性。3. Protected Internalprotected internal 实际上是 protected 和 internal 的一个 union。它指示的是，该类型在当前程序集可见 或者 在其他程序集中的派生类可见4. 修饰限制Top-level 的类型只能使用 public 和 internal 来修饰，如普通的类。嵌套类、嵌套的数据结构可以使用其他的修饰符。]]></content>
      <categories>
        <category>CSharp</category>
      </categories>
      <tags>
        <tag>CSharp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《编写可读代码的艺术》笔记]]></title>
    <url>%2FCleanCode%2F%E7%BC%96%E5%86%99%E5%8F%AF%E8%AF%BB%E4%BB%A3%E7%A0%81%E7%9A%84%E8%89%BA%E6%9C%AF%20%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1. 代码应该易于理解好的代码，应该能让人易于理解。理解难度指的是别人读懂你的代码所需的时间。读懂指的是，能对代码进行修改和扩展，并保持原有功能不变。易于理解的代码也易于测试，集成，模块化和扩展。从提高编码能力来看：程序员应该以写出易于理解的代码为核心目标。2. 把信息装到名字中2.1 选择专业的词, 不要空洞get 这个词很抽象，应该使用 download fetch 等更具有明显指向的词。下表是一个建议：单词更多选择senddeliver, dispatch, announce, distribute, routefindsearch, extract, locate, recoverstartlaunch, create, begin, openmakecreate, set up, build, generate, compose, add, new关键思想：清晰精确比装可爱要好2.2 避免使用泛泛的名字例如 tmp 和 retval 这种空洞的词语不要使用。tmp 这个名字只应用于短期存在且临时性为其主要存在因素的变量。i j k 经常被应用于迭代器，但是应该优先考虑比这些变量更为贴切的命名。2.3 使用具体的名字代替抽象的名字例如 ServerCanStart()，如果它是检测服务是否可以监听某个给定的端口的话，那么就应该声明为 CanListenOnPort()例子： run_locally如果我们有个命令行标识叫 run_locally，那么很难推断出它究竟有什么用处，可能需要在本地运行的时候使用它？但不明白为什么使用它。假如 run_locally 是用于输出日志，那么就应该把它改成 extra_logging ，如果 run_locally 不仅做这个工作怎么办呢？假如说它还承担了建立和使用一个本地数据库的工作。那么就应该 新建另一个标志 use_local_database2.4 为名字附带更多信息为你的名字带上一些具体的信息，比如说变量的 内在格式，和变量的 单位1string id; // Example: "af84ef845cd8"如上，如果这个变量的格式很重要，那么就应该在名字附上 hex_id这里指的就是变量的 内在格式，而不是类似匈牙利命名法的变量的类型。有时候单位也是很重要的，那么就应该加上单位。1234var start_ms = (new Date()).getTime();var elapsed_ms = (new Date()).getTime() - start;document.writeln("load time was: " + elapsed + " seconds");2.5 名字的长度大作用域采用较长名称，小作用域采用短名称使用快捷键来快速输入长名字和使用名字自动补全不要使用大家都不认得的首字母缩写词丢掉没用的词2.6 利用名字的格式来传递含义比如说大驼峰是类，小驼峰是变量等等；格式可以指明一个名字的类型。]]></content>
      <categories>
        <category>CleanCode</category>
      </categories>
      <tags>
        <tag>CleanCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Intellij Tips and Tricks]]></title>
    <url>%2FIntelliJ%2FIntellij%20Tips%20and%20Tricks%2F</url>
    <content type="text"><![CDATA[1. 跳转原则： 尽量不使用鼠标、不使用标签页command + O 跳转到特定的类shift + command + O 跳转到文件使用 : + 行号 可以快速跳转到特定文件的特定行alt + command + o 变量、方法跳转使用 &lt;class&gt;.&lt;symbol&gt; 可以跳转到特定类的方法或者变量double shift Search Everywhere上述方法的综合体command + E Recent Filesshift + command + E Recent Changed Filescommand + [ 和 command + ] 在之前打开的文件前后跳转在 Project Window 使用 Auto Scroll from Souce，使用 command + ↓ 来跳转到源文件在方法名、变量名和类名使用 command + B 可以跳转到声明部分在方法名、变量名和类名使用 command + U 可以跳转到继承链的上一级，即超类在声明部分使用 alt + command + B 可以查看所有的 实现 并进行跳转在变量声明部分使用 ctrl + H 可以显示整个变量、类的继承结构在方法名使用 shift + command + H 可以显示方法的继承结构在文件中使用 command + F12 可以显示一个当前类所有成员的 Popup 窗口也可以使用 command + 7 来打开结构窗口来查看使用 command + ↑ 来打开 Navigation Bar， 不要把它长期显示在屏幕上使用 F2 和 shift + F2 来在错误之间跳转在右上角的感叹号图标右键点击，可以设置 只在 Error 之间跳转2. 新建在 Project Window 使用 command + N 来新建文件或者 package 或者目录使用 abc/def/ghi/mnop 这种文件夹名来建立文件夹结构，而不要一个一个建立同上，在新建文件时，也可以使用 abc/def/test.txt 这种文件名来构建一个在文件夹内部的文件同，使用 abc.def.ghi.Hehe 这种 类名 可以建立一个 在包内的类焦点在编辑器时使用 ctrl + alt + N 来进行上述新建操作使用 command + shift + N 新建一个临时文件(Scratral File)临时文件可以是任何文件，也可以成功的编译运行。实际上就是用来给开发者进行一些小测试用的3. 重构使用 alt + ↑ 来选择一行代码持续点击会继续选择更大的作用域：方法 -&gt; 内部类 -&gt; 外部类 -&gt; 文件使用 alt + ↓ 来缩小选择的作用域范围使用 alt + shift + ↑/↓ 来 移动选择的代码使用 shift + command + V 来打开剪切板历史记录不包括 IdeaVim 的剪贴板历史记录使用 alt + shift + 左键点击 来设置一个 Multicursor不要使用这个功能来进行代码重构可以使用多重指针来进行复制粘贴操作使用 shift + F6 来进行变量重命名使用 alt + command + L 进行当前文件的代码格式化使用 Code Cleanup 来进行整个工程级别的代码格式化选择一段代码然后使用 alt + Enter 可以对当前片段的代码格式进行调整。使用 ctrl + T 可以调出 Refactor This 菜单，有很多重构功能可以使用4. Language Injection在 字符串 使用 alt + Enter 选择 inject language 可以让 IDEA 认定当前字符串的语言成分，从而进行相应语言的提示和工作。选择 json 可以在 JSON 编辑框中编辑纯 JSON 内容，IDEA 会自动生成相应的 Java 字符串选择 SQL 可以进行 SQL 补全，同时选择链接的数据库进行执行。同时，如果在 SQL 字符串中使用重构功能，IDEA 不仅会重构代码内容，同时还会对 数据库 内容进行修改选择 正则表达式 可以在对应的 Hover 框内对正则表达式进行检验5. 补全使用 ctrl + shift + Space 进行 智能补全使用 command + P 来获取 所调用方法的参数信息使用 ctrl + alt + Space 可以补全方法名和类名使用 alt + / 来进行变量补全和 变量命名补全使用 shift + command + Enter 可以补全当前语句块不仅仅是分号补全，还可以是大括号补全6. 模板使用 command + J 来插入已经定义好的 Live Template可以打出 Live Template 然后使用 Tab 进行补全不过使用 command + J 可以给予提示常用的：psvm -&gt; public static void main(String[] args)在选择了一段代码的情况下，使用 alt + command + T 可以将代码用特定的结构包起来比如说 if-else 、try-catch 等等使用调用可以在列表中选取 Postfix Completion，具体效果和上面相同模板不仅仅支持 Java，还支持例如 HTML，CSS， Javascript 等多种语言7. 代码分析使用 Code Inspection By Name 可以分析特定的错误和缺陷使用 Structural Search/Replace 可以进行特定的代码结构的查找和替换，同时，可以将其加入 Inspection，进行错误提示使用 Analyze Data Flow 可以分析特定变量的流动，有助于读懂他人代码8. 版本控制选择两个 commit 然后使用 ctrl + D 来进行 Diff使用 Annotate 可以查看一个文件中的各行的修改使用 command + K 进行 commit 操作使用 shift + command + K 进行 push 操作使用 alt + command + Z 进行 revert 操作使用 ctrl + V 调出 有关版本控制的 Popup 窗口9. 调试右键点击断点区域，可以设置断电的 condition还有个 More 可以点击在调用栈区域，可以选择 Drop Frame 将选择的 Frame 进行出栈操作如果不小心 Step Into 太深的话可以使用这个10. 其他使用 ctrl + ` 来进行代码样式、快捷键等的快速切换可以在设置中定义一个常用的 Quick List使用 alt + F12 可以调出 IDEA 内置终端Help 菜单中的 Productive Guild 记录了使用的 IDEA 功能，包括功能的解释和使用频率Registry 内有一个选项可以减少输入延迟(editor latency)]]></content>
      <categories>
        <category>IntelliJ</category>
      </categories>
      <tags>
        <tag>IntelliJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 3 Class]]></title>
    <url>%2FPython%2FPython%203%20Class%2F</url>
    <content type="text"><![CDATA[1. 概述Python 是高度面向对象的语言，事实上，任何的变量类型都是类2. 创建类类由 class 关键词定义，后面加冒号表示类的作用域12class Person: pass3. self 参数Python 的 self 参数类似于 Java 的 this，但是这个参数在 Python 中的作用则更为重要，具体可以看下面的内容4. 类域Python 类的域与 Java 不同不带 self 参数修饰的普通变量为静态变量只有带 self 修饰的才是对象变量例如 self.name 是对象变量，name 是静态变量成员都是公有的，包括数据成员但是以双下划线 __ 开头的成员会被 Python 的名称管理体系作为私有变量，这是 Python 的名称管理体系做出的，而不是类的特性5. 类方法Python 的类方法和 Java 稍有不同类的普通方法必须定义 self 参数类块中不带 self 参数的方法一般为静态方法，需要用 staticmethod() 修饰123456789class Robot: '''Represent a robot, with a name''' def sayHi(self): print("hehe") def howMany(): print('We have &#123;0:d&#125; robot'.format(Robot.population) ) howMany = staticmethod(howMany)静态方法也可以用以下语句修饰123@staticmethoddef howMany(): print('We have &#123;0:d&#125; robot'.format(Robot.population))6. 构造函数和析构函数Python 拥有构造函数和析构函数。工作原理和 C++ 的构造函数和析构函数相同。123456789class Person: def __init__(self, name): self.name = name def sayHi(self): print('Hello, my name is', self.name) def __del__(self): print("I am dying.")7. 继承Python 的继承通过在类名称后面添加括号实现。括号中为父类的名字1234567891011121314151617181920212223242526272829303132333435363738class SchoolMember: def __init__(self,name,age): self.name = name self.age = age print('(Initialize SchoolMember:&#123;0&#125;)'.format(self.name)) def tell(self): '''Tell my details.''' print('Name:"&#123;0&#125;" Age:"&#123;1&#125;"'.format(self.name,self.age),end ='')class Teacher(SchoolMember): '''Repressent a teacher.''' def __init__(self,name,age,salary): SchoolMember.__init__(self,name,age) self.salary = salary print('(Initialized Teacher:&#123;0&#125;)'.format(self.name)) def tell(self): SchoolMember.tell(self) print('Salary:"&#123;0:d&#125;"'.format(self.salary))class Student(SchoolMember): '''Represents a student''' def __init__(self,name,age,marks): SchoolMember.__init__(self,name,age) self.marks = marks print('(Initialized Student:&#123;0&#125;)'.format(self.name)) def tell(self): SchoolMember.tell(self) print('Marks:"&#123;0:d&#125;"'.format(self.marks))t = Teacher('Mrs.Shrividya',30,30000)s = Student('Swaroop',25,75)print() # print a blank linemembers = [t,s]for member in members: member.tell() # work for both Teacher and Students上面的例子中，Student 和 Teacher 都继承自 SchoolMenber通过 SchoolMenber 调用父类方法]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 3 Basic]]></title>
    <url>%2FPython%2FPython%203%20Basic%2F</url>
    <content type="text"><![CDATA[1. 注释注释以 # 开头以 #! 开头的称为组织行，表明了执行脚本的解释器Linux/Unix 中，如果不清楚 Python 的位置，可以使用 #!/usr/bin/env python，env 会自动寻找 Python 的解释器路径进行执行。2. 字面意义的常量如同 5, 1.23, 9.25e-3 这样的数，以及 “This is a string” 等字符串被称作字面意义上的常量2.1 数数的类型有三种——整数、浮点数和复数2 是整数3.23 和 52.3E-4 是浮点数(-5+4j) 和 (2.3-4.6j) 是复数Python 3 只有一种整数类型，不区分 long 和 intPython 2 中区分 long 类型布尔型(bool) 属于整型(integer)的一种2.2 字符串字符串是字符的序列，其编码默认为 Unicode。可以使用 str.encode(&quot;ascii&quot;) 将字符串编码转换为 ASCII可以用单引号和双引号来指定字符串，单引号和双引号的意义完全相同利用三引号 &quot;&quot;&quot; 或者 &#39;&#39;&#39; 可以指定一个多行字符串12345'''This is a multi-line-string. This is the first line.And this is the second line."What's your name?" I asked.He said "Bond, James Bond."'''在三引号中，可以自由使用单引号和双引号使用转义来表示原有字符例如 &#39;What&#39;s your name?&#39; 中，由于（使用单引号界定的）字符串中有单引号，会使 Python 解释出现错误，此时需要用转义来表示原有的单引号。正确的应该是 &#39;What\&#39;s your name?&#39;。但是，可以在用双引号界定的字符串中使用单引号。这个也是正确的 &quot;What&#39;s your name?&quot;另外，在一行的末尾的反斜杠 \ 仅仅表示下一行的字符串是上一行的继续，并不增加新的行12345# 以下字符串是等价的"This is the first line.\This is also the first line.""This is the firstline. This is also the first line."原始字符串当需要指定一些字符不被特殊处理时，可以使用 r 或者 R 附加在字符串前面指定原始字符串。例如： r&quot;Newlines are indicated by \n&quot;此时，字符串中的所有字符都不会被转义在正则表达式使用的时候，请尽量使用原始字符串字符串是不可变的字符串按字面意义连接如果将两个字符串按字面意义相邻放着，会被自动转为一个字符串format() 方法可以使用 format() 方法来通过使用其他信息构建字符串1234567#!/usr/bin/pythonage = 25name = 'Swaroop'print('&#123;0&#125; is &#123;1&#125; years old'.format(name, age))# 输出为# Swaroop is 25 years old.也可以使用 format() 进行格式化输出12&gt;&gt;&gt; '&#123;0:.3&#125;'.format(1/3)'0.333'3. 变量3.1 命名同其他语言的变量命名无多大差别。不允许数字开头大小写敏感3.2 类型Python 变量不需要声明类型，但仍然是强类型实际上，Python 的任何一切都称为对象4. 逻辑行和物理行Python 中一个逻辑行对应一个物理行，虽然 Python 也可以使用分号，但是一般不使用分号其他语言一般强制要求行尾分号，Python 不推荐分号的使用。5. 缩进Python 有着严格的缩进区分，不能随意缩进，缩进用来标明语句块同一个语句块具有相同的缩进层次Python 使用缩进来表示代码块，不再使用花括号6. 操作符Python 中的 // 符号表示向下取整相除，而不是单行注释。注释使用 # 来开头。注意这里是向下取整，而不是趋零取整布尔操作not 表示布尔非（相当于 !）and 表示布尔与（相当于 &amp;&amp;）or 表示布尔或（相当于 ||）有趣的是，不等于仍然使用 != 来表示相等性判别Python 3 中有两种相等性判别，一种是变量相等性(equality)，另一种是实例相等性(identity)is 用作判断实例相等性否定操作为 is not而 == 用于判断变量相等性区别：1234a = [1, 2, 3]b = [1, 2, 3]a == b # Truea is b # False优先级在 Python 中，lambda 表达式处在最高优先级，而并非布尔运算]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 3 Function]]></title>
    <url>%2FPython%2FPython%203%20Function%2F</url>
    <content type="text"><![CDATA[1. 函数的定义函数通过 def 关键字来定义。def 后跟一个函数名称，然后跟一对圆括号，表示函数。注意不要漏掉括号1234567#!/usr/bin/python# Filename: function1.pydef sayHello(): print('Hello, World!')sayHello() # 调用函数2. 函数参数在函数定义的圆括号中可以指定形参。注意，不需要声明形参类型1234567def printMax(a, b): if a &gt; b: print(a, 'is maximum') elif a == b: print(a, 'is equal to', b) else: print(b, 'is maximum')注意，Python 的方法是 Pass by reference其中 a, b 是形参这里由于形参类型不确定，一般的 IDE 无法进行提示。所以可以使用冒号指明其类型1def printMax(a:int, b:int):3. 变量作用域函数内声明的变量称作局部变量可以使用 global 语句来调用和修改函数外部声明的变量但是，不建议使用 global 语句。应通过其他方式实现。非局部变量在嵌套定义函数的情况下会遇到。通过 nonlocal 来调用外部函数定义的变量1234567def funcOuter(): x = 2 print('x is ', x) def funcInner(): nonlocal x x = 5有毒性，最好不要这么搞4. 默认参数通过在函数定义的时候对形参进行指定，可以指定默认参数12def say(message, times = 1): print(message * times)只有形参表末尾的形参才能有默认参数12def func(a, b = 5) # Correctdef func(a = 5, b) # Wrong5. 关键参数在函数调用的时候对形参进行指定，可以忽略形参顺序指定实参123456def func(a, b = 5, c = 10): print('a is ', a, 'and b is ', b, 'and c is ', c)func(3, 7)func(25, c = 24)func(c = 50, a = 100)6. 不定参数通过在函数定义的时候使用星号标识形参123456789101112#!/usr/bin/python# Filename: total.pydef total(initial = 5, *numbers, **keywords): count = initial for number in numbers: count += number for key in keywords: count += keywords[key] return countprint(total(10, 1, 2, 3, vegetables = 50, fruits = 100))带一个星号的参数范围内的参数会被收集为一个列表如上面的函数会将 1, 2, 3 收集为一个叫做 numbers 的列表。带两个星号的参数范围内的参数会被收集为一个字典如上面的函数会将 vegetables = 50, fruits = 100 收集为一个叫做 keywords 的字典。7. Keyword-only 参数在带星参数之后的普通参数会成为 Keyword-only 参数，即只能通过关键参数形式来传递实参假如不需要不定参数而又想使用 Keyword-only 参数，那么可以使用没有名字的空星，如下所示1234567&gt;&gt;&gt; def foo(a,b,*,c,d):... print(a,b,c,d)...&gt;&gt;&gt; foo(1,2,3,4)Traceback (most recent call last):File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: foo() takes exactly 2 positional arguments (4 given)8. return 语句Python 的函数默认为没有返回值一个没有返回值的函数的 return 语句等价于 return None9. DocStrings这一特性很类似 Java 的 javadoc。与 Java 不同的是，Python 的 DocStrings 在函数的第一个逻辑行处定义特点如下：一个多行字符串以大写字母开头，句号结尾第二行是空行Python 的每个函数都拥有 __doc__ 属性，可以通过调用这个属性来显示 DocStrings在 DocStrings 中可以使用 reStructureText 的格式来实现 Javadoc 中的 @parma @retrun 功能1234567891011def foo(a, b): '''This is the foo function It is just a foo function :parma a: This is the parma a :type a: int :parma b: This is the parma b :type b: int ''' pass也可以使用 Google 的规范1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859def module_level_function(param1, param2=None, *args, **kwargs): """This is an example of a module level function. Function parameters should be documented in the ``Args`` section. The name of each parameter is required. The type and description of each parameter is optional, but should be included if not obvious. Parameter types -- if given -- should be specified according to `PEP 484`_, though `PEP 484`_ conformance isn't required or enforced. If \*args or \*\*kwargs are accepted, they should be listed as ``*args`` and ``**kwargs``. The format for a parameter is:: name (type): description The description may span multiple lines. Following lines should be indented. The "(type)" is optional. Multiple paragraphs are supported in parameter descriptions. Args: param1 (int): The first parameter. param2 (Optional[str]): The second parameter. Defaults to None. Second line of description should be indented. *args: Variable length argument list. **kwargs: Arbitrary keyword arguments. Returns: bool: True if successful, False otherwise. The return type is optional and may be specified at the beginning of the ``Returns`` section followed by a colon. The ``Returns`` section may span multiple lines and paragraphs. Following lines should be indented to match the first line. The ``Returns`` section supports any reStructuredText formatting, including literal blocks:: &#123; 'param1': param1, 'param2': param2 &#125; Raises: AttributeError: The ``Raises`` section is a list of all exceptions that are relevant to the interface. ValueError: If `param2` is equal to `param1`. .. _PEP 484: https://www.python.org/dev/peps/pep-0484/ """ if param1 == param2: raise ValueError('param1 may not be equal to param2') return True10. 注解(Annotations)10.1 参数注解Python 的参数注解定义在形参声明的位置，与形参以括号间隔，置于参数默认值之前1def foo(a: "This is param a", b: "This is param b" = 5):10.2 返回值注解Python 的返回值注解定义在函数头末尾的冒号之前，使用 -&gt; 和函数头分隔1def haul(item: Haulable, *vargs: PackAnimal) -&gt; Distance:注意，注解可以是字符串，也可以是类型。可以通过注解实现类型检查10.3 Lambda 表达式Lambda 表达式不支持注解]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 3 Advanced Skill]]></title>
    <url>%2FPython%2FPython%203%20Advanced%20Skill%2F</url>
    <content type="text"><![CDATA[1. 函数返回多个值函数可以通过返回一个元组来达到返回多个值的目的。1234def get_error_details(): return (2, 'second error details')errnum, errstr = get_error_details()上面运用到了元组解包技术，通过使用逗号分隔变量，就可以分别取出对应位置的元组元素。2. 特殊方法Python 的类中有许多内置的特殊方法，例如 __init__() 和 __del__()可以在 Python 的参考手册中找到它们以及对应的作用。3. 单行语句块如果一个语句块只有一个逻辑行，则可以把它置于条件语句或者循环语句的同一行1if flag: print 'Yes'4. Lambda 表达式lambda 语句用来创建新的函数对象，并且在运行时返回它们。12def make_repeater(n): return lambda s: s*n本质上, lambda 需要一个参数,后面仅跟单个表达 式作为函数体,而表达式的值被这个新建的函数返回。注意,即便是 print 语句也不 能用在 lambda 形式中,只能使用表达式。5. 列表综合通过列表综合，可以从一个已有的列表导出一个新的列表。12345#!/usr/bin/python# Filename: list_comprehension.pylistone = [2,3,4]listtwo = [2*i for i in listone if i &gt; 2]通过在列表中使用这样的语句就可以对符合条件的每个列表元素进行处理注意原有的列表并没有改变，这个操作实际上是生成了一个新列表6. exec 和 evalexec 语句用来执行字符串形式的 Python 语句12&gt;&gt;&gt; exec(&apos;print(&quot;Hello, World&quot;)&apos;)Hello, Worldeval 语句用来执行字符串形式的 Python 表达式12&gt;&gt;&gt; eval('2*3')6两者看似相同，但是也有细微区别：eval 只接受单行字符串表达式，exec 可以接受一个语句和语句块“表达式”所指的就是可以放在等号右边的东西，break if pass 等不是表达式eval 会返回表达式的结果，exec 则会忽略该结果7. assert 语句同 Java 中的 assert 语句一样，以调试为目的。但是 Python 的 assert 语句功能是默认启动的当 assert 失败时，会引发一个 AssertionError8. repr 函数该函数用来取得对象的规范字符串表示，实际上它的作用就是为对象包了一层&quot;&quot;12345678910&gt;&gt;&gt; i = []&gt;&gt;&gt; i.append('item')&gt;&gt;&gt; i['item']&gt;&gt;&gt; repr(i)"['item']"&gt;&gt;&gt; eval(repr(i))['item']&gt;&gt;&gt; eval(repr(i)) == iTrue]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 3 Exception]]></title>
    <url>%2FPython%2FPython%203%20Exception%2F</url>
    <content type="text"><![CDATA[&emsp;1. 概述&emsp;2. 处理异常&emsp;3. 引发异常&emsp;4. Try…Finally 语句&emsp;5. with 语句1. 概述Python 的异常处理和 Java 相似，函数拼写错误等也会触发异常。2. 处理异常通过 try...except 语句来处理异常123456789try: text = input('Enter something --&gt; ')except EOFError: print('Why did you do an EOF on me?')except KeyboardInterrupt: print('You cancelled the operation.')else: print('You entered &#123;0&#125;'.format(text))try 还可以带一个 else 语句，作用与 while 的语句类似3. 引发异常通过 raise 语句来引发异常123456789101112131415161718192021class ShortInputException(Exception):'''A user-defined exception class''' def __init__(self, length,atleast): Exception.__init__(self) self.length = length self.atleast = atleasttry: text = input('Enter something--&gt;') if len(text) &lt; 3: raise ShortInputException(len(text),3) #other work can continue as usual hereexcept EOFError: print('Why did you do an EOF on me')except ShortInputException as ex: print('ShortInputException The input was &#123;0&#125; long, excepted \atleast &#123;1&#125;'.format(ex.length, ex.atleast))else: print('No exception was raised.')4. Try…Finally 语句这点与 Java 相似，Python 使用 finally 语句来对流进行一些收尾操作1234567891011121314151617181920#!/usr/bin/python# Filename: finally.pyimport timetry: f = open('poem.txt') while True: # our usual file-reading idiom line = f.readline() if len(line) == 0: break print(line, end = '') time.sleep(2) # To make sure it runs for a whileexcept KeyboardInterrupt: print('!! You cancelled the reading from the file.')finally: f.close() print('(Cleanig up: closed the file)')5. with 语句这个语句类似 Java 中的带资源的 try 块通过使用 with 来打开一个带资源的操作，则其会自动在最后将资源关闭12345#!/usr/bin/python# Filename: using_with.pywith open("poem.txt") as f: for line in f: print(line,end='')]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 3 Control Flow]]></title>
    <url>%2FPython%2FPython%203%20Control%20Flow%2F</url>
    <content type="text"><![CDATA[&emsp;1. 概述&emsp;2. if 语句&emsp;3. while 语句&emsp;4. for 语句&emsp;5. 其他流程控制1. 概述控制流程包括 if for 和 whilePython 的流程控制语句有些特殊首先，关于流程控制不使用括号，只有函数和表达式才使用小括号使用冒号指示语句块的开头2. if 语句下面是一个 if 语句的例子1234567891011121314#!/usr/bin/python# Filename: if.pynumber = 23guess = int(input('Enter an integer : '))if guess == number: print('Congratualtions, you guessed it!') print('But you do not win any prizes!')elif guess &lt; number: print('No, it is a little higher than that')else: print('No, it is a little lower than that')print('Done')几个注意要点：Python 中为了减少缩进，使用 elif 来代替 if...else if...else注意缩进，同样的缩进等级表示了同一个代码块Python 中没有 switch 语句，使用相应的 if..eles 结构来替代注意不要漏掉冒号3. while 语句while 语句与其他语言无太大差别，讲几个注意事项注意不要漏掉 while 语句末尾的冒号Ture 和 False 代表布尔类型while 可以有 else 语句，但一般不使用4. for 语句for 语句和其他语言有较大区别，以下是 Python 和 Java 语言的对比123# Pythonfor i in range(0, 4): print(i)下面是等价的 Java1234// Javafor(int i = 0; i &lt; 4; i++) &#123; System.out.println(i);&#125;实际上 Python 的 for 语句更像 Java 中的 foreach 语句，下面是两种等价的语法形式123# Pythonfor word in wordList: print(word)下面是 Java 语法表述1234// Javafor(word : wordList) &#123; System.out.println(word);&#125;需要注意的几个要点：range() 函数的指示区间为左闭右开print() 函数会默认打印换行符通过指示 end 来进行单行打印print(word, end=&#39;&#39;)如果缓冲区中有字符，那么指定 flush 为 True 来清除缓冲区print(word, end=&#39;&#39;, flush=True)5. 其他流程控制break 和 continue 都和其他语言无异]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 3 Collection]]></title>
    <url>%2FPython%2FPython%203%20Collection%2F</url>
    <content type="text"><![CDATA[1. 列表(list)列表是用于处理有序项目的数据结构，与 Java 的数组类似，自带排序方法，可以使用 [] 进行随机访问列表使用方括号定义，使用 len() 函数来获取列表长度123456789#!/usr/bin/python# This is my shopping listshoplist = ['apple', 'mango', 'carrot', 'banana']print(len(shoplist))olditem = shoplist[0]del shoplist[0]del 类似 C++ 中的 delete，用于释放一个对象。这里使用 del 来将列表元素移除2. 元组(tupple)元组和列表相似，唯一的区别是元组不可改变元组使用圆括号来定义12345678#!/usr/bin/python# 圆括号是可选的，但是还是加上圆括号为好zoo = ('python', 'elephant', 'penguin')print('Number of annimal in the zoo is', len(zoo))new_zoo = ('monkey', 'camel', zoo)print('Last annimal in the zoo is', new_zoo[2][2])注意到，元组是可以嵌套的，有点类似于 Java 中的二维数组，但并不完全相同。new_zoo[0] ==&gt; &#39;monkey&#39;new_zoo[2] ==&gt; zoo ==&gt; (&#39;python&#39;, &#39;elephant&#39;, &#39;penguin&#39;)new_zoo[2][2] ==&gt; zoo[2] ==&gt; &#39;penguin&#39;含有 0 个或者 1 个元素的元组含有 0 个元素的元组用空圆括号表示，empty = ()含有 1 个元素的元组要在元素后面接一个逗号 singleton = (2, )3. 字典(dict)字典是一个键值对的表，类似于 Java 中的哈希表，一个项目具有 Key 和 Value只能用不可变对象作为项目的键，值则可以是可变的也可以是不可变的。字典使用花括号定义，用冒号分隔键和值，用逗号分隔项目，使用 [] 来取值。12345678910ab = &#123; 'Swaroop' : 'swaroop@swaroopch.com' 'Larry' : 'larry@wall.org' &#125;print("Swaroop's address is", ab['Swaroop'])for name, adderss in ab: # iterate the dict在字典中，使用键来充当索引成分。字典可以通过 items() 方法来返回键值对的列表，但是是无序的。注意字典是没有顺序的（不能维持插入时的顺序），要使用时最好先排序。4. 序列列表，元组和字符串都是序列，序列具有以下特点：支持索引操作符 [] 随机访问索引从 0 开始，可以支持负数当索引是负数时，它会抓取倒数的项目可以采取切片操作即返回一个序列的子集，例如子数组等切片操作通过冒号完成，例如下面的 shoplist[1:3]。切片操作的区间是左闭右开，上面返回的是 shoplist[1] 和 shoplist[2] 组成的子列表假如前一个为空，切片从序列头开始，后一个为空，切片在序列尾停止。（后一个为空，最后结果包括最后一个元素，shoplist[:] 返回整个列表）也可以使用负数作切片，此时的负数只作为一个定位元素的索引，例如 shoplist[:-1] 会在倒数第一个停止，也就是不包括最后一个元素的子列表也可以给切片定义第三个参数——切片的步长。其实就是切片操作在遍历数组时的步长。步长通过两个冒号的最后一个参数定义shoplist[::3] ==&gt; shoplist[0], shoplist[3], shoplist[6]...1234567891011121314151617181920# Indexing or 'Subscription' operationprint('Item 0 is', shoplist[0])print('Item 1 is', shoplist[1])print('Item 2 is', shoplist[2])print('Item 3 is', shoplist[3])print('Item -1 is', shoplist[-1])print('Item -2 is', shoplist[-2])print('Character 0 is', name[0])# Slicing on a listprint('Item 1 to 3 is', shoplist[1:3])print('Item 2 to end is', shoplist[2:])print('Item 1 to -1 is', shoplist[1:-1])print('Item start to end is', shoplist[:])# Slicing on a stringprint('characters 1 to 3 is', name[1:3])print('characters 2 to end is', name[2:])print('characters 1 to -1 is', name[1:-1])print('characters start to end is', name[:])5. 集合集合是无顺序的简单对象的聚集。使用集合，可以检查是否是成员，是否是另一个集合的子集，得到两个集合的交集1234567891011&gt;&gt;&gt; bri = set(['brazil', 'russia', 'india'])&gt;&gt;&gt; 'india' in briTrue&gt;&gt;&gt; 'usa' in briFalse&gt;&gt;&gt; bric = bri.copy() &gt;&gt;&gt; bric.add('china')&gt;&gt;&gt; bric.issuperset(bri)True&gt;&gt;&gt; bri.remove('russia')&gt;&gt;&gt; bri &amp; bric # OR bri.intersection(bric)&#123;'brazil', 'india'&#125;6. 引用这个概念和 Java 中的引用相同。注意切片操作可以对一个序列进行深拷贝(deep copy)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 3 IO]]></title>
    <url>%2FPython%2FPython%203%20IO%2F</url>
    <content type="text"><![CDATA[1. 使用 input() 进行输入Python3 使用 input() 函数获取用户输入。input() 函数会返回一个字符串，随后可以使用 int() float() 等方法将字符串转为对应的类型或者格式在 Python 3 中，raw_input() 被整合到 input() 函数中，Python 2 的 input() 函数的功能被抛弃了。2. 文件输入输出与 C++ 和 Java 读取文件流的形式一样，Python 通过使用 file 类的函数来对文件进行读取写入123456789101112131415161718poem = '''\ Programming is funWhen the work is doneif you wanna make your work also fun: use Python!'''f = open('poem.txt', 'w') # open for 'w'ritingf.write(poem) # write text to filef.close() # close the filef = open('poem.txt') # if no mode is specified, 'r'ead mode is assumed by defaultwhile True: line = f.readline() if len(line) == 0: # Zero length indicates EOF break print(line, end='')f.close() # close the file使用 open() 打开文件，模式规则和 C++ 的相同文件交互完毕后，使用 close() 来关闭文件流3. pickle 模块Python 提供了一个 pickle 的标准模块，用于将对象储存在文件中，称为对象的持久化保存1234567891011121314151617181920#!/usr/bin/python# Filename: pickling.pyimport pickle# the name of the file where we will store the objectshoplistfile = 'shoplist.data'# the list of things to buyshoplist = ['apple','mango','carrot']# Write to the filef = open(shoplistfile,'wb')pickle.dump(shoplist, f) #dump the object to a file f.close()del shoplist # detroy the shoplist variable# Read back from the storagef = open(shoplistfile,'rb')storedlist = pickle.load(f) # load the object from the fileprint(storedlist)注意，持久化保存要求使用二进制模式通过 dump() 和 load() 就可以对对象进行导入和导出]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 3 Module]]></title>
    <url>%2FPython%2FPython%203%20Module%2F</url>
    <content type="text"><![CDATA[1. 概述模块有点类似 C++ 中的 Namespace，但并不完全相同2. 导入模块通过使用 import 语句来导入一个模块进行使用12345678910#!/usr/bin/python# Filename: using_sys.pyimport sysprint ('The conmmand line arguments are:')for i in sys.argv: print(i)print('\n\nThe PYTHONPATH is', sys.path, '\n')在上面的例子中，通过使用 import sys 就可以通过 sys.function 的形式来调用 sys 模块中的函数和变量。用户自定义模块在第一次导入时，会编译成字节码文件，这是 Python 处理的，可以提高模块导入的效率。这些文件以 .pyc 为扩展名，如果 Python 没有当前目录的访问权限，那么就不会创建 .pyc 文件第三方模块可以通过 Python 自带的 pip 进行安装另外，还可以通过使用 from...import... 语句来导入语句；它和 import 语句的唯一区别就是在模块导入之后，不用再在调用的时候填写模块名称。1234567891011# Import statementimport sysprint(sys.path)# From...import... statementfrom sys import argvprint(argv)# If you want to import all the identifiers,# use this statement.form sys import *注意，from...import * 语句不会导入以双下划线开头的标识符，如 __version__一般来说，不建议使用 from...import... 语句3. 创建模块创建模块最简单的方法就是编写 .py 文件；一个 .py 文件就是一个 Python 模块。例如：1234567#!/usr/bin/python# Filename: mymodule.py__version__ = '0.1'def sayHi(): print('Hi')Module Demo:1234567#!/usr/bin/python# Filename: mymodule_demo.pyimport mymodulemymodule.sayHi()print('Version', mymodule.__version__)4. 模块的默认变量每个模块都有几个默认变量，它们是由 Python 自动构建的；如 __name__ 变量，这是模块的名字（即 .py 文件的名字）可以使用 __name__ 变量来检测其自身是否是作为主程序运行1234567#!/usr/bin/python# Filename: using_name.pyif __name__ == '__main__': print('This program is being run by itself')else: print('I am being imported from another module')&#39;__main__&#39; 是主模块的名字，也就是主程序的文件名5. dir() 函数dir() 函数是内建函数，可以通过它来列出模块定义的标识符，包括函数、类和变量如果不提供参数，则返回当前模块中定义的名称列表12345&gt;&gt;&gt; a = [1, 2, 3, 4, 5]&gt;&gt;&gt; import fibo&gt;&gt;&gt; fib = fibo.fib&gt;&gt;&gt; dir()['__builtins__', '__name__', 'a', 'fib', 'fibo', 'sys']由此可以看出，主模块具有 __buitins__ 对象，实际上这就是 Python 的内建函数和类dir() 函数一般不会将内建函数列出，如果需要查看，可以通过 dir(builtins) 查看6. 包(Package)包是模块的文件夹，其中包含了很多模块；同时一个包也可以包含另一个包。一个包必须包含 __init__.py 文件，以免 Python 将包识别为普通目录可以使用点号来访问到包中的模块例如：1234567891011121314151617181920212223sound/ Top-level package __init__.py Initialize the sound package formats/ Subpackage for file format conversions __init__.py wavread.py wavwrite.py aiffread.py aiffwrite.py auread.py auwrite.py ... effects/ Subpackage for sound effects __init__.py echo.py surround.py reverse.py ... filters/ Subpackage for filters __init__.py equalizer.py vocoder.py karaoke.py ...关于 __init__.py:一个包必须包含这个文件这个文件可以是空的，也可以做一些包的初始化工作，比如定义 __all__ 变量6.1 导入包包的导入有如下几种形式：使用 import 语句例如 import sound.effects.echo, 将 sound/effects/echo 模块导入；使用方法为 sound.effects.echo.echofilter(input, output, delay = 0.7, atten = 4使用 from package import item在包(Package)层面，Python 推荐这么导入，主要的优点在于能够减少没有必要的前缀修饰。例如： from sound.effects import echo 将 echo 模块导入使用方法为：echo.echofilter(input, output, delay = 0.7, atten = 4)补充：关于 from package import * 和 __all__ 变量__all__ 变量通常在 __init__.py 文件中定义，用于指定允许 import * 识别的标识符，即允许导出的标识符；如果没有指定这个变量，那么在使用 import * 时便会自动忽略以下划线开头的标识符内包导入对于包中的模块，在可能需要到另一个兄弟包模块的时候，由于它们处在同一个目录结构中，所以可以简单地省略一些前缀。Python 在导入包时，首先会搜寻当前目录，如果搜索不到，则再到系统 PATH 中进行搜索例如 srround 想要利用 echo 模块，则直接简单地 import echo 即可。在 Python 2.5 之后，可以使用相对路径进行包导入，例如：12345# 一个点代表当前目录# 两个点代表父目录from . import echofrom .. import formatsfrom ..filters import equalizer目前，Python 推荐使用 from package import item 的包层面导入，和 import module 的模块层面导入方法，能更好地避免冗余和变量名称冲突。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[特殊发音]]></title>
    <url>%2FJapanese%2F%E7%89%B9%E6%AE%8A%E5%8F%91%E9%9F%B3%2F</url>
    <content type="text"><![CDATA[1. 概述特殊发音指的是在发音过程中，一些五十音的发音方式要发生改变的情况。包括浊音、半浊音、拗音、促音和长音，以及同一个假名可能在不同场景下需要音变的情况。2. 浊音浊音值得是 「た」「さ」「か」「は」行假名派生出来的，具体的浊化音和英语的浊化差不多：ta -&gt; da; sa -&gt; za; ka -&gt; ga;あ い う え お がぎぐげごガギグゲゴざじずぜぞザジズゼゾだぢづでどダヂヅデドばびぶべぼバビブベボ2.1 鼻浊音特别注意，当 「が」行位于 句中或者句末 时，发鼻浊音。即在发 「が」时，先发 「ん」的音。当 「が」行位于词首的时候，只发普通的浊音，而不是鼻浊音。当 「が」用作 助词 时，也发 鼻浊音具体可以参考此视频链接2.2 半浊音需要注意的是，最后一个 「は」的浊化。有浊音和 半浊音 的区别。「は」的浊音就是 ha -&gt; ba (「ば」)而 「は」的半浊音是 ha -&gt; pa (「ぱ」)注意假名右上角标注的不同，浊音标注两点，而半浊音标注一个圈3. 送气音和不送气音送气音是 「か」「た」「ぱ」行假名特有现象。主要是为了满足较快的语速，保证说话的连贯性。当这些假名不在词首、句首时，发不送气音。即， 发音不变，将送气量减少，听起来就会像浊音，但是实际上还是清音或者半浊音。这里要多多练习才能掌握，注意多听多练，重点在 气流量的减少 而非 发音的改变，不然会导致 「か」「が」不分。4. 母音无声化母音无声化指的是在一些情况下 省略元音，而只保留气音的现象。这也是为日语的高语速而服务的。4.1 「い」「う」结尾 + 无声子音无声子音指的是声带不震动的气音。包括 「か」「さ」「た」「は」「ぱ」行，以及拗音 きゃ行、しゃ行、ちゃ行、ひゃ行、ぴゃ行如果遇到 「い」「う」结尾的词加上无声子音，那么就会造成母音无声化。其最主要的特征就是发前面的词时， 声带不会震动！具体可以看这个视频4.2 「い」「う」假名结尾时比如说常见的 です 和 ます，其中的 す 就会出现母音无声化。念做 「ｓ」而不是 「su」。注意 す 的读音也有比较难发的地方，注意读准5. 促音促音指的是 っ ，其本身 不发音，但是占用词语的一个节拍。所谓节拍，就是有促音的，读的时候，保持口型，不发音，等一阵子再发下一个假名。具体看 http://www.learnjapanese.aiyori.org/hiragana-sokuon.html6. 长音长音指的是 将前一个字母的音拉长一拍，和促音相反。在 写法上，有如下规则：母音重复如 「あ」「い」「う」只需要重复假名即可「え」段加「い」如 「きれい」美丽的「お」段加「う」如 「おとうさん」父亲片假名使用「ー」表示日文输入法输入减号即可注意，「え」和 「お」会出现母音重复现象，如 「おおい」。同时，「え」段有时也有加「え」的情况，如 「おねえさん」可能需要总结归纳。7. 拗音拗音是 「イ」段假名的特有现象，此段假名加上 ょ・ゃ・ょ 即组成拗音。注意拗音的字要缩小。拗音连成一个音节来读，而不是分开两个音节，相对来说较为简单。需要注意的是，拗音的罗马字会省略掉 i，如 「きゃ」的罗马字是「kya」，在打字时注意即可。如果要单独打后面的缩小的字，那么在假名前面加上 x 即可，如 ゃ 使用 「xya」即可。8. 助词音变一些假名在用作助词时，会发生音变现象，比如：「は」-&gt; 「わ」「へ」-&gt; 「え」]]></content>
      <categories>
        <category>Japanese</category>
      </categories>
      <tags>
        <tag>Japanese</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[补助动词]]></title>
    <url>%2FJapanese%2F%E8%A1%A5%E5%8A%A9%E5%8A%A8%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[1. 〜ている主要表示以下意思：正在进行的动作反复进行的动作自然维持的状态电视机坏了过去的经历去过 3 次北海道未来完成的结果到…时候， 已经… 了吧2. 〜てある后接他动词，表示状态〜ている 一般接 自动词，表示自然保持的状态〜てある 后接 他动词，表示人为维持的状态需要注意的是，上述两个的格动词都使用 が实际上，〜ている 让他动词具有表达状态的能力，整体上成为了自动词还有就是，上述的两种状态，都是 静止状态，所以格助词使用 に。后接他动词，表示 事先做好了某种准备票已经买好了，准备已经做好了3. 〜ておく]]></content>
      <categories>
        <category>Japanese</category>
      </categories>
      <tags>
        <tag>Japanese</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动词变化形式]]></title>
    <url>%2FJapanese%2F%E5%8A%A8%E8%AF%8D%E5%8F%98%E5%8C%96%E5%BD%A2%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1. 敬体形式(ます形)2. 连用形实际上就是 ます 形去掉 ます，就是动词连用形。2.1 敬体注意，这里的敬体时态变形都是属于敬体。中顿形用的比较少。始めまして2.2 名词动词连用形就是动词的 名词形式。通常和 に 连用，表示目的。に 作为助词只能接名词，表示目的时，只能使用动词的名词形式，即连用形。2.3 构成复合词3. 否定形由动词原形变化而来4. 意志形(想要做)用作第二人称时，主要表达劝诱和建议的意义。注意，意志形和推量形有区别，推量形表示 推测。需要注意的是，推量形不能用于第二人称，而意志形不能用于第三人称。5. た 形/て 形5.1 音变规律仅仅适用于五段动词5.2 作用た 形表示 完成时和过去式て 形表示 中顿，如果有两个动词需要隔开来说，那么使用 て 形6. 假定形(如果)直接使用 尾变 え 段 + ば 即可，不需要区分。6.1 假定形表达方式假定形表达方式有四种： と、ば、なら、たら6.1.1 と 形式前面的动作发生之后，就 一定会 (100%) 发生后面的动作；表示一种自然状态和必定发生的事情。使用 动词原形、否定形 + とコインを入 い れると、缶 (かん) ビールが出 で る6.1.2 ば 形式主要是固定搭配、谚语和接特定的动词，基本属于固定搭配。就是上面的 PPT 的形式。平 (へい) 日 (じつ) は学 (がっ) 校 (こう) に行 い かなければならない研 けん 究 きゅう すればするほど、面 おも 白 しろ くなる。住 す めば都 みやこ 。表示习惯了都是好地方 （谚语）喉 のど 元 もと 過 す ぎれば熱 あつ さを忘 わす れる。比喻享乐时候就会忘了以前的艰辛麝 じゃ あれば香 かんば し。比喻有实力的人最终都能得到认同この仕 し 事 ごと はやればできると思 おも う。先 せん 生 せい に聞 き けば分 わ かる。学 がく 生 せい はちゃんと宿 しゅく 題 だい をすればいい接特定的动词，主要有やれば聞けばすれば固定搭配，主要有〜 ば 〜 ほど越… 就越 …否定形去 い ＋ ければならない不…的话，就不行。剩下的都表示 必然结果6.1.3 なら 形式假设前面的动作 尚未进行，而给予后面的建议和意见、后果。用法： 动词原形、否定形、名词 + なら注意不需要变化，只使用原形即可。通常只接原形。スーパーに行 い くなら、メロンを買 か ってきてください6.1.4 たら 形式动词 た 形 + なら 的省略。表示 如果事情已经发生了，而对后方的效果、后果。(已经发生了) 的话…就…用法： 动词 た 形 + ら学 がっ 校 こう に行 い ったら、先 せん 生 せい に休 やす みのことを伝 つた えてください到了学校之后，和老师说休假的事情。6.1.5 なら 和 たら 的区别なら表示前面的动作 尚未进行，多用于表示建议たら表示前面的动作 已经进行但是在接形容词和名词，区别不大。还有就是 なら 比较正式化，而 たら 比较口语化；需要注意的就是它们在接动词的区别。7. 命令形语法上比较凶悍，大多数情况不要使用。一段动词中的 よ 是一个 书面用语，口语中一般不用。7.1 命令的表达方式最后一种是 否定形式 的命令表达。在这里是双重否定，注意区分。]]></content>
      <categories>
        <category>Japanese</category>
      </categories>
      <tags>
        <tag>Japanese</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自动词和他动词]]></title>
    <url>%2FJapanese%2F%E8%87%AA%E5%8A%A8%E8%AF%8D%E5%92%8C%E4%BB%96%E5%8A%A8%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[1. 概述相当于英语中的及物动词和不及物动词。自动词是不及物的；他动词是及物的。2. 用法区别这里有个考点，就是自他动词的用法区别主语 が + 自动词自动词前面的格助词是 が主语 が + 宾语 を + 他动词他动词前面的格助词是 をを 后面还可以接自动词，表示经过、离开。3. 按照意思区分首先，我们可以按照意思来区分。如果动作可以 自然发生，不需要外力帮助，那么就是自动词。比如说，雨が降る 这里的 降る 是自动词；而 料理を食べる 中的 食べる 就是他动词。雨是自然落下的，不存在外力；料理是被吃的，存在外力。4. 自他动词按照说话立场有所不同例如，开门 開く 是自动词；而 開ける 是他动词。区别在于说话人立场不同，開く 指的是乘客看到电车门打开了，此时对于 乘客而言，车门打开不依靠外力；而 開ける 指的是，电车司机把门打开了，此时 对于电车司机而言，车门打开依靠外力指向。5. 区分技巧对于同个意思的自他动词，称为一对自他动词，主要有以下几种区分技巧。5.1 技巧一あ 是自动词， え 是他动词注意，存在反例，不一定正确。5.2 技巧二す 结尾的动词，几乎可以确定为他动词；另外一个就是他动词。5.3 技巧三注意，另一个动词没有 る 才能使用。如果没有 す，那么 る 就把 す 的地位替代掉，成为他动词。注意，这个技巧不靠谱概率较高，慎用。5.4 反例預かる：别人的东西放在自己这里 -&gt; 保管預ける：自己的东西放在别人那里 -&gt; 寄存此外还有一些反例聞く 是自动词；聞こえる 是他动词聞く 是听聞こえる 是听得到固定搭配 なる 和 する〜が〜になる，表示自然变化〜を〜にする，表示人为改变。〜になる，表示客观结果〜にする，表示主观决定入る 是自动词，入れる 是他动词]]></content>
      <categories>
        <category>Japanese</category>
      </categories>
      <tags>
        <tag>Japanese</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动词特征和分类]]></title>
    <url>%2FJapanese%2F%E5%8A%A8%E8%AF%8D%E7%89%B9%E5%BE%81%E5%92%8C%E5%88%86%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[1. 动词特征2. 动词分类如果是 汉字直接加 る，并且 不是两个假名，那么它是 五段动词。如果是 两个假名 的，那么就为 一段动词。比如上面的 帰る 有三个假名，是 五段动词。但是 見る 只有两个假名，而且，る 前面是 み(い 段假名)，是 一段动词]]></content>
      <categories>
        <category>Japanese</category>
      </categories>
      <tags>
        <tag>Japanese</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间数词]]></title>
    <url>%2FJapanese%2F%E6%97%B6%E9%97%B4%E6%95%B0%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[1. 日期一号一日（ついたち）/（いちにち）/一号二号二日（ふつか）/二号三号三日（みっか）/三号四号四日（よっか）/四号五号五日（いつか）/五号六号六日（むいか）/六号七号七日（なのか）/七号八号八日（ようか）/八号注意，八号和四号很像，八号有长音九号九日（ここのか）/九号十号十日（とおか）/十号二十号二十日（はつか）几号表示疑问何日（なんにち）/几号,几日2. 星期星期相对比较简单，记住 日月火水木金土 即可。3. 时间前后表达3.1 日今天 きょう明天あした/みょうにち昨天きのう前天おととい后天あさって3.2 星期本周こんしゅう (今周)上周せんしゅう (先周)上上周せんせんしゅう (先々周)下周らいしゅう (来周)下下周さらいしゅう (再来周)3.3 月这个月こんげつ （本月）下个月らいげつ （来月）下下个月さらいげつ （再来月）上个月せんげつ (先月)上上个月せんせんげつ (先々月)3.4 年今年ことし (今年)去年きょねん (去年) / さくねん (昨年)前年おととし / ぜんねん (前年)明年らいねん (来年)后年さらいねん (再来年)4. 一天之内的表达早上あさ上午ごぜん (午前)中午ひる (昼)下午ごご (午后)傍晚ゆうがた (夕方)晚上よる (夜)白天ひる (昼)5. 长时间末尾的表达周末周末（しゅうまつ）月末月末（げつまつ）年末年末（ねんまつ）]]></content>
      <categories>
        <category>Japanese</category>
      </categories>
      <tags>
        <tag>Japanese</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[授受关系]]></title>
    <url>%2FJapanese%2F%E6%8E%88%E5%8F%97%E5%85%B3%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[1. 我 -&gt; 他人需要注意的是， さしあげる 是 あげる 的自谦语。实际上，判断自谦语和尊敬语主要看主语成分，即 は 的修饰词。2. 他人 -&gt; 我这里有个常考点，主要是考 格助词 和后面的句末修饰的关系。需要记忆。同理，上述的 くださる 是 くれる 的尊敬语；いだだく 是 もらう 的 自谦语。主要看主语，いだだく 虽然是 自谦语，但是用于描述别人的动作，表示对别人的尊敬。3. 结合使役，逻辑颠倒！这里的逻辑颠倒，主要是 行为人 的变化。这里的第三句并没有 请求 的意思，所表达的就是 “我要说自己的意见”，而不包含有请求意味。4. 请求别人为自己做某事这里的句式才具有 请求意味；需要注意的是，いただく 的请求句式需要使用 动词的可能态，也就是动词末尾变为同行的 え 段。5. 请求别人允许自己做某事在请求句式加上 使役态，变成 请求允许 的意思。6. 注意授受关系中隐含了一个 恩惠给予 的意思。如果没有包含此意思，就不应该使用此句式。]]></content>
      <categories>
        <category>Japanese</category>
      </categories>
      <tags>
        <tag>Japanese</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[.NET 平台基础知识]]></title>
    <url>%2FCSharp%2Fdot%20NET%20%E5%B9%B3%E5%8F%B0%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[1 . 概述.NET 是微软公司开发的一个运行库和平台，它是平台无关和语言无关的，可以支持多种语言创建 .NET 应用并跨平台运行。这有点类似 Java 的 “write once, run anywhere” 的思想2. .NET 平台的构成.NET 平台主要有平台构造块（CLR, CTS, CLS）和基础类库构成。2.1 平台构造块.NET 的平台构造块有三个，分别为 CLR, CTS 和 CLS。2.1.1 CLR —— 公共语言运行库CLR 全称叫做 Common Langurage Runtime。其主要作用就是为我们定位、加载和管理 .NET 类型，同时负责底层细节的工作，如内存管理、应用托管、处理线程、安全检查等。从 Java 的角度看，CLR 相当于 Java 的 JRE2.1.2 CTS —— 公共类型系统CTS 的全称叫做 Common Type System。顾名思义，它定义了一个公共的 .NET 类型系统，描述 .NET 支持的数据结构和类型，这是 .NET 的多语言支持的特点。2.1.3 CLS —— 公共语言规范CLS 全称为 Common Language Specification。它定义了一个让所有的 .NET 语言都支持的公共类型和编程结构的子集，这主要是保证各个语言的兼容性而设计的。如果构造的 .NET 类型仅公开与 CLS 兼容的部分，那么所编写的 .NET 库就能与其他语言进行交互。2.2 基础类库.NET 除了三大构件以外，还提供了一个使用与全部 .NET 程序语言的基础库。相当于 Java 和 C ++ 中的标准库基础类库包括各种基本类型，文件 IO ，线程，GUI 以及与各种外部设备的交互等等。下面的图显示了 .NET 构件与基础类库的关系。3. C# 的特点不需要指针自动管理内存和垃圾回收所以不支持 delete 关键字类、接口、结构、枚举、委托都有正式的语法结构可以重载操作符支持基于特性的编程属性(property) 而非字段(field)也就是说可以直接用点操作符而不是使用 getter 和 setter。await 和 async 关键字，类似同步调用的异步调用方法同时还具有其他语言的泛型、匿名类、反射等特性。4. 托管代码和非托管代码和 Java 一样，C# 语言需要生成类似 Java 字节码的一种中间代码才能够运行。所以 C# 编译生成的代码只能在 .NET 运行库中执行。就像 Java 必须使用 JRE 运行一样正确的来说，这种必须在 .NET 运行库中执行的代码被称为托管代码(managed code)；包含托管代码的二进制单元称为程序集(assembly)。反之，不能直接在 .NET 运行库承载的代码被称为非托管代码(unmanaged code)5. 其他支持 .NET 的编程语言除了 C# 以外，.NET 框架也支持其他的编程语言。实际上，在安装了 Visual Studio 之后，微软会提供 C#, Visual Basic, C++/CLI , JavaScript 和 F# 的 .NET 支持6. .NET 程序集概览为了实现平台无关性，.NET 采用了程序集的概念。不同的语言通过特定的编译器，编译得到一个中间语言(IL)和元数据，随后打包成一个程序集。需要注意的是，.NET 中间语言拥有很多种缩写，IL 只是其中一种，其余的还有 MSIL 或者 CIL。IL, MSIL, CIL 都是等价的，指的就是中间语言。程序集是二进制大对象所打包成的集合，大致分为两类；一类是应用程序，拥有一个 .exe 入口。另一类是库，具有 .dll 扩展名。CIL 类似于 Java 的字节码，也是平台无关性的一个重要的原因。在运行时，CIL 通过 JIT 编译器编译成为特定的机器码，在不同的设备上进行运行。程序集除了包含 CIL 以外，还包含了元数据。元数据是许多 C# 特性的支柱（例如反射，晚期绑定等），同时，一些现代 IDE (Visual Studio)可以利用元数据进行智能感知。此外，程序集还包含了描述程序集本身的元数据，它们叫做清单(manifest)。7. CTSCTS 是 .NET 的公共类型系统，它包括五个内容：类接口结构枚举委托大体上与 Java 类似，下面重点讲讲和 Java 不同的部分。7.1 委托(delegate)这可以算是 C# 相对 Java 的一个进步的方面。委托相当于一个类型安全的函数指针，实际上委托是一个派生自 System.MultcastDelegate 的类，使用 delegate 关键字可以声明一个委托。1delegate int BinaryOp(int x, int y);这样，就可以使用委托来实现回调，而不需要像 Java 一样使用臃肿的接口来进行回调动作。7.2 结构(struct)C# 的结构和 C99 之后的结构很像，用法也趋近；可以包含字段、构造函数、定义方法等。不过一般当做一个容器类来使用。8. 内建类型同样，.NET 具有一个內建的核心数据类型，用于兼容不同平台的类型结构。下表给出了一个 CTS 数据类型和 C# 、C++ 的相应对比。CTSCC++System.Bytebyteunsigned charSystem.SBytesbytesigned cahrSystem.Int16shortshortSystem.Int32intint 或 longSystem.Int64longint64_tSystem.UInt16ushortunsigned shortSystem.UInt32uintunsigned int 或 unsigned longSystem.UInt64ulongunsigned int64_tSystem.SinglefloatfloatSystem.DoubledoubledoubleSystem.Objectobjectobject^System.Charcharwchar_tSystem.StringstringString^System.DecimaldecimalDecimalSystem.Booleanboolbool9. CLRCLR 类似于 JVM，利用 mscoree.dll 库来进行 .NET 程序加载工作。下图是 mscoree.dll 的工作流。10. 名称空间(namespace)这个特性类似于 Java 的 package 。语法和 C++ 中的名称空间语法相同，使用 using 来引入名称空间（相当于 Java 的 import） 来进行使用。123456789using System;public class MyApp&#123; static void Main() &#123; Console.WriteLine("Hi from C#"); &#125;&#125;当然，同 Java 一样，在使用对应的名称空间之前，首先要引入依赖程序集。]]></content>
      <categories>
        <category>CSharp</category>
      </categories>
      <tags>
        <tag>CSharp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C# Basic]]></title>
    <url>%2FCSharp%2FCSharp%20Basic%2F</url>
    <content type="text"><![CDATA[&emsp;1. Hello, World!&emsp;2. 基本类型&emsp;&emsp;2.1 声明和初始化&emsp;&emsp;2.2 默认值&emsp;&emsp;2.3 基本类型的对象成员&emsp;&emsp;2.4 Big Number&emsp;3. 字符串&emsp;&emsp;3.1 逐字字符串&emsp;&emsp;3.2 相等性判别&emsp;&emsp;3.3 字符串格式化&emsp;4. 类型转换&emsp;&emsp;4.1 checked 和 unchecked&emsp;5. 隐式类型 var&emsp;&emsp;真正用途1. Hello, World!123456789101112namespace SimpleCSharpApp&#123; class Program &#123; static void Main(string[] app) &#123; Console.WriteLine("Hello, World!"); Console.ReadLine(); &#125; &#125;&#125;​ 基本的编码规范：区分大小写命名空间、类、成员（包括方法）采用大驼峰大括号另起一行2. 基本类型C# 中的基本类型都是对象，事实上，基本类型的关键字都对应一个 System 命名空间中的一个类显然是相对于 Java 的重大进步下表给出了 C# 基本类型和 CLS，系统类型的对应关系。基本类型符合 CLS？系统类型范围作用boolTSystem.Booleantrue or false布尔值sbyteFSystem.SByte-128 ~ 127有符号的 8 bit 整数byteTSystem.Bute0 ~255无符号的 8 bit 整数shortTSystem.Int16-32768 ~32767有符号的 16 bit 整数ushortFSystem.UInt160 ~ 65535无符号的 16 bit 整数intTSystem.Int32-$2^{31}$ ~ $2^{31} -1$带符号的 32 bit 整数uintFSystem.UInt320 ~ $2^{32}$无符号的 32 bit 整数longTSystem.Int64-$2^{63}$ ~ $2^{63} -1$有符号的 64 bit 整数ulongFSytem.UInt640 ~ $2^{64}$无符号的 64 bit 整数charTSystem.CharU+0000 ~U+ffff16 bit 的 Unicode 字符floatTSystem.Single$-3.4 \times 10^{38} \sim +3.4 \times 10^{38}$32 bit 浮点数doubleTSystem.Double$\pm 5.0 \times 10^{-324} \sim \ \pm 1.7 \times 10 ^{308}$64 bit 浮点数decimalTSystem.Decimal$(-7.9 \times 10^{28} \sim 7.9 \times 10^{28})/(10^{0 \sim 28})$128 bit 带符号数stringTSystem.String受系统内存限制字符串objectTSystem.Object任何类型都能保存在一个 object 变量中所有类的基类2.1 声明和初始化C# 变量声明和初始化采用 C 系语言的一贯语法：123456int myInt = 0;string myString;myString = "This is my string";bool b1 = true, b2 = false, b3 = true;当然也可以用全名来声明一个基本变量，不过基本没人这么干。2.2 默认值与 Java 一样，C# 的基本变量都具有一定的默认值。bool 默认为 false数值类型默认为 0，如果是浮点数，则为 0.0char 类型默认为空字符BigInteger 默认为 0DateTime 类型设置为 1/1/0001/ 12:00:00 AM对象引用默认为 null2.3 基本类型的对象成员C# 与 Java 最大的区别就是，取消了原始类型，所有的类型都是对象。所以，基本对象也具有成员，通常集成了一些对本类型的一些处理方法，和 Java 中的 Integer Long 等类型不同。需要注意的是，基本类型内置了 Parse() 方法，用于将 string 字面量转换成对应的对象。1bool b = bool.Parse("True");2.4 Big Number与 Java 一样，C# 也内置了 BigNumber 类型，它需要使用 System.Numerics 命名空间才能使用。3. 字符串C# 的字符串和 Java 的大体相似，只有少数的扩展功能。字符串使用 string 定义，而不是使用大写的。同样，支持加号拼接、转义、StringBuilder。字符串也是不可变的。不过，C# 字符串相对于 Java 来说也有一些扩展功能。3.1 逐字字符串实际上就是原始字符串，在字符串引号前加上 @，则编译器不会对转义字符进行转义，同时，空格也会得到保留（即可以声明多行字符串）。123456string raw = @"C:\MyApp\bin\Debug";string multipleLine = @"This is mutiple line string";3.2 相等性判别谢天谢地，C# 支持了操作符重载功能，也就是说，可以用 == 和 != 进行字符串相等性判别，而不是 Java 的引用判别。与此同时，也可以使用传统的 Equals() 来进行字符串相等性判断。123string s1 = "hello";Console.WriteLine(s1 == "hello"); // trueConsole.WriteLine(s1.Equals("hello"));3.3 字符串格式化C# 中使用 {0} {1} 等可以实现字符串格式化。123string hehe = "hhe";string s = "&#123;0&#125;, &#123;1&#125;, $hehe";Console.WriteLine(string.Format(s, 1, 2));同时也可以使用基本的格式化字符，可以直接使用于控制台输出。1Console.WriteLine("c format: &#123;0:c&#125;", 99999); //$99999.00比起 Java 只能用格式化字符，不知道高到哪里去了。下面是一些常用的格式化字符：格式化字符作用C 或 c用于格式化货币，这个标识会以当地的货币符号为前缀D 或 d用于格式化十进制数，还可以指定最小的填充个数E 或 e用于指数计数法，字母的大小写决定了数字后的 E 的大小写F 或 f用于顶点小数的格式化，也可以指定最小的填充个数G 或 g代表 general。这个字符能用来将一个数格式化为定点或者指数格式N 或 n用于基本的数值格式化（带逗号）X 或 x用于十六进制，字母的大小写决定了十六进制字母的大小写其中，给定的占位符由冒号分隔，如上面的 {0:c}能指定填充个数的，在格式化字符后添加个数。例如：{0:d9}4. 类型转换与 C 系 语言一样，C# 对于数据类型，会使用隐式向上转换，或者称为宽化。使用 () 对类型进行强制转换(cast)，也叫做窄化。12345short s1 = 30000;short s2 = 30000;s1 + s2; // 转换为 int(short)(s1 + s2); // 强制转换为 short，丢失数据。4.1 checked 和 unchecked当我们不希望数据丢失时，可以使用 checked，这个关键字在数据出现溢出时会抛出异常。1checked((short)(s1 + s2)); // OverflowException同样也可以使用 checked 块。1234checked &#123; byte sum = (byte)Add(b1, b2); Console.WriteLine("sum = &#123;0&#125;", sum);&#125;当然，如果运算过多，我们可以直接开启 checked 编译选项，此时对所有运算都会进行 checkede 操作。当然，这个时候，我们也会有一些不想被 check 的运算，那么就可以使用 unchecked 关键字来避免 checked。用法类似 checked，就不举例了。5. 隐式类型 varC# 中，可以利用 var 关键字来让编译器对变量的类型进行自动推断。这个特性有点类似 C++ 11 的 auto1var myInt = 0;需要注意的是，var 仍然是强类型的，只不过类型并不在编辑时确定，但是也是在编译期间就确定类型，而且不能改变。这和 JS 中的 var 有很大不同。真正用途虽然有这么好用的特性，但是 C# 并不鼓励滥用，如果需要 int，那么就声明 int。这个特性通常只在 LINQ 查询中使用，由于某些情况下无法得知数据库查询结果的真正类型，所以此时使用 var 是合理的。1var subset = from i in numbers where i &lt; 10 select i;]]></content>
      <categories>
        <category>CSharp</category>
      </categories>
      <tags>
        <tag>CSharp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C# Control Flow]]></title>
    <url>%2FCSharp%2FCSharp%20Control%20Flow%2F</url>
    <content type="text"><![CDATA[1. if/else只接受布尔值2. 逻辑运算符&amp;&amp; || !需要注意的是，&amp;&amp; 和 || 在有必要的时候都会“短路”，也就是说如果只检查一个表达式就能确定 if 的布尔值，那么就不会检查另一个了。3. switchswitch 相比 Java 来说，可以支持 字符串 和 枚举 值。不过并不支持类型检测，相比 Kotlin 来说差了一截。4. for123for(int i = 0; i &lt; 4; i++) &#123; // for body&#125;5. foreach遗憾的是，C# 将 foreach 语法用了一个单独的关键字 foreach123foreach(string c in carTypes) &#123; Console.WriteLine(c);&#125;当然也可以使用隐含类型 var123foreach(var i in linqSubset) &#123; Console.Write("&#123;0&#125;", i);&#125;6. while/do-while和 Java 没什么不同；需要注意一下 do while 最后要有个分号。123while(condition) &#123; // hehe&#125;123do &#123; // hehe&#125;while(condition);]]></content>
      <categories>
        <category>CSharp</category>
      </categories>
      <tags>
        <tag>CSharp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C# Method]]></title>
    <url>%2FCSharp%2FCSharp%20Method%2F</url>
    <content type="text"><![CDATA[1. 定义C# 中的方法定义和 Java 没有区别。1234int Add(int x, int y)&#123; return x + y;&#125;2. 默认按值传递C# 默认的参数传递是 按值传递 的；也就是说，方法中拿到的参数实际上是实参的一个 副本3. 输出参数C# 支持 输出参数， 这是 C/C++ 语言中常用的一种技巧；即，通过对传入的指针进行赋值，然后在调用完毕后进行指针解引用，从而得到多个返回值。C# 没有指针，所以使用了 out 关键字用作指明输出参数。使用输出参数的方法定义如下：1234void Add(int x, int y, out int ans)&#123; ans = x + y;&#125;调用时， 也需要 使用 out 关键字。12int ans;Add(90, 90, out ans);用作输出参数的变量可以不进行初始化，如同上面的 ans 一样；但是， 必须 在方法内部对输出参数进行赋值，否则会报错。使用这个技巧，我们可以一次性返回多个值。1234void Hehe(out int a, out int b, out int c)&#123; // hehe&#125;4. 按引用传递C# 比 Java 高明的地方就在于，C# 可以 按引用传递，所以可以做到 Java 比较难做到的 交换两个 int；只要使用 ref 关键字，指明需要按照引用传递的参数即可123456public static void swapStrings(ref string s1, ref string s2)&#123; string temp = s1; s1 = s2; s2 = temp;&#125;此时，由于两个参数是按照 引用 传递的，所以上述代码是有效的。5. 不定参数同 Java 一样，C# 也支持不定参数。只要使用 params 关键字指明不定参数即可。1234void addToList(params int[] args)&#123; // Add to list&#125;与 Java 一样，不定参数只支持 数组 类型，而不支持其他集合类型。需要注意的是，C# 只支持 一个 params 参数， 而且必须是参数列表中 最后一个 参数。6. 可选参数C# 也支持可选参数（也叫做 默认参数），即给参数赋予默认值的行为。1234static void EnterLogData(string message, string owner = "Programmer")&#123; // hehe&#125;只要在 定义 方法时，给形参进行 “赋值” 即可。需要注意的是，可选参数的默认值必须在 编译时确定；也就是说，不能将一些运行时才能确定的量作为默认值1234static void EnterLogData(string message, string owner = "Programmer", DateTime timeStamp = DateTime.Now) &#123; // ERROR! // DateTime.Now determined at runtime!&#125;7. 命名参数C# 还支持 命名参数，即，通过形参名字来指定对应的实参，而不需要遵守参数顺序。123DisplayFancyMessage(message: "Wow! Very Fancy indeed!", textColor: ConsoleColor.DarkRed, backgroundColor: ConsoleColor.White)通过 冒号 (:) 来分隔形参和实参。通过命名参数，可以很好地结合可选参数来使用。8. 方法重载和其他现代语言一样，C# 也支持方法重载。注意方法签名只由两部分决定：方法名字和方法参数（类型和数量）。和 Java 的方法重载没什么区别。]]></content>
      <categories>
        <category>CSharp</category>
      </categories>
      <tags>
        <tag>CSharp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C# 复杂类型]]></title>
    <url>%2FCSharp%2FCSharp%20%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[1. 数组使用类似 Java 的语法进行数组初始化123int[] intArray = new int[];string[] stringArray = new string[] &#123;"1", "2", "3"&#125;;当然，数组也可以使用 var 声明12// c is a int arrayvar c = new[] &#123;1, 2, 3&#125;;1.1 多维数组C# 比较神奇的一点就是它有 两种 多维数组类型：矩形数组和交错数组。1.1.1 矩形数组矩形数组时一个每一行长度都相等的多维数组12// 6*6 的数组int [,] matrix = new int[6, 6];1.1.2 交错数组交错数组是 数组的数组，其中包括了内部数组。12// 5 个不同数组int[][] jagArray = new int[5][];1.1.3 区别矩形数组是 一个数组交错数组是 数组的数组，实际上也就是 Java 的普通多维数组矩形数组涉及方法调用，而交错数组只涉及内存访问。交错数组比矩形数组要快。1.2 数组基类数组实际上也是一个对象，可以调用基类 System.Array 的静态方法来进行一些工作。主要的方法有：Clear()CopyTo()LengthRankReverse()Sort()2. 枚举2.1 声明与使用使用 enum 定义枚举。默认会以 int 来存储枚举值。1234567enum EmpType&#123; Manager, // 0 Grunt, // 1 Contractor, // 2 VicePresident = 101 // 101&#125;可以通过 冒号 (:) 来指定枚举储存的类型1234567enum EmpType : byte&#123; Manager, // 0 Grunt, // 1 Contractor, // 2 VicePresident // 3&#125;2.2 获取枚举值每个枚举对象都有个 ToString() 方法，可以用它获取枚举的 名字123EmpType emp = EmpType.Manager;emp.ToString(); // "Manager"如果想获取枚举存储的变量值，那么使用强制转换即可。1Console.WriteLine("&#123;0&#125; = &#123;1&#125;", emp.ToString(), (byte)emp);System.Enum 还提供了 GetValues() 方法来获取枚举中的所有成员。2.3 注意事项需要注意的是，switch 可以接受 0 作为 枚举值 进行处理；但是，对于其他的数值则不行。所以最好还是使用类似 Java 的枚举使用方法。3. 结构 (struct)结构类型和类很相似，都可以具有构造函数、域和方法；同时也可以给它们附上可见性修饰符。12345678910struct Point&#123; public int x; public int y; public void Display() &#123; Console.WriteLine("X = &#123;0&#125;, Y = &#123;1&#125;", x, y); &#125;&#125;结构和类的不同点主要在于：结构是一个 值类型，而类是一个 引用类型。下面会详细描述两种类型的不同点。需要注意的是，结构在声明时必须为 每个域 赋值；或者使用 默认构造函数，否则在使用结构时就会报错。4. 值类型和引用类型值类型分配在栈中，引用类型分配在堆中值类型在使用等号(=)赋值时，对应内容的值被复制，而引用类型只复制指向对象的引用即，值类型在复制时，构造出了新的对象而引用类型只是复制指针，并没有构造出新的对象基本类型和枚举、结构都是值类型类、数组、字符串都是引用类型结构中包含引用类型时，复制结构，只复制引用类型的引用按值传递引用类型时，引用本身进行复制，然后传入方法中，不会改变原有的引用的指向按引用传递引用类型时，引用本身被传入方法中，会改变原有引用的指向5. 可空类型可空类型(nullable-type) 只能用于 值类型。它使用 ? 来表示一个值类型是 可以为空的。1int? nullableInt = null;这通常用于数据库编程中。此语法不能用于引用类型，因为引用类型可以为空。这和 Kotlin 中的 ? 不同，Kotlin 中不指明 ? 的类型都是不可空的。可以使用 ?? 操作符为空类型赋予初始值。1int myData = dr.GetIntFromDatabase() ?? 100;]]></content>
      <categories>
        <category>CSharp</category>
      </categories>
      <tags>
        <tag>CSharp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin 委托属性]]></title>
    <url>%2FKotlin%2FKotlin%20%E5%A7%94%E6%89%98%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[1. 使用场景有些时候，对于一些特殊的变量，虽然我们每次都去手动生成它们，但是如果一次性生成它们，然后存进库中会更加方便，例如：lazy 属性：只在第一次访问它们的时候计算它们。observable 属性：当它被修改的时候，会通知它的监听者。将属性储存在一个 Map 中，而不是用字段存储。对于这些使用场景，Kotlin 支持使用委托属性2. 声明123class Example &#123; var p: String by Delegate()&#125;声明委托属性的语法为：val/var &lt;property name&gt;: &lt;Type&gt; by &lt;expression&gt;。其中，在 by 之后的表达式就是委托操作。上面的例子说明了 p 变量的操作将会委托给 Delegate 类来进行。为了替代 p 的 getter 和 setter，Delegate 类必须提供 getValue() 和 setValue() 方法，委托之后，对 p 的调用操作将会由这两个方法来完成。123456789class Delegate &#123; operator fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): String &#123; return "$thisRef, thank you for delegating '$&#123;property.name&#125;' to me!" &#125; operator fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: String) &#123; println("$value has been assigned to '$&#123;property.name&#125; in $thisRef.'") &#125;&#125;那么当我们进行如下调用：12val e = Example()println(e.p)打印结果为1Example@33a17727, thank you for delegating ‘p’ to me!同理，进行如下操作1e.p = "NEW"将会打印如下结果：1NEW has been assigned to ‘p’ in Example@33a17727.3. 需要满足的条件对于只读属性(val)，被委派的类必须提供 getValue() 方法，该方法必须拥有如下参数接收者：必须是当前属性的拥有者（属性所属的类）或者其超类的实例对象。元数据：必须是 KProperty&lt;*&gt; 或者它的超类getValue() 必须拥有返回值，而且类型与当前委托的属性类型相同。对于可变属性(var)，被委托的类必须额外提供一个 setValue() 方法，该方法必须拥有如下参数：接收者：和 getValue() 相同元数据：和 getValue() 相同新值：其类型必须和所委托的类型相同，或者是它的超类。getValue() 和 setValue() 方法既可以是被委托类的成员，也可以是它的扩展。两个方法都需要使用 operator 来修饰。4. 一般的委托场景Kotlin 的标准库提供了一些工厂方法，用来实现篇头所说的几种场景。4.1 lazy 变量Kotlin 提供了一个 lazy() 方法用于 lazy 变量的生成。lazy() 方法接受一个 lambda 表达式，返回一个 Lazy&lt;T&gt; 实例，用于委托属性。123456789val lazyValue: String by lazy &#123; println("computed!") "Hello"&#125;fun main(args: Array&lt;String&gt;) &#123; println(lazyValue) println(lazyValue)&#125;main 中的第一个调用会触发 lazy()进行 lazyValue 的计算，而第二个调用只会返回 lazyValue 的值。结果为123computed!HelloHello默认情况下，lazy() 的调用是同步的。也就是说，只有一个线程会进行变量的计算，完成后，所有的线程都能看到其结果。如果不需要初始化同步，那么可以通过将 LazyThreadSafetyMode.PUBLICATION 作为参数传给 lazy() 方法来实现。如果确保变量的初始化只会有一个线程来完成，那么可以将 LazyThreadSafetyMode.NONE 作为参数传给 lazy()，这样一来，Kotlin 就不会对该变量的生成启用线程安全机制。4.2 ObservableKotlin 标准库用 Delegates.observable() 来实现可观察属性(observable property)。1234567891011121314import kotlin.properties.Delegatesclass User &#123; var name: String by Delegates.observable("&lt;no name&gt;") &#123; prop, old, new -&gt; println("$old -&gt; $new") &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val user = User() user.name = "first" user.name = "second"&#125;Delegates.observable() 接受两个参数：一个是初始化值，另一个是 handler。Handler 会在每次我们对变量进行赋值操作后被调用。它具有三个参数：被赋值的变量旧的变量值新的变量值上面的例子的打印结果为：12&lt;no name&gt; -&gt; firstfirst -&gt; second使用 vetoable() 代替 observable() 方法可以对变量赋值进行拦截操作。vetoable() 的 handler 会在每次赋值操作前被调用。4.3 在 Map 中储存属性这个场景通常在进行 JSON 解析或者对其他数据进行动态解析时常用的。对于 JSON 数据，我们通常将其解析为一个 Map，所以，我们可以通过对 Map 进行委派，从而实现反序列化操作。1234class User(val map: Map&lt;String, Any?&gt;) &#123; val name: String by map val age: Int by map&#125;一个调用的例子：1234val user = User(mapOf( "name" to "John Doe", "age" to 25))12println(user.name) // Prints "John Doe"println(user.age) // Prints 25User 类会通过 Map 将数据取出。这个方法同样适用于 var 变量，只要把 Map 改成 MutableMap 即可。]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin 委托模式]]></title>
    <url>%2FKotlin%2FKotlin%20%E5%A7%94%E6%89%98%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1. 委托模式委托模式是软件设计模式中的一项基本技巧。在委托模式中，有两个对象参与处理同一个请求，接受请求的对象将请求委托给另一个对象来处理。委托模式是一项基本技巧，许多其他的模式，如状态模式、策略模式、访问者模式本质上是在更特殊的场合采用了委托模式。委托模式使得我们可以用聚合来替代继承。2. Java 例子1234567891011121314151617181920212223242526272829303132333435363738interface I &#123; void f(); void g(); &#125; class A implements I &#123; public void f() &#123; System.out.println("A: doing f()"); &#125; public void g() &#123; System.out.println("A: doing g()"); &#125; &#125; class B implements I &#123; public void f() &#123; System.out.println("B: doing f()"); &#125; public void g() &#123; System.out.println("B: doing g()"); &#125; &#125; class C implements I &#123; // delegation I i = new A(); public void f() &#123; i.f(); &#125; public void g() &#123; i.g(); &#125; // normal attributes public void toA() &#123; i = new A(); &#125; public void toB() &#123; i = new B(); &#125; &#125; public class Main &#123; public static void main(String[] args) &#123; C c = new C(); c.f(); // output: A: doing f() c.g(); // output: A: doing g() c.toB(); c.f(); // output: B: doing f() c.g(); // output: B: doing g() &#125; &#125;C 将 I 接口的工作委托给 A 或者 B 来做。可以看出，Java 中的委托模式的缺点在于要求比较多的代码。3. Kotlin 的委托模式而在 Kotlin 中，委托模式要求的代码量非常低。只需要一个 by 表达式就能实现委托模式1234567891011121314interface Base &#123; fun print()&#125;class BaseImpl(val x: Int) : Base &#123; override fun print() &#123; print(x) &#125;&#125;class Derived(b: Base) : Base by bfun main(args: Array&lt;String&gt;) &#123; val b = BaseImpl(10) Derived(b).print() // prints 10&#125;在这里 by 表达式表示，变量 b 会储存在类 Derived 中，编译器会在 Derived 生成所有的 Base 的方法，并将它们都用 b 来执行。4. 注意事项不过需要注意的是，Kotlin 的委托目前只支持初始值。也就是一旦类被建立，那么委托就不可改变，即使委托的对象是 var。只有通过重新建立类才能改变委托。]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Retrofit2 使用简明手册]]></title>
    <url>%2FAndroid%2FRetrofit%2FRetrofit2%20%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[1. 介绍Retrofit 是 Square 公司出品的 Android 开源网络框架，使用注解和代理实现各项 HTTP 操作和 body 解析处理等。Retrofit2 通过与 Square 公司的另一开源库 OkHttp3 合并，由 OkHttp 进行 HTTP 操作，重定向响应，以及缓存支持。2. 初始化设置2.1 添加依赖1compile &apos;com.squareup.retrofit2:retrofit:2.1.0&apos;注意现在已经是 Retrofit2 的年代了。2.2 配置 Proguard12345678910# Platform calls Class.forName on types which do not exist on Android to determine platform.-dontnote retrofit2.Platform# Platform used when running on RoboVM on iOS. Will not be used at runtime.-dontnote retrofit2.Platform$IOS$MainThreadExecutor# Platform used when running on Java 8 VMs. Will not be used at runtime.-dontwarn retrofit2.Platform$Java8# Retain generic type information for use by reflection by converters and adapters.-keepattributes Signature# Retain declared checked exceptions for use by a Proxy instance.-keepattributes Exceptions3. 基本使用3.1 创建 ApiService interface创建一个 interface，用于储存需要进行的网络操作 API1234public interface GitHubService &#123; @GET("users/&#123;user&#125;/repos") Call&lt;List&lt;Repo&gt;&gt; listRepos(@Path("user") String user);&#125;其中，方法的返回值是一个 Call 对象，泛型内部的 List&lt;Repo&gt; 是 GET 请求获取到的 HTTP Body 解析后的内容。方法的参数通过注解来区分是 Request 的 URL 参数还是 Body 参数。方法顶上的注解表明了该请求的 HTTP method，括号中的内容是请求所涉及到的 URL 部分。URL 的基础部分由 Retrofit 类构建时指定。3.2 构建 Retrofit 类，获取 ApiService 实例12345Retrofit retrofit = new Retrofit.Builder() .baseUrl("https://api.github.com/") .build();GitHubService service = retrofit.create(GitHubService.class);3.3 通过 ApiService 实例发起请求发起同步请求12Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos;repos.execute();发起异步请求12Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos;repos.enqueue(new CallBack());3.4 取消请求1repos.cancel();4. 可变 URL 和 GET 请求参数4.1 可变 URL12@GET("group/&#123;id&#125;/users")Call&lt;List&lt;User&gt;&gt; groupList(@Path("id") int groupId);上面的 id 在程序运行时可能会动态变化，对于这种参数， retrofit2 采用 {} 将其包住进行区分，并在方法形参中使用 @Path 注解来指定动态参数。4.2 Query 参数12@GET("group/&#123;id&#125;/users")Call&lt;List&lt;User&gt;&gt; groupList(@Path("id") int groupId, @Query("sort") String sort);通过使用 @Query 注解来指定请求参数。同时也可以直接在 URL 中添加。1@GET("users/list?sort=desc")如果 query 参数过于复杂，可以使用 Map 对象来指定，此时需要使用 @QueryMap 注解来表示12@GET("group/&#123;id&#125;/users")Call&lt;List&lt;User&gt;&gt; groupList(@Path("id") int groupId, @QueryMap Map&lt;String, String&gt; options);5. 通过 Body 请求12@POST("users/new")Call&lt;User&gt; createUser(@Body User user);POST 等方法均是通过 HTTP Body 来传输内容的， retrofit 中通过使用 @Body 注解来表示该参数通过 HTTP Body 来进行传输。Body 的类型会通过转换器(converter)反序列化成对应的类，如果没有指定转换器，则只能使用 Okhttp 的 RequestBody 作为转换的对象。6. Form URL encode 数据使用 @FormUrlEncoded 注解来发送 application/x-www-form-urlencoded 类型的数据。使用 @Field 注解来指示表单的项。123@FormUrlEncoded@POST("user/edit")Call&lt;User&gt; update: 2016-11-26application/x-www-form-urlencoded 和 application/json 的异同前者说明，客户端会将表单参数通过 URL 加密传输，后者说明客户端会使用 HTTP Body 来传送 json。application/x-www-form-urlendoced12&gt; &#123; Name : &apos;John Smith&apos;, Age: 23&#125;&gt;application/json12&gt; Name=John+Smith&amp;Age=23&gt;7. 上传文件使用 @Multipart 注解来表示要上传文件123@Multipart@PUT("user/photo")Call&lt;User&gt; update: 2016-11-267. 指定 Header通过 @Header 注解来指定 HTTP Header123@Headers("Cache-Control: max-age=640000")@GET("widget/list")Call&lt;List&lt;Widget&gt;&gt; widgetList();这个方法只适合用于单独的一个或者几个 API 设置头，如果需要加入公有头，则需要使用 OkHttp 拦截器实现。8. 指定转换器retrofit 除了 okhttp 默认的 RequestBody 外，还提供了其他知名的序列化和反序列化的库用作转换器。其中包括：Gson: com.squareup.retrofit2:converter-gsonJackson: com.squareup.retrofit2:converter-jacksonMoshi: com.squareup.retrofit2:converter-moshiProtobuf: com.squareup.retrofit2:converter-protobufWire: com.squareup.retrofit2:converter-wireSimple XML: com.squareup.retrofit2:converter-simplexmlScalars (primitives, boxed, and String): com.squareup.retrofit2:converter-scalars通过在构建 Retorfit 实例时，使用 addConverterFactory() 来实现。123456Retrofit retrofit = new Retrofit.Builder() .baseUrl("https://api.github.com") .addConverterFactory(GsonConverterFactory.create()) .build();GitHubService service = retrofit.create(GitHubService.class);参考资料：Retrofit 主页：http://square.github.io/retrofit/]]></content>
      <categories>
        <category>Android</category>
        <category>Retrofit</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Retrofit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin 异常]]></title>
    <url>%2FKotlin%2FKotlin%20%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[1. 概述和 Java 一样，Kotlin 的异常都继承于 Throwable 类。每个异常都拥有 message stacktrace 和 cause2. 抛出异常使用 throw 抛出一个异常1throw MyException("Hi There!")注意到，没有 new3. 捕获异常使用 try-catch-finally 来进行异常捕获和处理。123456789try &#123; // some code&#125;catch (e: SomeException) &#123; // handler&#125;finally &#123; // optional finally block&#125;可以有多个 catch 块，finally 块是可选的；但是必须存在至少一个 catch 块，否则就必须有 finally。4. try 表达式try 也可以是一个表达式，也就是说它可以拥有返回值1val a: Int? = try &#123; parseInt(input) &#125; catch (e: NumberFormatException) &#123; null &#125;表达式的返回值不是 try 块的最后一个值，就是 catch 块的最后一个值。finally 块中的语句不会被作为返回值返回。5. 已检查异常不像 Java，Kotlin 中没有已检查异常；也就说它不需要也不会在函数头进行 throws 声明。原因在于，如果类似 Java 拥有已检查异常，那么：1Appendable append(CharSequence csq) throws IOException;当我在调用这个方法时，我就必须进行异常捕获（有很多方法内部不允许再次抛出异常）。123456try &#123; log.append(message)&#125;catch (IOException e) &#123; // Must be safe&#125;很多时候，就会写出上面的代码，由于生吞了异常，这是一种非常不好的写法，同时这也违反了《Effective Java》中的条款。《Effective Java》第六十五条：不要忽略异常同样也有很多关于已检查异常的批评意见see here]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin 扩展类型]]></title>
    <url>%2FKotlin%2FKotlin%20%E6%89%A9%E5%B1%95%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[1. 介绍Kotlin 支持类似 C# 的对类进行扩展，而不需要对该类进行继承操作。这个特性被称作扩展(extension)。2. 方法的扩展给类写一个扩展方法很简单，只需要使用类成员运算符(.)即可。12345fun MutableList&lt;Int&gt;.swap(index1: Int, index2: Int) &#123; val tmp = this[index1] // 'this' corresponds to the list this[index1] = this[index2] this[index2] = tmp&#125;上面的例子中，我们给 MutableList&lt;Int&gt; 类扩展了一个方法 swap()。此时，我们称 MutableList&lt;Int&gt; 为接收者类型，例子中的 this 标识符指的就是接收者类型的对象本身。对类进行方法扩展后，我们就可以调用普通方法一样调用这个方法。12val l = mutableListOf(1, 2, 3)l.swap(0, 2) // 'this' inside 'swap()' will hold the value of 'l'当然，可以看出 MutableList 是个泛型类，同样的，我们的扩展方法也支持泛型特性。12345fun &lt;T&gt; MutableList&lt;T&gt;.swap(index1: Int, index2: Int) &#123; val tmp = this[index1] // 'this' corresponds to the list this[index1] = this[index2] this[index2] = tmp&#125;3. 方法的扩展是静态的这指的是决定扩展方法调用的，是形式上的调用对象类型，而非实际的调用对象类型。例如：12345678910111213open class Cclass D: C()fun C.foo() = "c"fun D.foo() = "d"fun printFoo(c: C) &#123; println(c.foo())&#125;printFoo(D())此时，printFoo() 的结果是 “c” 而不是 “d”。虽然传入 printFoo() 方法的是 D 对象，但是在该方法定义中，使用的是 C 的 foo() 方法，所以即使传入的是 D，而结果却依然是 C 的打印结果。这就是扩展方法的静态特性。4. 方法扩展的优先级和重载4.1 优先级如果类中已经存在了一个和我们扩展方法相同的成员，那么在方法调用时，优先调用类成员12345class C &#123; fun foo() &#123; println("member") &#125;&#125;fun C.foo() &#123; println("extension") &#125;如果我们调用对于一个任意的 C 对象调用 c.foo() ，结果都会是 “menber” ，而不是 “extension”。4.2 重载但是，如果我们的扩展方法和类成员拥有不同的函数签名，那么两者互不干涉，就像函数重载一样。12345class C &#123; fun foo() &#123; println("member") &#125;&#125;fun C.foo(i: Int) &#123; println("extension") &#125;如果我们调用 C().foo(1)，则依旧会打印 “extension”5. 可以为空的接收者扩展可以使用一个为空的接收者类型，这样的扩展方法在对象为 null 的时候仍然能被调用，此时可以在扩展方法中进行 null 检查，对于调用者来说，就直接调用方法即可。123456fun Any?.toString(): String &#123; if (this == null) return "null" // after the null check, 'this' is autocast to a non-null type, so the toString() below // resolves to the member function of the Any class return toString()&#125;注意到，Kotlin 在经过 if(this == null) 这一 null 检查之后，会自动将对象 cast 成为一个非空对象。6. 属性的扩展与方法的扩展一样，Kotlin 中同样可以对属性进行扩展。12val &lt;T&gt; List&lt;T&gt;.lastIndex: Int get() = size - 1需要注意的是，由于扩展采用静态处理，而不是插入一个新成员，所以，扩展的属性没有 backing field 的支持，因此，扩展属性不能被初始化，它们只能用显式的 getter 和 setter 来进行初始化。7. 友元对象的扩展如果一个类具有友元对象(Companion Object)，那么，也可以对其进行扩展。1234567class MyClass &#123; companion object &#123; &#125; // will be called "Companion"&#125;fun MyClass.Companion.foo() &#123; // ...&#125;扩展的友元对象就像类的友元对象一样，使用类名进行调用。8. 扩展类型的作用域通常，我们会将扩展定义在 top-level，此时就需要使用 import 语句来调用这个扩展。9. 将扩展作为类成员我们可以在一个类中定义另一个类的扩展方法12345678910111213141516class D &#123; fun bar() &#123; ... &#125;&#125;class C &#123; fun baz() &#123; ... &#125; fun D.foo() &#123; bar() // calls D.bar baz() // calls C.baz &#125; fun caller(d: D) &#123; d.foo() // call the extension function &#125;&#125;此时，我们称 C 为调度接收者，D 为扩展接收者。当扩展名称和类成员冲突时，此时，在扩展内部，扩展接收者具有更高优先级；而在扩展外部，调度接收者具有更高优先级。12345678910111213141516171819202122232425262728class C &#123; fun foo() &#123; println("C foo") &#125;&#125;class D &#123; fun foo() &#123; println("D foo") &#125; fun C.fooBar() &#123; foo() // "C foo" this@D.foo() // "D foo" &#125; fun caller(c: C) &#123; c.fooBar() &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val d = D() val c = C() d.foo() // "D foo" c.foo() // "C foo"&#125;如果需要在扩展内部访问外部类（即 D），则需要一个带标签的 this 来进行。带标签的 this 通常用于内部类来访问外部类。注意，扩展成员需要使用一个另外的调用器来执行。在类的外部它是不可见的。10. 扩展成员的继承与其他成员一样，扩展成员也可以进行继承和重载操作。但需要注意的是，扩展接收者是静态的，而调度接收者是动态的。即，扩展接收者不受多态影响123456789101112131415161718192021222324252627282930313233open class D &#123;&#125;class D1 : D() &#123;&#125;open class C &#123; open fun D.foo() &#123; println("D.foo in C") &#125; open fun D1.foo() &#123; println("D1.foo in C") &#125; fun caller(d: D) &#123; d.foo() // call the extension function &#125;&#125;class C1 : C() &#123; override fun D.foo() &#123; println("D.foo in C1") &#125; override fun D1.foo() &#123; println("D1.foo in C1") &#125;&#125;C().caller(D()) // prints "D.foo in C"C1().caller(D()) // prints "D.foo in C1" - dispatch receiver is resolved virtuallyC().caller(D1()) // prints "D.foo in C" - extension receiver is resolved statically11. 开发扩展的动机提供扩展这一特性主要是为了简化 Java 代码中关于工具类的调用。将这样的代码12345// JavaCollections.swap( list, Collections.binarySearch(list,Collections.max(otherList)), Collections.max(list))转换成这样的12// Javalist.swap(list.binarySearch(otherList.max()), list.max())]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP]]></title>
    <url>%2FPHP%2FPHP%2F</url>
    <content type="text"><![CDATA[1. BasicBegins with &lt;?php and ends with ?&gt;123&lt;?phpecho strlen("Hello, World!");?&gt;Comments// and # for a single line./* */ for block.12345678910&lt;?php// Single line Comment.# Also single line./*And comment block,Crossmultiplelines.*/?&gt;Case SensitivityAll the function() class and the key word is NOt cAse SenSiTivE123456&lt;?php// They all do the same things.ECHO "Hello World!&lt;br&gt;";echo "Hello World!&lt;br&gt;";EcHo "Hello World!&lt;br&gt;";?&gt;But the $variable is CASE SENSITIVE1234567&lt;?php// Only the FIRST statement can do the right output.$color="red";echo "My car is " . $color . "&lt;br&gt;";echo "My house is " . $COLOR . "&lt;br&gt;";echo "My boat is " . $coLOR . "&lt;br&gt;";?&gt;2. VariableThevariable` begins with the `char.123456&lt;?php// They are all variables$x = 5;$txt = "Hello, World!";$y = 10.5;?&gt;Weak TypePHP is an weak type language, you do not have to announce the type when you create the variableAs the above, $x is an int, $txt is an string and $y is an floatScopeLocal - The variable can only be konwn inside the function or the current statement Global - The variable can be konwn at any where Static - The variable whose value can be maintain 4.]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin 函数]]></title>
    <url>%2FKotlin%2FKotlin%20%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1. 声明函数使用 fun 关键字进行声明。12fun double(x: Int): Int &#123;&#125;2. 调用函数的调用和其他语言一样1val result = double(2)2.1 类成员函数调用类成员函数使用 . 进行调用。1Sample().foo() // create instance of class Sample and calls foo2.2 中继调用使用了 infix 标识符的函数可以进行中继调用2.2.1 条件函数是成员函数或者扩展函数只有一个参数使用 infix 进行标识2.2.2 例子123456789101112// Define extension to Intinfix fun Int.shl(x: Int): Int &#123;...&#125;// call extension function using infix notation1 shl 2// is the same as1.shl(2)3. 参数函数的参数使用 Pascal 的形式进行调用。(name: Type)使用逗号分隔不同的参数。每个参数都必须显式指明类型123fun powerOf(number: Int, exponent: Int) &#123;...&#125;3.1 默认参数Kotlin 中允许使用默认参数，这样相比 Java 就减少了函数重载的使用。在 Java 中，如果出现多个重载函数，开销将迅速增长。但是 Kotlin 相对于 Python 来说仍然支持函数重载特性使用 = 来指定参数的默认值，而且 Kotlin 不对默认参数的位置进行要求。123fun read(b: Array&lt;Byte&gt;, off: Int = 0, len: Int = b.size()) &#123;...&#125;通过类重载的方法不允许拥有默认参数1234567open class A &#123; open fun foo(i: Int = 10) &#123; ... &#125;&#125;class B : A() &#123; override fun foo(i: Int) &#123; ... &#125; // no default value allowed&#125;3.2 参数指定在函数调用时，Kotlin 支持参数的指定，类似 Python例如，对如下函数：1234567fun reformat(str: String, normalizeCase: Boolean = true, upperCaseFirstLetter: Boolean = true, divideByCamelHumps: Boolean = false, wordSeparator: Char = ' ') &#123;...&#125;在调用时使用 = 来指定参数。123456reformat(str, normalizeCase = true, upperCaseFirstLetter = true, divideByCamelHumps = false, wordSeparator = '_' )当然我们也可以不指定所有的参数，如果参数有默认值的话。此时，没有被指定的实参按照顺序赋予形参。1reformat(str, wordSeparator = '_')需要注意的是，调用 Java 的方法时，不能使用参数指定。3.3 不定参数Kotlin 同样支持不定参数，只需要给参数标识上 vararg 即可。例如：123456fun &lt;T&gt; asList(vararg ts: T): List&lt;T&gt; &#123; val result = ArrayList&lt;T&gt;() for (t in ts) // ts is an Array result.add(t) return result&#125;与 Java 一样，不定参数会被视作一个 Array 对象来进行处理。只有一个参数能被标记为 vararg。不定参数可以不处于最后位置，此时，只能通过参数指定的形式对剩下的参数进行赋值，或者如果其中一个参数是函数，那么可以在括号外使用 lambda 表达式。此外，Kotlin 中可以将一个 Array 对象传给不定参数，通过使用 spread operator (*) 来实现。12val a = arrayOf(1, 2, 3)val list = asList(-1, 0, *a, 4)4. 返回值如果一个函数没有指明返回值或者没有使用 return 语句，那么默认返回 Unit。Unit 是一种特有类型，只具有 Unit 一个值。使用 Unit 的原因在于，Kotlin 一切都是对象，使用一个具体类型能使泛型更好的工作不使用 Void 的原因：因为已经存在了一个 Nothing 类，为了防止意思冲突，所以使用 Unit 来指代 Java 中的 void1234567fun printHello(name: String?): Unit &#123; if (name != null) println("Hello $&#123;name&#125;") else println("Hi there!") // `return Unit` or `return` is optional&#125;当然，Unit 的返回值声明也是可以省略的。实际上，在编码规范中，要求对其省略。123fun printHello(name: String?) &#123; ...&#125;4.1 单一表达式函数当一个函数只具有一条表达式时，花括号可以被省略。1fun double(x: Int): Int = x * 2此时，如果编译器能推断出表达式的值，那么返回类型的声明也是可以省略的。1fun double(x: Int) = x * 24.2 非单一表达式函数如果函数不是单一表达式，而且具有返回值，那么返回类型就必须被声明。5. 函数作用域在 Kotlin 中，函数可以在 Top-level 声明，也就是说不需要用类来包裹函数。函数同样也可以是局部的，也就是说它可以是成员函数或者函数的扩展。5.1 局部函数Kotlin 支持局部函数，例如嵌套函数123456789fun dfs(graph: Graph) &#123; fun dfs(current: Vertex, visited: Set&lt;Vertex&gt;) &#123; if (!visited.add(current)) return for (v in current.neighbors) dfs(v, visited) &#125; dfs(graph.vertices[0], HashSet())&#125;同时，内部函数可以访问外部函数的局部变量，也就是闭包属性。所以对于上面的例子，visited 可以作为一个局部变量。12345678910fun dfs(graph: Graph) &#123; val visited = HashSet&lt;Vertex&gt;() fun dfs(current: Vertex) &#123; if (!visited.add(current)) return for (v in current.neighbors) dfs(v) &#125; dfs(graph.vertices[0])&#125;6. 尾调用对于一些算法实现来说，使用递归实现会令算法过程更加明晰。对此，Kotlin 拥有一个特殊的关键字 tailrec，使用它可以支持使用尾调用(tail recursion)形式的函数。使用 tailrec 关键字的原因在于：虽然不使用这个关键字也可以实现尾调用形式的函数，但是 tailrec 会指示编译器将其优化为相应的循环形式，从而避免了因递归调用过多造成的 StackOverflow。12tailrec fun findFixPoint(x: Double = 1.0): Double = if (x == Math.cos(x)) x else findFixPoint(Math.cos(x))使用 tailrec 的函数必须满足尾调用形式，即函数的最后一个操作就是调用其自身。当你的递归调用操作之后还存在更多代码时，不能对函数使用 tailrec]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin `this` 表达式]]></title>
    <url>%2FKotlin%2FKotlin%20%60this%60%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Tags: KotlinKotlin 提供了一个 this 表达式，主要就是一个带标签的 this，用于在内部类、扩展中获取正确的类对象实例。12345678910111213141516171819202122class A &#123; // implicit label @A inner class B &#123; // implicit label @B fun Int.foo() &#123; // implicit label @foo val a = this@A // A's this val b = this@B // B's this val c = this // foo()'s receiver, an Int val c1 = this@foo // foo()'s receiver, an Int val funLit = lambda@ fun String.() &#123; val d = this // funLit's receiver &#125; val funLit2 = &#123; s: String -&gt; // foo()'s receiver, since enclosing lambda expression // doesn't have any receiver val d1 = this &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin 数据类]]></title>
    <url>%2FKotlin%2FKotlin%20%E6%95%B0%E6%8D%AE%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[1. 介绍我们经常要使用容器类结构，所以 Kotlin 提供了一种新特性，专门用于生成容器类，称为数据类(data class)2. 创建Kotlin 使用 data 定义一个数据类1data class User(val name: String, val age: Int)编译器会自动为这个类生成如下方法：equal() 和 hashCode()toString()：生成 &quot;User(name=John, age=42)&quot;componentN() 方法，用于类的解构copy() 方法，用于复制这个类如果这些方法已经被显式声明了，那么则不进行生成。3. 需要满足的条件一个 Kotlin 数据类需要满足如下条件：primary constructor 必须具有至少一个参数所有的 primary constructor 参数必须使用 val 或 var数据类不能具有 open abstract sealed 修饰符，而且不能是内部类。数据类不能继承其他类，但是可以实现接口如果需要在 JVM 上使得类具有一个无参数的构造器，那么所有的 primary constructor 参数都必须有默认值4. 复制数据类自动实现了 copy() 方法，可以进行数据类的深拷贝。12val jack = User(name = "Jack", age = 1)val olderJack = jack.copy(age = 2)copy() 方法的声明如下：1fun copy(name: String = this.name, age: Int = this.age) = User(name, age)5. 数据类的解构数据类自动生成了 componentN() 方法，因此可以用作数据类的解构。解构指的是类似 Python 中的返回元组，将数据类中的数据拆分开，用不同的变量来承接的特性。123val jane = User("Jane", 35)val (name, age) = janeprintln("$name, $age years of age") // prints "Jane, 35 years of age"上面这个例子实际上在编译过程中会被自动转换成12val name = jane.component1()val age = jane.component2()所以 name 和 age 可以直接被使用12println(name)println(age)componentN() 方法的顺序和 primary constructor 中参数的顺序相同。componentN() 方法的自定义实际上，为了支持上面的类似元组的操作，需要使用 operator 标识符来声明 componentN() 方法。1234operator fun &lt;K, V&gt; Map&lt;K, V&gt;.iterator(): Iterator&lt;Map.Entry&lt;K, V&gt;&gt; = entrySet().iterator()operator fun &lt;K, V&gt; Map.Entry&lt;K, V&gt;.component1() = getKey()operator fun &lt;K, V&gt; Map.Entry&lt;K, V&gt;.component2() = getValue()&gt;定义之后，就可以像这样调用1234for ((key, value) in map) &#123; // do something with the key and the value&#125;&gt;]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin 枚举类]]></title>
    <url>%2FKotlin%2FKotlin%20%E6%9E%9A%E4%B8%BE%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[1. 概述事实上，Kotlin 的枚举和 Java 一样，只是提供了一个类型限定范围。而如果要使用在 switch，都必须使用 valueOf() 方法，同时使用 try-catch。当然，在 Kotlin 中，可以使用 sealed clasdd 来方便的实现需要 switch 的情景。2. 声明123enum class Direction &#123; NORTH, SOUTH, WEST, EAST&#125;3. 初始化与 Java 一样，枚举类也可以被初始化12345enum class Color(val rgb: Int) &#123; RED(0xFF0000), GREEN(0x00FF00), BLUE(0x0000FF)&#125;4. 匿名类每一个枚举项都能拥有它自己的匿名类和重载方法。1234567891011enum class ProtocolState &#123; WAITING &#123; override fun signal() = TALKING &#125;, TALKING &#123; override fun signal() = WAITING &#125;; abstract fun signal(): ProtocolState&#125;5. 创建枚举创建枚举和 Java 相同，只能使用 valueOf() 方法。而且，此方法在参数不符合枚举值时，会抛出异常。同时 Kotlin 也提供了 values() 方法来遍历所有的枚举值。]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin 泛型]]></title>
    <url>%2FKotlin%2FKotlin%20%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[1. 声明和实例化和 Java 一样，Kotlin 使用类型参数来声明一个泛型类123class Box&lt;T&gt;(t: T) &#123; var value = t&#125;而在实例化时，我们需要显式给出类型参数1val box: Box&lt;Int&gt; = Box&lt;Int&gt;(1)但是，如果类型能够被推断出，那么类型参数可以被省略1val box = Box(1) // 1 has type Int, so the compiler figures out that we are talking about Box&lt;Int&gt;2. Java 中的泛型可变性在 Java 中，泛型是不可变的。也就是说 List&lt;Object&gt; 不能接受一个 String 对象。1234567// JavaList&lt;String&gt; strs = new ArrayList&lt;String&gt;();List&lt;Object&gt; objs = strs; // !!! The cause of the upcoming problem sits here. Java prohibits this!objs.add(1); // Here we put an Integer into a list of StringsString s = strs.get(0); // !!! ClassCastException: Cannot cast Integer to String但是我们又需要实现一个接受泛型对象的方法，例如 addAll()12345// Java// Wrong implementationinterface Collection&lt;E&gt; ... &#123; void addAll(Collection&lt;E&gt; items);&#125;但是由于泛型不可变，这样的实现实际上是错误的。所以 Java 引入了通配符(?)，使用 extends 和 super 来对通配符进行限制。12345// Java// Correct implementationinterface Collection&lt;E&gt; ... &#123; void addAll(Collection&lt;? extends E&gt; items);&#125;2.1.1 &lt;? extends T&gt; 和 &lt;? super T&gt; 的区别何时使用 extends 和 super，Java 有一个 PECS 原则。PECS 的意思是 Producer Extends, Consumer Super。即对于生产者，使用 extends，对于消费者，使用 super，如果一个类既要生产，也要消费，那么就不对通配符进行限制。究其原因，还是得从这两者特性说起。2.1.1.1 &lt;? extends T&gt;实际上，对于使用了 &lt;? extends T&gt; 的类，编译器会阻止向其加入任何的元素。例如：123List&lt;Apple&gt; apples = new ArrayList&lt;Apple&gt;();List&lt;? extends Fruit&gt; fruits = apples; //works, apple is a subclass of Fruit.fruits.add(new Strawberry()); //compile errorfruits 是一个 Fruit 的子类的 List ,由于 Apple 是 Fruit 的子类，因此将 apples 赋给 fruits 是合法的。但是编译器会阻止将 Strawberry 加入 fruits。因为编译器只知道 fruits 是 Fruit 的某个子类的 List，但并不知道究竟是哪个子类，为了类型安全，只好阻止向其中加入任何子类。那么可不可以加入 Fruit 呢？很遗憾，也不可以。但是由于编译器知道 fruits 中的元素总是 Fruit 的子类，所以可以安全的将其取出。1Fruit fruit = fruits.get(0);2.1.1.2 &lt;? super T&gt;使用 super 的原因其实并不如使用 extends 的原因那样复杂。使用 super 只是为了为了保证能向其加入 T，或者是对其调用接受 T 作为参数的方法。有趣的是，编译器并没有禁止在这种类型上调用 get() 方法，但是需要注意的是，如果调用 get()，返回的是 Object 而不是具体的 T 类型。所以在 &lt;? super T&gt; 对象上，只能进行消费，即调用以 T 为参数的方法。神奇的是，虽然类型是 super，但是却不能加入一个具体的超类，而可以加入一个具体的子类。其原因就是编译器无法确定加入的超类究竟是哪一个，而 T 作为参数时，可以接受一个子类。3. Kotlin 的改进： Declaration-site variance在 Java 中，如果一个接口只返回泛型，而不对泛型进行操作，那么将其赋给超类泛型就是安全的。123456789// Javainterface Source&lt;T&gt; &#123; T nextT();&#125;void demo(Source&lt;String&gt; strs) &#123; Source&lt;Object&gt; objects = strs; // !!! Not allowed in Java // ...&#125;由于 Source&lt;T&gt; 中只有返回 T 的方法，所以即使对 objects 进行操作，也只能返回 T，而 Object 是 T 的超类或者它本身，所以这是安全的。但是在 Java 中不允许这样的写法，你依旧要使用 Sorce&lt;? extends String&gt;，这显得毫无意义。在 Kotlin 中，对于这样的情形，定义了 out 标识符，使用 out 标识符来说明，类、接口只会返回泛型，而不会接受泛型作为参数。12345678abstract class Source&lt;out T&gt; &#123; abstract fun nextT(): T&#125;fun demo(strs: Source&lt;String&gt;) &#123; val objects: Source&lt;Any&gt; = strs // This is OK, since T is an out-parameter // ...&#125;同样的，定义了 in 标识符，用于表明类、接口只会接受 T 作为参数，而不会返回它。123456789abstract class Comparable&lt;in T&gt; &#123; abstract fun compareTo(other: T): Int&#125;fun demo(x: Comparable&lt;Number&gt;) &#123; x.compareTo(1.0) // 1.0 has type Double, which is a subtype of Number // Thus, we can assign x to a variable of type Comparable&lt;Double&gt; val y: Comparable&lt;Double&gt; = x // OK!&#125;与 Java 不同的是，Kotlin 并没有定义一个口诀来帮助记忆，out 和 in 已经足够说明其属性。out 代表着类、接口只会给出T，相当于 T 的生产者；in 代表着类、接口只会接受 T，相当于 T 的消费者。这些词语的表意性已经十分明确了。4. 类型预测对于一个既能生产又能消费的类，我们就不能在声明阶段限定它的泛型类型。例如：1234class Array&lt;T&gt;(val size: Int) &#123; fun get(index: Int): T &#123; /* ... */ &#125; fun set(index: Int, value: T) &#123; /* ... */ &#125;&#125;但是对于如下方法12345fun copy(from: Array&lt;Any&gt;, to: Array&lt;Any&gt;) &#123; assert(from.size == to.size) for (i in from.indices) to[i] = from[i]&#125;这个方法的目的是将一个类的元素复制到另一个类中去，如果进行如下的调用：123val ints: Array&lt;Int&gt; = arrayOf(1, 2, 3)val any = Array&lt;Any&gt;(3)copy(ints, any) // Error: expects (Array&lt;Any&gt;, Array&lt;Any&gt;)一个 Array&lt;Any&gt; 当然可以接受一个 Int 的值，理论上来说这段代码是完全没有问题的。但是编译器阻止这么使用的原因在于：Array&lt;T&gt; 类既可以生产又可以消费，如果我们向 from 中添加一个 Any 对象（因为 from 的形参是 Array&lt;Any&gt;），但是当前 from 是 Int， 当然这就会导致 ClassCastException。为了防止这种不安全的事情发生，编译器就禁止了上述操作。但是，只要 from 不进行消费操作，那么这段代码就是类型安全的。所以，Kotlin 除了提供在声明阶段进行泛型限制以外，还可以在调用阶段进行泛型限制。在 copy() 方法中，如果我们限制 from 只会生产，而不会消费，那么上面的调用就是安全的了。123fun copy(from: Array&lt;out Any&gt;, to: Array&lt;Any&gt;) &#123; // ...&#125;Kotlin 的这种特性，我们称之为类型预测：from 不仅仅只是一个简单的 Array，而且它受到了限制，它的类型已经被预测了。同样，我们也可以使用 in 来指明一个变量只会消费，而不会生产。123fun fill(dest: Array&lt;in String&gt;, value: String) &#123; // ...&#125;事实上， &lt;out T&gt; 相当于 Java 的 &lt;? extends T&gt;；&lt;in T&gt; 相当于 Java 的 &lt;? super T&gt;5. 星号除了上述的泛型类型限制外，Kotlin 还提供了一个星号类型(*)。这和 Java 的通配符(?)很相似，当你不知道具体的泛型类型，而又想使用它时，那么就可以使用星号类型。具体来说：对于 Foo&lt;out T&gt;，Foo&lt;*&gt; 意味着 Foo&lt;out TUpper&gt;，TUpper 指的是 Foo() 方法所给定的泛型上界。也就是说当 T 是未知的时候，你可以从 Foo&lt;*&gt;读取T 的上界对于 Foo&lt;in T&gt;，Foo&lt;*&gt; 指的是 Foo&lt;in Nothing&gt;，意思是当 T 未知时，你不能向 Foo&lt;*&gt; 中写入任何东西。对于 Foo&lt;T&gt;，T 是一个不可变的泛型类型，所以 Foo&lt;*&gt; 表示 Foo&lt;out TUpper&gt; 和 Foo&lt;in Nothing&gt;一个更为通俗的解释如下：对于接口声明 interface Function&lt;in T, out U&gt;：Function&lt;*, String&gt; 表示 Function&lt;in Nothing, String&gt;Function&lt;String, *&gt; 表示 Function&lt;String, out Any?&gt;Function&lt;*, *&gt; 表示 Function&lt;in Nothing, out Any?&gt;6. 泛型方法与 Java 一样，Kotlin 中的方法也可以有泛型。1234567fun &lt;T&gt; singletonList(item: T): List&lt;T&gt; &#123; // ...&#125;fun &lt;T&gt; T.basicToString() : String &#123; // extension function // ...&#125;调用方法：1val l = singletonList&lt;Int&gt;(1)7. 泛型约束与 Java 一样，Kotlin 也拥有泛型约束，这用在当泛型参数 T 未知时，用于对 T 的类型做出限制，即 TUpper最常用的泛型约束就是上界，Java 中使用 extends 来指明上界。Kotlin 使用 冒号(:) 来指明上界。123fun &lt;T : Comparable&lt;T&gt;&gt; sort(list: List&lt;T&gt;) &#123; // ...&#125;用法举例：12sort(listOf(1, 2, 3)) // OK. Int is a subtype of Comparable&lt;Int&gt;sort(listOf(HashMap&lt;Int, String&gt;())) // Error: HashMap&lt;Int, String&gt; is not a subtype of Comparable&lt;HashMap&lt;Int, String&gt;&gt;默认的上界是 Any?（? 说明可以为空nullable）。只有一个上界可以在尖括号中被指定，如果需要对同一个泛型参数指定多个上界，则需要使用 where 语句。12345fun &lt;T&gt; cloneWhenGreater(list: List&lt;T&gt;, threshold: T): List&lt;T&gt; where T : Comparable, T : Cloneable &#123; return list.filter &#123; it &gt; threshold &#125;.map &#123; it.clone() &#125;&#125;注意 Comparable 和 Cloneable 都是接口。]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin 相等性]]></title>
    <url>%2FKotlin%2FKotlin%20%E7%9B%B8%E7%AD%89%E6%80%A7%2F</url>
    <content type="text"><![CDATA[1. 概述Kotlin 中拥有两种相等性类型引用相等性：两个引用是否指向同一个对象结构相等性：类似 Java 中的 equals()2. 引用相等性引用相等性使用 ===（其否定判断为 !==）， 来进行判别，它只判断两个引用是否指向了同一个对象。a === b 为真当且仅当 a 和 b 指向了同一个对象。3. 结构相等性结构相等性的判断类似 Java 中的 equals()，在 Kotlin 中，使用 == 操作符来进行判断（其否定为 !=）。一个 == 操作符会被转换成以下的相应代码1a?.equals(b) ?: (b === null)也就是说，当 a 非空时，它会调用 equal(Any?)，当 a 为空时，它会检查 b 是否也为空。注意，在空检查时，没有必要转换你的代码，编译器会自动将 a == null 优化为 a === null]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin 内联函数]]></title>
    <url>%2FKotlin%2FKotlin%20%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1. 概述使用 lambda 和高阶函数固然方便，但是由于需要生成函数对象和进行闭包操作，这也造成了一些不必要的内存和时间开销。但是一般情况下，我们可以通过将函数和 Lambda 表达式内联化进行开销的减免。内联函数指的是将整个函数直接替换为函数实际代码的技术，它可以减少函数调用时由于跳转产生的开销浪费。2. Kotlin 内联语法例如 lock() 函数，它可以很方便的在调用点进行内联化操作：1lock(l) &#123; foo() &#125;通过这种写法，编译器并没有为 lambda 表达式创建一个函数对象，而是生成了如下代码：1234567l.lock()try &#123; foo()&#125;finally &#123; l.unlock()&#125;为了让编译器进行这种操作，我们可以给函数使用 inline 修饰符。123inline fun lock&lt;T&gt;(lock: Lock, body: () -&gt; T): T &#123; // ...&#125;注意，inline 修饰符会对整个函数和其 lambda 表达式都有效，即整个函数和 lambda 都被替换成实际代码。123456789101112// 内联函数inline fun &lt;T&gt; inlineLock(lock: Lock, body: () -&gt; T): T &#123; lock.lock() try &#123; return body() &#125; finally &#123; lock.unlock() &#125;&#125;// 普通函数fun echo() = println("foo")调用该内联函数：12val lock = ReentrantLock()inlineLock(lock, &#123; echo() &#125;)以上代码会被编译为如下代码：1234567val lock = ReentrantLock()lock.lock()try &#123; println("foo")&#125; finally &#123; lock.unlock()&#125;函数内联技术会导致代码体积膨胀，为了减少代码体积膨胀，不要内联大体积的函数。3. Noinline有时候我们只希望对函数本身进行内联化操作，而对其 lambda 参数不使用内联。此时我们可以对参数使用 noinline 标识符123inline fun foo(inlined: () -&gt; Unit, noinline notInlined: () -&gt; Unit) &#123; // ...&#125;内联的 lambda 只能在内联函数内部调用，或者作为一个 inline 参数传给内联函数；但是非内联的 labmda 可以储存在变量中，或者传递它。4. 非局部返回普通的 return 默认返回的函数是最近的 fun 所定义的函数，这叫做局部返回(local return)所以，由于在 lambda 表达式内部不能让外部函数返回，所以在 lambda 表达式中使用 return 是被禁止的。12345fun foo() &#123; ordinaryFunction &#123; return // ERROR: can not make `foo` return here &#125;&#125;但是内联函数由于使用定义替代了调用，所以在其中使用 return 是可以的。12345fun foo() &#123; inlineFunction &#123; return // OK: the lambda is inlined &#125;&#125;这个例子中，return 会让 foo() 返回。这种返回方式被称作非局部返回。这种特性十分有效，所以被内建在标准的循环中123456fun hasZeros(ints: List&lt;Int&gt;): Boolean &#123; ints.forEach &#123; if (it == 0) return true // returns from hasZeros &#125; return false&#125;有时候，在调用处传入的 lambda 可能并不会被立即执行，而是传入到另一个线程中，或者另一个本地对象或本地方法中，此时，非本地返回同样会被禁止。为了提示编译器，我们使用 crossinline 标识符来指明当前的函数对象会在一个内嵌的函数或者对象，或是在另一个线程中执行。123456inline fun f(crossinline body: () -&gt; Unit) &#123; val f = object: Runnable &#123; override fun run() = body() &#125; // ...&#125;break 和 continue 尚未写入支持，但是 Kotlin 开发组预计会在未来实现这两个功能。5. 类型参数有时候我们希望访问一个对象的类型参数，例如 Class，在 Java 中，这通常是通过反射机制来实现的。12345678fun &lt;T&gt; TreeNode.findParentOfType(clazz: Class&lt;T&gt;): T? &#123; var p = parent while (p != null &amp;&amp; !clazz.isInstance(p)) &#123; p = p.parent &#125; @Suppress("UNCHECKED_CAST") return p as T&#125;调用这个函数：12345678910val root = DefaultMutableTreeNode("root")val node1 = DefaultMutableTreeNode("node1")val node1_1 = DefaultMutableTreeNode("node1_1")val node2 = DefaultMutableTreeNode("node2")node1.add(node1_1)root.add(node1)root.add(node2)var parent = node1_1.findParentOfType(DefaultMutableTreeNode::class.java)println(parent) // node1可以看到由于依赖于反射，所以在函数体内不但要处理未检查类型转换的警告也很难处理具体类型的信息。而内联函数由于是复制到调用处，所以实际在运行时无需依赖反射，可以直接得到真实类型。要开启此功能，只需在泛型参数前加上 reified 关键字。1234567inline fun &lt;reified T&gt; TreeNode.inlineFindParentOfType(): T? &#123; var p = parent while (p != null &amp;&amp; p !is T) &#123; p = p.parent &#125; return p as T&#125;调用该函数12val parent = node1_1.inlineFindParentOfType&lt;DefaultMutableTreeNode&gt;()println(parent) // node1非内联的函数不能使用 reified 标识符。一个不具备运行时表示类型的类型（比如一个没有 reified 的类型参数，或者是一个虚拟的类型，如 Nothing），不能当做 reified 函数参数使用。]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin 内部类]]></title>
    <url>%2FKotlin%2FKotlin%20%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[1. 声明12345678class Outer &#123; private val bar: Int = 1 class Nested &#123; fun foo() = 2 &#125;&#125;val demo = Outer.Nested().foo() // == 22. inner 关键字需要使用 inner 关键字来指明一个内部类允许访问外部类属性。12345678class Outer &#123; private val bar: Int = 1 inner class Inner &#123; fun foo() = bar &#125;&#125;val demo = Outer().Inner().foo() // == 13. 获取外部类实例通过使用带标签的 this 可以获取外部类实例。4. 匿名内部类Kotlin 没有 Java 中的匿名类，反之，Kotlin 使用对象表达式(object expression)来实现这一功能。123456789window.addMouseListener(object: MouseAdapter() &#123; override fun mouseClicked(e: MouseEvent) &#123; // ... &#125; override fun mouseEntered(e: MouseEvent) &#123; // ... &#125;&#125;)如果内部类对应的接口只有一个方法，那么也可以使用 lambda 表达式来创建这个内部类。1val listener = ActionListener &#123; println("clicked") &#125;]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin 可见性修饰符]]></title>
    <url>%2FKotlin%2FKotlin%20%E5%8F%AF%E8%A7%81%E6%80%A7%E4%BF%AE%E9%A5%B0%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[1. 概述Kotlin 的可见性修饰符和 Java 及 C++ 有比较大的区别。首先，Kotlin 拥有四种可见性修饰符:public private protected internal默认的可见性修饰符为 public。2. 包级别函数，变量，类都可以在 “top-level” 级别声明，即直接在包内声明。12345// file name: example.ktpackage foofun baz() &#123;&#125;class Bar &#123;&#125;在包级别中的可见性规则如下：如果没有显式指定，那么 public 是默认的可见性，即你声明的内容在任意地方均可见如果指定了 private，那么只有同文件可见如果指定了 internal，那么只有在同一个模块可见protected 修饰符不支持在包级别使用例如：123456789// file name: example.ktpackage fooprivate fun foo() &#123;&#125; // visible inside example.ktpublic var bar: Int = 5 // property is visible everywhere private set // setter is visible only in example.ktinternal val baz = 6 // visible inside the same module3. 类级别当在类或者接口中声明属性或方法时，也同样有可见性的修饰符作用。此时，规则如下。如果没有显式指定，那么默认为 public，此时，内容对所有能看见这个类的对象都是可见的如果指定了 private，那么只有在类的内部才可见如果指定了 protected，那么只在类内部和其子类可见，如果 override 了一个 protected 变量，那么 override 后的变量自动具有 protected 属性如果指定了 internal，那么在模块内可见需要注意的是，不像 Java，外部类不能看见内部类的 private 变量。123456789101112131415161718192021222324open class Outer &#123; private val a = 1 protected open val b = 2 internal val c = 3 val d = 4 // public by default protected class Nested &#123; public val e: Int = 5 &#125;&#125;class Subclass : Outer() &#123; // a is not visible // b, c and d are visible // Nested and e are visible override val b = 5 // 'b' is protected&#125;class Unrelated(o: Outer) &#123; // o.a, o.b are not visible // o.c and o.d are visible (same module) // Outer.Nested is not visible, and Nested::e is not visible either&#125;4. 构造器同样的，构造器也可以指定可见性，但是如果可见性被指定了，那么 constructor 关键字就必须存在。1class C private constructor(a: Int) &#123; ... &#125;构造器的默认可见性为 public，即能看到类，就能看到构造器。5. 关于模块一个具有 internal 可见性的变量，方法，类，函数在其模块内可见。所谓的模块，更通俗一点来说就是在一起编译的 Kotlin 文件，比如说：一个 IntelliJ IDEA module一个 Maven 或者 Gradle 工程一个使用同一个 Ant Task 调用的文件集合]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Storage API]]></title>
    <url>%2FProjects%2FMdzzProject%2FStorage%20API%2F</url>
    <content type="text"><![CDATA[1. 概述所有的储存信息和操作均通过实体实现。所有实体均存放在 models 包中。SharedPreferences 存放在 models/shared_preferences 包中数据库相关的实体存放在 models/db 包中。取消 Intant Run 再运行，否则程序将会报错！！！2. SharedPreferences 部分此部分的数据需要先获取实体 instance 之后再进行操作。通过实体的 getter 和 setter 对数据进行获取和更改，更改后数据会自动进行持久化保存。2.1 储存的数据用户的个人信息，包括注册信息和是否单身，是否第一次登陆等，实体为 UserInfo系统的信息，目前只包括是否第一次启动，实体为 AppInfo3. 数据库部分数据库使用 Sugar ORM，需要注意的是，此库需要取消 Instant Run 才能正常使用。通过相应的 find 方法来获取相应的实体，对实体进行数据操作之后，使用 save() 方法对其进行更新。此库已经极其简单，具体的使用说明请参照https://github.com/satyan/sugar#exampleshttp://satyan.github.io/sugar/]]></content>
      <categories>
        <category>工程</category>
        <category>MDZZ</category>
      </categories>
      <tags>
        <tag>工程</tag>
        <tag>MDZZ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin 调用 Java 代码]]></title>
    <url>%2FKotlin%2FKotlin%20%E8%B0%83%E7%94%A8%20Java%20%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[1. 概述Kotlin 完美支持 Java，你可以无缝地在 Kotlin 中引入 Java 库，调用 Java 类等。1234567891011import java.util.*fun demo(source: List&lt;Int&gt;) &#123; val list = ArrayList&lt;Int&gt;() // 'for'-loops work for Java collections: for (item in source) list.add(item) // Operator conventions work as well: for (i in 0..source.size() - 1) list[i] = source[i] // get and set are called&#125;2. 调用 getter 和 setterJava 中的 getter 和 setter 在 Kotlin 中都会被转换为 Kotlin 的格式，即只需要直接引用属性值即可。12345678import java.util.Calendarfun calendarDemo() &#123; val calendar = Calendar.getInstance() if (calendar.firstDayOfWeek == Calendar.SUNDAY) &#123; // call getFirstDayOfWeek() calendar.firstDayOfWeek = Calendar.MONDAY // call setFirstDayOfWeek() &#125;&#125;3. 返回 void 的方法Java 中返回 void 的方法，在 Kotlin 中会转换为返回 Unit4. 转义 Java 方法Kotlin 中拥有一些 Java 没有的关键字（比如 is in object 等）。对于这些关键字，如果 Java 代码中有相同的方法名或变量名，可以通过对其进行转义来调用它。使用 `` 来进行转义工作。1foo.`is`(bar)5. Null Safety 和 Platform Type在 Java 中，任何引用都有可能为空，但是在 Kotlin 中，严格的类型系统不允许空值。对于这种冲突，Kotlin 采用 Platform Type，也就是说在 Java 代码中的引用，Kotlin 类型系统会对其放松限制。所以它们的安全性保障就和在 Java 代码中一样。对于 Platform Type，我们可以使用一个 nullable 的 Kotlin 类型来承接它，也可以使用 non-nullable 对象。12val nullable: String? = item // allowed, always worksval notNull: String = item // allowed, may fail at runtime当我们使用 non-null 对象来承接 Platform Type 时，Kotlin 会自动在赋值语句上方插入断言，来保证 Kotlin 变量的非空性。同样的，当我们把 Platform Type 传个一个接受非空类型的函数参数时，Kotlin 也会自动在函数调用前插入断言语句。不过有时候也不一定会进行断言，特别是在使用泛型的时候。6. Platform Type 的符号由于 Platform Type 不能被显式确定，所以没有关于它们的语法。但是有时候 IDE 需要生成函数提示，所以对于 Platfrom Type 也有一些符号用于说明。T! 表示 T 或者 T?(Mutable)Collection&lt;T&gt;! 表示关于 T 的 Java 集合，可能会被修改，也可能不会；可能为空，也可能不会Array&lt;(out) T&gt;! 表示关于 T 或者其子类型的 Java 数组，有可能为空，也可能不为空。7. Nullability 注解使用了注解表明 nullability 的 Platform Type 会被当做真正的 Kotlin 变量来处理。Kotlin 目前支持以下注解：JetBrains (@Nullable and @NotNull from the org.jetbrains.annotations package)Android (com.android.annotations and android.support.annotations)JSR-305 (javax.annotation)FindBugs (edu.umd.cs.findbugs.annotations)Eclipse (org.eclipse.jdt.annotation)Lombok (lombok.NonNull).8. 类型的对应关系由于 Kotlin 中没有原始类型，所以对于 Java 的原始类型，会被自动转换成对应的 Kotlin 类。这个转换只会发生在编译期间，在运行期间是不变的，会保持 Platfrom Type。Java typeKotlin typebytekotlin.Byteshortkotlin.Shortintkotlin.Intlongkotlin.Longcharkotlin.Charfloatkotlin.Floatdoublekotlin.Doublebooleankotlin.Boolean一些非原始类型的类也会被转换Java typeKotlin typejava.lang.Objectkotlin.Any!java.lang.Cloneablekotlin.Cloneable!java.lang.Comparablekotlin.Comparable!java.lang.Enumkotlin.Enum!java.lang.Annotationkotlin.Annotation!java.lang.Deprecatedkotlin.Deprecated!java.lang.Voidkotlin.Nothing!java.lang.CharSequencekotlin.CharSequence!java.lang.Stringkotlin.String!java.lang.Numberkotlin.Number!java.lang.Throwablekotlin.Throwable!集合类型在 Kotlin 有可变和不可变两种类型，所以 Java 的集合类型也会进行相应的转换。Java typeKotlin read-only typeKotlin mutable typeLoaded platform typeIterator&lt;T&gt;Iterator&lt;T&gt;MutableIterator&lt;T&gt;(Mutable)Iterator&lt;T&gt;!Iterable&lt;T&gt;Iterable&lt;T&gt;MutableIterable&lt;T&gt;(Mutable)Iterable&lt;T&gt;!Collection&lt;T&gt;Collection&lt;T&gt;MutableCollection&lt;T&gt;(Mutable)Collection&lt;T&gt;!Set&lt;T&gt;Set&lt;T&gt;MutableSet&lt;T&gt;(Mutable)Set&lt;T&gt;!List&lt;T&gt;List&lt;T&gt;MutableList&lt;T&gt;(Mutable)List&lt;T&gt;!ListIterator&lt;T&gt;ListIterator&lt;T&gt;MutableListIterator&lt;T&gt;(Mutable)ListIterator&lt;T&gt;!Map&lt;K, V&gt;Map&lt;K, V&gt;MutableMap&lt;K, V&gt;(Mutable)Map&lt;K, V&gt;!Map.Entry&lt;K, V&gt;Map.Entry&lt;K, V&gt;MutableMap.MutableEntry&lt;K,V&gt;(Mutable)Map.(Mutable)Entry&lt;K, V&gt;!同样的，Java 的数组也会进行转换Java typeKotlin typeint[]kotlin.IntArray!String[]kotlin.Array&lt;(out) String&gt;!9. Java 泛型Kotlin 中的泛型系统和 Java 有些不同，所以当使用的 Java 代码存在泛型时，做如下转换：Java 泛型通配符被转换成类型预测Foo&lt;? extends Bar&gt; 转换为 Foo&lt;out Bar!&gt;!Foo&lt;? super Bar&gt; 转换为 Foo&lt;in Bar!&gt;!Java 的原始类型被转换成星形预测List 转换为 List&lt;*&gt;!，也就是 List&lt;out Any?&gt;!和 Java 一样，Kotlin 的泛型在运行期间是不会保留的。也就是说对象在构建的时候不会携带泛型的真正类型的信息。也就说说 Kotlin 不能区分 ArrayList&lt;Integer&gt; 和 ArrayList&lt;Character&gt;。这限制了 is 语句的使用，对于泛型，is 只能用于星形预测类型的检查，而不能应用于其他普通泛型类型的检查。123if (a is List&lt;Int&gt;) // Error: cannot check if it is really a List of Ints// butif (a is List&lt;*&gt;) // OK: no guarantees about the contents of the list10. Java 数组与 Java 不同，数组在 Kotlin 中是不可变的。也就是说 Kotlin 不允许将 Array&lt;Int&gt; 赋予 Array&lt;Any&gt;，这避免了一些运行期间的错误。同样的，Kotlin 也不允许一个子类的数组传入一个超类数组的形参中。在 Java 平台中，使用原生类型的数组能避免装箱和拆箱所带来的性能损失；但是在 Kotlin 中，这些细节被隐藏了起来，所以在调用 Java 代码时就需要一些特殊方法来进行沟通。Kotlin 对此为每个原始类型都提供了一个对应的数组类型，例如 IntArray LongArray CharArray 等，这些类和 Array 类没有关系。在编译时，这些数组类型会被编译为 Java 的原生类型数组，以提高性能。IntArray 和 Array&lt;Int&gt; 的区别：IntArray 相当于 Java 中的 int[]，不进行装箱和拆箱操作；Array&lt;Int&gt; 相当于 Java 中的 Integer[]，进行装箱和拆箱操作。see here所以对于一个接受 int[] 的 Java 方法123456public class JavaArrayExample &#123; public void removeIndices(int[] indices) &#123; // code here... &#125;&#125;我们可以使用 IntArray 将参数传入：123val javaObj = JavaArrayExample()val array = intArrayOf(0, 1, 2, 3)javaObj.removeIndices(array) // passes int[] to method当代码被编译为 JVM 字节码时，编译器会对以上类型进行优化，取消 getter 和 setter 的使用，而是直接取值赋值。1234val array = arrayOf(1, 2, 3, 4)array[x] = array[x] * 2 // no actual calls to get() and set() generatedfor (x in array) // no iterator created print(x)同样，在遍历这样的一个数组时，不会创建 iterator。12for (i in array.indices) // no iterator created array[i] += 2最后，在 in 语句中，对于这样的数组也不会调用 contains() 方法。123if (i in array.indices) &#123; // same as (i &gt;= 0 &amp;&amp; i &lt; array.size) print(array[i])&#125;11. Java 不定参数对于 Java 的不定参数，你需要像 Kotlin 中一样，使用 spread operator(*) 来传入一个数组。123456public class JavaArrayExample &#123; public void removeIndices(int... indices) &#123; // code here... &#125;&#125;123val javaObj = JavaArray()val array = intArrayOf(0, 1, 2, 3)javaObj.removeIndicesVarArg(*array)12. 操作符由于 Java 没有操作符重载，所以 Kotlin 允许将任何的拥有正确命名和函数参数的 Java 方法当做操作符重载使用。不过不允许在中缀函数中调用 Java 方法。13. 已检查异常由于 Kotlin 没有已检查异常，所以 Kotlin 不会强制要求你进行异常捕获；即使你调用的 Java 方法声明了已检查异常也一样。14. Java Object 类方法引用 Java 代码时，Java 的 Object 类会被转换成 Any；但是 Any 类只声明了 toString()，hashCode() 和 equals()方法，所以，为了完整实现 Object 类的功能，我们使用扩展来实现。14.1 wait() 和 notify()《Effective Java》第 69 条中强调：尽量使用多线程工具而不是使用 wait() 和 notify() 方法；所以 Any 类中并没有实现这两个方法。但是如果你真的需要使用这两个方法，可以把 Any 造型为 Object 来使用。1(foo as java.lang.Object).wait()14.2 getClass() 方法在 Kotlin 中，我们使用 javaClass 变量来获取对应的 Class 变量。1val fooClass = foo.javaClass对于 Java 中的 Foo.class，Kotlin 中使用 Foo::class.java1val fooClass = Foo::class.java14.3 clone() 方法要重载 clone() 方法，你的类必须实现 kotlin.Cloneable：123class Example : Cloneable &#123; override fun clone(): Any &#123; ... &#125;&#125;不要忘记 《Effective Java》的忠告，第 11 条：明智地重载 clone() 方法14.4 finalize() 方法要重载 finalize() 方法，你只需要声明它即可，而不需要使用 override 。12345class C &#123; protected fun finalize() &#123; // finalization logic &#125;&#125;注意，finalize() 不能是 private 的。15. 继承 Java 类只能继承一个基类；可以实现多个接口。16. 访问静态成员Java 类的静态成员会被自动转换成这个类的伴生对象。我们不能直接将这个伴生对象作为参数或者变量；但是我们依旧可以显式的调用它的静态成员。123if (Character.isLetter(a)) &#123; // ...&#125;17. Java 反射Java 的反射机制可以应用于 Kotlin 上，反之亦然。刚才也提到，你可以使用 instance.javaClass 或者 ClassName::class.java 来使用 Java 的反射机制。同样的，Kotlin 也支持使用 Java 方法来生成 getter、setter 和 backing field。KProperty 指代 Java 的字段，KFunction 指代 Java 方法，反之亦然。18. SAM 方法和 Java 8 一样，Kotlin 也支持 SAM 类型，这意味着 Kotlin 的直接函数定义（lambda 函数主体）可以被转换为一个只有单个方法的接口实现，只要函数接口能够对应的上的话，转换就能成功。1val runnable = Runnable &#123; println("This runs in a runnable") &#125;也可以应用于方法调用中：123val executor = ThreadPoolExecutor()// Java signature: void execute(Runnable command)executor.execute &#123; println("This runs in a thread pool") &#125;如果一个 Java 类有多个这种方法的重载，那么我们可以通过对 SAM 类型指定对应的转换器。1executor.execute(Runnable &#123; println("This runs in a thread pool") &#125;)注意，SAM 只能应用于接口，而不能应用于抽象类，即使这个类只有一个方法。还有，这个特性只支持 Java 代码，Kotlin 拥有相应的函数类型，所以将其转换为 Kotlin 接口的实现是非必须的，所以也没有实现这个特性。19. 使用 JNI通过 external 关键字来指明一个方法会调用 native 的 C 或者 C++ 代码。1external fun foo(x: Int): Double20. 其他方面在其他方面，Kotlin 和 Java 工作程序一致。]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin 范围]]></title>
    <url>%2FKotlin%2FKotlin%20%E8%8C%83%E5%9B%B4%2F</url>
    <content type="text"><![CDATA[1. 概述虽然 Kotlin 支持了简单易用的 foreach 语法，但是，有些时候也有必要获取下标，并显式的限定其范围，或者你需要判定一个值是否在一个范围内。Kotlin 对此支持 Range 语法，它就是简单的使用 .. 来表示范围，并且支持使用 in 和 !in 来进行判定；以及 for 进行遍历。2. 判定123if (i in 1..10) &#123; // equivalent of 1 &lt;= i &amp;&amp; i &lt;= 10 println(i)&#125;3. 遍历对于标准库中的范围（IntRange LongRange CharRange），Kotlin 支持遍历操作。123for (i in 1..4) print(i) // prints "1234"for (i in 4..1) print(i) // prints nothing上面的第二种写法不会打印出值，但是，如果你需要逆序遍历也很简单，只需要使用 downTo() 方法即可。1for (i in 4 downTo 1) print(i) // prints "4321"如果需要定义步长，使用 step() 方法123for (i in 1..4 step 2) print(i) // prints "13"for (i in 4 downTo 1 step 2) print(i) // prints "42"4. 原理范围需要实现一个 ClosedRange&lt;T&gt; 接口。ClosedRange&lt;T&gt; 代表着一个闭区间，它有两个变量 start 和 endInclusive，分别代表着区间的两端。它主要的方法是 contains() 一般应用在 in 和 !in 的范围检查中。对于步长和逆序方法，它们主要是通过 *Progression 来实现的；目前 Kotlin 拥有 IntProgression, LongProgression, CharProgressionProgresssion 接受三个参数，first 、last 和一个非零的 increment。Progression 主要实现了 Iterable&lt;N&gt; 接口，进行遍历的操作和以下的 Java 代码类似123for (int i = first; i != last; i += increment) &#123; // ...&#125;Progression 类主要通过以下方法进行构建1IntProgression.fromClosedRange(start, end, increment)注意 increment 不能是负的，也就是说不允许出现1(last - first) % increment == 05. 其他有用的方法除了上面介绍的有用的方法外，还有一些比较有用的方法。5.1 reversed()很简单，用于反转整个流程。123fun IntProgression.reversed(): IntProgression &#123; return IntProgression.fromClosedRange(last, first, -increment)&#125;]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin 集合]]></title>
    <url>%2FKotlin%2FKotlin%20%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[1. 概述和许多其他语言不同的是， Kotlin 将集合分成了可变和不可变两大类。理解和区分可变集合和不可变集合是很重要的，Kotlin 致力于尽量将事务显式化，所以 Kotlin 对这两种集合进行了区分。2. 与 Java 的区别与 Java 相比的很大的不同点在于，Kotlin 的 List 是 List&lt;out T&gt;，而不是 List&lt;T&gt;，也就是说 Kotlin 的 List 是只读的，而对应的 MutableList&lt;T&gt; 才是可写的。其他的集合类型如 Set、Map 同样继承了这个特点。123456789val numbers: MutableList&lt;Int&gt; = mutableListOf(1, 2, 3)val readOnlyView: List&lt;Int&gt; = numbersprintln(numbers) // prints "[1, 2, 3]"numbers.add(4)println(readOnlyView) // prints "[1, 2, 3, 4]"readOnlyView.clear() // -&gt; does not compileval strings = hashSetOf("a", "b", "c", "c")assert(strings.size == 3)3. 创建Kotlin 没有专门的语法或者构造器来构建一个集合类型；反之，Kotlin 使用标准库中的方法对集合类型进行构建，比如说 listOf() mutableListOf() setOf() mutableSetOf()需要注意的是，上面的 readOnlyView 引用指向的是同一个列表，如果一个列表只有一个引用指向它，而且该引用是不可变类型的话，那么这个列表就是不可变的。也就说一个不可变的集合可以接受一个可变集合的引用生成这样的一个列表的简易方法是：1val items = listOf(1, 2, 3)目前，listOf() 方法返回的是一个 array list，以后可能会采用更为节省内存的实现方法。需要注意的是，不可变集合是协变的，也就是说一个 List&lt;Shape&gt; 可以接受一个 List&lt;Rectangle&gt; 变量，如果 Rectangle 是继承于 Shape 的话。相反，可变类型的集合没有这个特性。4. 返回一个只读列表的快照有时候，虽然类中的列表在不断变动，但是你只想给调用者呈现一个某时刻的只读列表，可以使用如下方法1234class Controller &#123; private val _items = mutableListOf&lt;String&gt;() val items: List&lt;String&gt; get() = _items.toList()&#125;toList() 方法只是简单的复制了列表中的元素，而且保证它是只读的，这样调用者就可以得到调用时列表的状态，而且是只读的。5. 其他有用的方法列表类中还拥有其他十分有用的扩展方法。123456789val items = listOf(1, 2, 3, 4)items.first() == 1items.last() == 4items.filter &#123; it % 2 == 0 &#125; // returns [2, 4]val rwList = mutableListOf(1, 2, 3)rwList.requireNoNulls() // returns [1, 2, 3]if (rwList.none &#123; it &gt; 6 &#125;) println("No items above 6") // prints "No items above 6"val item = rwList.firstOrNull()同样，Map 也继承了这个特点123val readWriteMap = hashMapOf("foo" to 1, "bar" to 2)println(readWriteMap["foo"]) // prints "1"val snapshot: Map&lt;String, Int&gt; = HashMap(readWriteMap)]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin 高阶函数和 Lambda]]></title>
    <url>%2FKotlin%2FKotlin%20%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E5%92%8C%20Lambda%2F</url>
    <content type="text"><![CDATA[1. 高阶函数Kotlin 允许函数接受一个函数引用作为参数，这样的函数被称作高阶函数。这使得回调机制在 Kotlin 中更容易被实现。1.1 声明123456789fun &lt;T&gt; lock(lock: Lock, body: () -&gt; T): T &#123; lock.lock() try &#123; return body() &#125; finally &#123; lock.unlock() &#125;&#125;上面的这个例子中，body 就是一个函数引用，它的类型是 () -&gt; T，表示该函数不接受参数，返回类型是 T。可以看到，在这个高阶函数中，可以直接使用 body() 对 body 函数进行调用。1.2 调用调用高阶函数需要传入另一个函数作为其参数，这是 Kotlin 反射机制中的一部分。Kotlin 使用函数引用来指明一个函数对象，其形式是 ::functionName，例如：123fun toBeSynchronized() = sharedResource.operation()val result = lock(lock, ::toBeSynchronized)这个例子中 ::toBeSynchronized 就是函数 toBeSynchronized() 的函数引用。除此之外，高阶函数还可以接受一个 Lambda 表达式作为其函数参数。1val result = lock(lock, &#123; sharedResource.operation() &#125;)Lambda 会在接下来的章节介绍，但是为了更好地理解高阶函数，先来几点简单的概述：Lambda 表达式无论何时都使用 {} 和其他表达式分隔-&gt; 之前的是 Lambda 表达式的参数-&gt; 之后的是 Lambda 表达式的主体特别的，如果一个高阶函数的函数引用参数在最后一位，那么该参数能在括号外被指定。123lock (lock) &#123; sharedResource.operation()&#125;另一个高阶函数的例子是 map() 函数。123456fun &lt;T, R&gt; List&lt;T&gt;.map(transform: (T) -&gt; R): List&lt;R&gt; &#123; val result = arrayListOf&lt;R&gt;() for (item in this) result.add(transform(item)) return result&#125;它可以这样被调用：1val doubled = ints.map &#123; it -&gt; it * 2 &#125;注意到，如果高阶函数只有唯一的一个参数，而且这个参数是一个函数类型的，那么调用它的圆括号也可以被省略。1.3 it 参数如果一个 Lambda 表达式只拥有一个参数，那么其参数的声明和箭头符号(-&gt;)都可以省略。1ints.map &#123; it * 2 &#125;这个唯一的参数被命名为 it，这是一个隐式的默认单参数名称。当 Lambda 表达式像上面那样被调用时，不能使用 it 以外的名称来指代唯一的参数。2. Lambda 表达式Lambda 表达式是一种匿名的函数，它只有文字上的函数定义，而没有实际的名称。也就是说 Lambda 表达式是一种没有被声明，却会被立即执行的函数。考虑如下的高阶函数1max(strings, &#123; a, b -&gt; a.length &lt; b.length &#125;)其中的 Lambda 表达式和 compare() 方法是等价的。1fun compare(a: String, b: String): Boolean = a.length &lt; b.length注意到，lambda 是一个表达式，所以它最后一个语句的执行结果就是它的返回值。2.1 函数类型对于上面的 max() 方法，定义如下：1234567fun &lt;T&gt; max(collection: Collection&lt;T&gt;, less: (T, T) -&gt; Boolean): T? &#123; var max: T? = null for (it in collection) if (max == null || less(max, it)) max = it return max&#125;它是一个高阶函数，其中， less 的类型是一个函数(T, T) -&gt; Boolean，意味着 less 函数接受两个 T 类型的参数，返回布尔值。对于函数类型，除了上面的这种声明方法外，也可以给函数类型中的各个变量赋上名称。这将有助于说明该函数类型的调用方法和作用。1val compare: (x: T, y: T) -&gt; Int = ...2.2 Lambda 表达式的语法一个 lambda 表达式总是在花括号内；参数的定义在括号之内，-&gt; 之前，而且可以省略类型；函数的主题在 -&gt; 之后。1val sum: (Int, Int) -&gt; Int = &#123; x, y -&gt; x + y &#125;同时，只有一个参数的 lambda 表达式可以直接省略参数声明和 -&gt;如果高阶函数的函数类型参数在最后一位，那么 lambda 表达式可以在圆括号之外。2.3 匿名函数lambda 表达式语法中缺少对返回类型的指定，在通常情况下，这是非必须的，因为大多数的返回类型都可以被自动推断出来。当然，如果你需要显式地声明返回类型，可以使用匿名函数1fun(x: Int, y: Int): Int = x + y一个匿名函数和常规的函数声明很像，只不过它的名字被省略了。匿名函数除了表达式之外，也可以使用语句块作为函数主体。123fun(x: Int, y: Int): Int &#123; return x + y&#125;当匿名函数的参数类型能够被推断得出时，其参数类型可以被省略。1ints.filter(fun(item) = item &gt; 0)同样的，匿名函数的返回类型也可以不显式指明，直接由函数主体推断得出。需要注意的是，匿名函数的参数必须在圆括号之中，只有 Lambda 表达式材才允许在圆括号外传递参数。匿名函数和 Lambda 表达式的一个主要区别是：在 Lambda 表达式中的 return 语句会从其外部函数返回（即对应的高阶函数）；而在匿名函数中的 return 将会在匿名函数自身返回。实际上，return 所对应的是最近的 fun 函数（这称为 local return），但是根据这个帖子，非本地返回特性只支持内联函数，所以从一个非内联的 lambda 使用 return，是不可能的。但是匿名函数可以进行这种操作，当你需要从 lambda 使用 return 时，使用匿名函数来代替它。https://www.reddit.com/r/Kotlin/comments/3yybyf/returning_from_lambda_functions/2.4 闭包闭包指的是内部函数可以访问外部变量，Kotlin 的 lambda 表达式、匿名函数、局部函数和 object expression 都支持这一特性。12345var sum = 0ints.filter &#123; it &gt; 0 &#125;.forEach &#123; sum += it&#125;print(sum)而且和 Java 不同的是，被闭包捕获的外部变量是可以改变的。2.5 带接收者的函数Kotlin 还支持定义一个带接收者的函数字面量，这样就可以在 lambda 表达式和匿名函数内部调用接收者的成员。1sum : Int.(other: Int) -&gt; Int与扩展函数的区别：带接收者的函数没有名字，只能通过匿名函数或者 lambda 表达式来使用这里定义了一个 sum() 函数，它的接收者是一个 Int 对象。那么就可以像这样调用：11.sum(2)通过匿名函数，我们可以定义一个带接收者函数的变量。1val sum = fun Int.(other: Int): Int = this + other当接收者能从上下文被推断出来时，可以使用 lambda 表达式来调用接收者成员。1234567891011121314class HTML &#123; fun body() &#123; ... &#125;&#125;fun html(init: HTML.() -&gt; Unit): HTML &#123; val html = HTML() // create the receiver object html.init() // pass the receiver object to the lambda return html&#125;html &#123; // lambda with receiver begins here body() // calling a method on the receiver object&#125;]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Network API]]></title>
    <url>%2FProjects%2FMdzzProject%2FNetwork%20API%2F</url>
    <content type="text"><![CDATA[1. 说明必须先看说明！！所有的网络请求 API 均位于 NetworkUtils 类中，以静态方法形式呈现。API 方法包括三个参数——发起请求的必要信息，一个结果回调监听器和一个错误回调监听器，并返回一个 Request 对象用于取消请求如下，registerInfo 是存储注册信息的对象，listener 是结果监听器， errorListener 是错误监听器。123public static Request register(RegisterInfo registerInfo, Response.Listener listener, Response.ErrorListener errorListener)取消请求调用 Request 类的 cancel() 方法即可。API 方法中的两个监听器需要调用者自行实现对结果和错误的处理如下是一个匿名类的监听器实现：123456789101112131415register(registerInfo, // 这个是结果监听器 new Response.Listener&lt;BaseResponse&gt;() &#123; @Override public void onResponse(BaseResponse response) &#123; // Do with response &#125; &#125;, // 这个是错误监听器 new Response.ErrorListener() &#123; @Override public void onError(VolleyError error) &#123; // Handle error &#125; &#125;);回调结果(Response)采用继承模型，所有网络结果均是或继承于BaseResponse，由其派生以增加相应字段。即所有的回调结果都至少包含 BaseResponse 的字段BaseResponse 包括两个字段，status 和 message。BaseResponsestatus(boolean): 用于表示请求的成功状态message(String): 用于描述结果信息，一般来说将其直接呈现给用户即可其余具有特殊相应字段的结果均继承自 BaseResponse，通过派生增加新字段。如登陆的回调结果需要包含 token，则通过建立新的 LoginResponse 继承 BaseResponse ，在 LoginResponse 中增加 token 字段。回调结果类均存储在 models.response 包中。关于各个 API 回调结果的说明，请参照服务器端文档请通过使用 VolleyErrorHelper 类来获取网络错误信息的形式来处理网络错误，不要自己处理。VolleyErrorHelper 类位于 utils 包中。其中也包含了一个展示默认 Snackbar 的 display() 方法2. API 列表这里只列出发起请求的必要参数，剩下的两个监听器不予列出。返回的 Request 对象同上，不予列出。2.1 注册1register(RegisterInfo registerInfo)registerInfo：保存用户注册信息的容器类对象，仅包括用户在注册界面填写的信息。2.2 获取验证码1getAuthCode(String phoneNumber)phoneNumber：用于获取验证码的用户手机号，要求 11 位，以 1 开头。]]></content>
      <categories>
        <category>工程</category>
        <category>MDZZ</category>
      </categories>
      <tags>
        <tag>工程</tag>
        <tag>MDZZ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin 类型检查和造型]]></title>
    <url>%2FKotlin%2FKotlin%20%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5%E5%92%8C%E9%80%A0%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[1. 类型检查使用 is 和 !is 来检查一个变量的类型12345678910if (obj is String) &#123; print(obj.length)&#125;if (obj !is String) &#123; // same as !(obj is String) print("Not a String")&#125;else &#123; print(obj.length)&#125;2. 智能造型(Smart Cast)智能造型指的是，当一个对象满足一个 is 表达式时，它就会被自动转换成这个类型。12345fun demo(x: Any) &#123; if (x is String) &#123; print(x.length) // x is automatically cast to String &#125;&#125;同样的，它也支持否定检查12if (x !is String) returnprint(x.length) // x is automatically cast to String也支持 &amp;&amp; 和 || 表达式123456// x is automatically cast to string on the right-hand side of `||`if (x !is String || x.length == 0) return// x is automatically cast to string on the right-hand side of `&amp;&amp;`if (x is String &amp;&amp; x.length &gt; 0) print(x.length) // x is automatically cast to String同样，在 when 和 while 语句中也支持这个特性12345when (x) &#123; is Int -&gt; print(x + 1) is String -&gt; print(x.length + 1) is IntArray -&gt; print(x.sum())&#125;但是，智能造型在编译器无法保证在检查和使用的过程中类型不会发生变化时，不能使用。具体来说，智能造型在以下场景中有效：val 局部变量：总是有效val 属性这个属性是 private 或者 internal；对于它的检查代码与它的声明在同一个模块中时注意，智能造型不适用于具有自定义 getter 或者开放的变量(public)var 局部变量这个变量没有在检查和使用代码间进行改动这个变量没有被修改它的 lambda 表达式捕获var 属性：总是无效3. 不安全的造型通常来说，当一个造型操作会丢出异常时，说明这个造型操作是不安全的。对于这种造型操作，Kotlin 使用 as 关键字。1val x: String = y as String注意，null 不能强制转换成 String，如果 y 是 null，那么上述代码将会抛出异常。我们可以使用一个 nullable 对象来进行造型1val x: String? = y as String?4. 安全的造型为了避免在造型中抛出异常，我们可以使用一个安全的造型操作符 as?。它会在造型失败时返回 null1val x: String? = y as? String注意，虽然 as? 右边是一个非空类型，但是造型返回的结果也可以为空。]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观察者模式(Observer Pattern)]]></title>
    <url>%2FDesignPattern%2F%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F(Observer%20Pattern)%2F</url>
    <content type="text"><![CDATA[1. 概述观察者模式，是在对象间定义一个一对多的关系。当“一个” 对象的改变状态，依赖它的对象都会收到通知，并自动更新。其中，“一个” 对象称作主题、可观察者、被观察者；“多个” 对象被称作观察者、倾听者、订阅者。这有点类似报社和读者的关系：发生新闻后，报社通过报纸来通知读者。实际上就是一个典型的观察者模式。事实上，观察者模式是 JDK 乃至实际程序和库中使用得最多的设计模式。基本上所有的 Java GUI 均实现了观察者模式。（也就是 Listener）2. 实现方式2.1 实现思路封装变化观察者模式中，主题的状态和观察者的种类和数量都会变化。所以，需要对观察者进行封装。同理，观察者也可能订阅多个主题，所以主题也需要进行封装。针对接口编程，不针对实现编程所以，我们使用接口，分别将主题和观察者进行封装。实际上就是让各个主题实现统一的 Subject 接口；观察者实现统一的 Observer 接口。多用组合，少用继承观察者模式是一个一对多的依赖关系，这意味着，主题必须维护一个观察者列表。状态改变后，通过调用通知方法来逐个通知观察者。实际上，这意味着将观察者组合进了主题中。2.2 图解3. 新设计原则——松耦合为了交互对象之间的松耦合设计而努力！所谓的松耦合，指的就是两个类、函数、模块之间相关度不高，改变其中的一个类不会造成另一个类的大幅变化。观察者模式通过接口的形式来进行交互，主题可以随时增加和删除观察者列表中的观察者；观察者也不需要关心主题的内容，它只需要接受主题的通知就可以了。4. 气象站例子的 UML 图解5. 推和拉实际上，主题向观察者发送通知并不只有主题向观察者推送这一个方法；我们还可以让观察者主动从主题拉取数据。它们的主要区别在于：推的通知方法包含数据，而拉的不包含，只负责传输主题的引用。12345678910111213// Pushpublic void notifyObservers() &#123; for (observer : list) &#123; observer.update: 2016-11-25 &#125;&#125;// Pullpublic void notifyObservers() &#123; for (observer : list) &#123; observer.update: 2016-11-25 &#125;&#125;拉的方法实现起来也很方便：首先主题提供 getter随后将主题本身作为参数传递给观察者即可。采用拉的好处在于，观察者种类繁多，需要的数据不尽相同，这样一来，观察者只需要获取自己感兴趣的数据即可，而不需要同时拿到一大堆自己不想要的数据。书中提到如果采用拉，当扩展功能的时候，就不必要更新和修改观察者的调用，而只需改变自己来允许更多的 getter 方法来取得新增的状态。这个观点固然不错，但是实际上，我们可以通过将数据封装成一个类来解决调用的问题。事实上，根据 OO 设计的原则，应该 Tell, Don’t Ask ，所以使用推的方法会更好。6. Java 内置的观察者模式Java API 中内置了一个观察者模式，包含一个基本的 Observer 接口和一个 Observable 类。我们可以使用 Java 的内置 API 来快速的实现观察者模式，而不需要自己再造轮子。基本的类图如下：其中，setChanged() 方法是用来指示状态改变的。在调用 notifyObservers() 之前，需要先调用这个方法。同时，Java 也实现了推和拉的方式。不带参数的 notifyObservers() 使用的是拉的方法，而带参数的使用的是推。1234567891011public notifyObservers(Objecgt arg) &#123; if (changed) &#123; for (observer : list) &#123; observer.update: 2016-11-25 &#125; &#125;&#125;public notifyObservers() &#123; notifyObservers(null);&#125;7. Java 内置观察者模式的缺陷违反面对接口编程原则由于 Observable 是一个类，并且实现了自己的通知方法，我们的通知途径就被绑定在了 Observable 的具体实现上，无法轻易改变。这也导致了对观察者的通知次序被绑定而无法改变。同时，由于 Java 禁止多重继承，所以无法对 Observable 进行复用。违反多用组合，少用继承Observable 中的 setChanged() 方法是 protected 的，这意味着如果不继承 Observable 就无法修改 setChanged() 方法。所以，如果应用要求弹性高，那么更好的方法应该是：自己重新造轮子！]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
      <tags>
        <tag>DesignPattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[策略模式(Strategy Pattern)]]></title>
    <url>%2FDesignPattern%2F%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F(Strategy%20Pattern)%2F</url>
    <content type="text"><![CDATA[1. 概述策略模式：定义算法族，分别封装起来，使它们可以相互替换。此模式让算法的变化独立于使用算法的用户。2. OO 基础抽象封装多态继承3. 设计原则封装变化将应用（类）中有可能变化的部分封装出来，和稳定的部分相互隔离针对接口编程，而非针对 实现编程为了运行时能动态改变类的行为，我们应该针对接口编程，而非针对实现编程。也就是说，使用接口来实现各个行为，而不是将行为固定在类的具体实现中。多用组合，少用继承has-a 比 is-a 更好，能够得到更多的应用弹性。4. 具体实现关键：使用委托，并使用 setter 实现行为的动态变化。4.1 使用接口封装行为4.2 对象包含接口4.3 使用 Setter 实现运行时更改行为1234ModelDuck modelDuck = new ModelDuck();modelDuck.performFly(); // FlyNoWaymodelDuck.setFlyBehavior(new FlywithWings());modelDuck.performFly(); // FlywithWings]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
      <tags>
        <tag>DesignPattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我心中的全面小康社会]]></title>
    <url>%2FHomework%2F%E6%88%91%E5%BF%83%E4%B8%AD%E7%9A%84%E5%85%A8%E9%9D%A2%E5%B0%8F%E5%BA%B7%E7%A4%BE%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[“小康”，一个由儒家经典著作中引申而出的词语，经过中国改革开放的总设计师——邓小平的重新演绎——“我们的目标，第一步是到2000年建立一个小康社会，这是指在温饱的基础上，生活质量进一步提高，达到丰衣足食。”，成为了中国人在新世纪的奋斗目标。而习近平总书记提出的“确保到2020年实现全面建成小康社会的奋斗”更加充实了中国人民实现全面小康社会的信念和信心。2020 年，中国即将实现全面的小康社会，下面就来谈谈我自己对“全面小康社会”的理解。首先，在经济方面，居民收入进一步提高，我国的人均 GDP 达到 10000 - 12000 美元 左右，正式进入中等收入国家。经济转型成功，新经济和第三产业发展迅猛，对中国经济的贡献比例飞速增长，达到或超过三分之二。城乡居民收入翻番，居民消费能力显著增长，国内经济由投资拉动为主变为国内消费和国内需求拉动为主。沿海的劳动密集型产业逐步升级或向中西部和东南亚迁移，经济重心逐步转为依托当地或周边大学发展高新科技产业，以高新科技指导的新型制造业基本成型。其次，在文化方面，文化产品（小说，游戏，电影，电视剧等）的分级制度初现雏形，文化题材限制有所放宽，由此带来文化产业方面发展的大爆发，一时众多文化艺术形式、产品和相关产业纷纷涌现，中国的文化企业和相关事业单位迎来了前所未有的发展机遇。知识产权保护体系初步完善，公民的知识产权保护意识提升，从而进一步促进了文化产业的发展。在法制方面，中国特色社会主义法律体系进一步完善，各行各业全面实现有法可依。法律相关工作者的从业门槛提升，考核标准提高，公民的法律意识水平提高，全面实现有法必依，执法必严，违法必究。交通和城建方面，在 2020 年基本实现了中国中东部省份县级城市和城镇通高铁或动车组列车，原有铁路线路进行新一轮提速，基本消除了 100 KM/H 以下速度的客运列车。十八大后实施的大规模棚户区改造完成，城镇居民都住进了居民小区。农业方面，由于城镇化程度提高，农村耕地流转出现集中化趋势，乡村企业规模迅速扩大，初步实现了农业机械化和集中化、规模化生产，中国的农业出现新一轮大发展趋势，粮食产量增速加快，农业科技得到进一步积累和发展。在医疗领域，由于互联网的飞速发展以及其与医学的紧密结合，名医指导手术和远端会诊得到普及，同时，中国社区医院体系和医生自由流转体系全面建立]]></content>
      <categories>
        <category>Homework</category>
      </categories>
      <tags>
        <tag>Homework</tag>
        <tag>Situation and Policy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Clean Code]]></title>
    <url>%2FCleanCode%2FClean%20Code%2F</url>
    <content type="text"><![CDATA[1. 观点代码混乱的代价十分庞大写整洁代码是十分有必要的我们是作者，代码是写给别人看的，要让人迅速看懂2. 有意义的命名命名要体现本意避免使用模糊的名称命名要避免误导不应出现 List 或 Map 等指示变量类型的名称。简单加个 s 或使用其他表示复数的表示法即可。命名要避免废话和冗余缺乏明确约定的前提下，不应使用冠词和无意义的后缀如 theMessage 和 message命名要简单易读不要生造词，要使用易读的英文命名要易于搜索名称长短应与其作用域大小相对应大作用域内，不应直接使用数字常量。避免使用匈牙利命名法命名不应前缀或后缀变量类型避免使用成员前缀在现代 IDE 中，没有必要使用冗余的成员前缀。在过多的使用前缀后，前缀将会被越来越多的忽略。避免使用接口前导字母原因和上条相同，只不过这里指的是类一级避免产生思维定式应使用较为直白的命名，而不是生造一些定式单字词关于类名类名是名词或者名词短语。类名不应该是动词。方法名方法名是动词或者动词短语。getter, setter 和 assert 应依照 Javabean 标准使用 get, set 和 is 前缀别扮可爱代码是严肃的，直白的。不应当出现过于幽默或者恶搞的命名每个概念对应一个词对于每个抽象概念取一个词，并确定下来。不要使用双关时刻保证每一个词只会代表一种含义如 add 方法用于连接两个现有值产生新值，则将单个值插入 collection 的方法就不能命名为 add，应命名为 insert 或者 append使用技术性名称看代码的都是程序员，使用技术性名称会更加靠谱。使用源自问题领域的名称如果不能使用技术性的名称，则应使用源自问题领域的词汇。添加有意义的语境很少有名称能够自我说明，最好为命名添加语境。只有一个变量时，可以为其添加前缀说明语境。但同一语境的变量过多时，应优先选择类作为变量的语境不要添加没用的语境只要短名称足够清楚，就不要使用长名称3. 函数函数应尽可能短小最佳的函数逻辑行数应该在个位数函数应该只做一件事一个函数应该只做一项工作。如果当前函数能够拆分出一个新函数，这说明其依然不够简洁。应确保 switch 埋藏在较低的抽象层级，并不重复很不幸的是， switch 语句没有办法避免。所以只能将其尽量地包装起来，不要嵌套过深。函数应使用描述性的名称函数名称总比注释要好函数参数应尽量简洁参数个数越少越好。尽量避免输出参数，应从返回值输出。]]></content>
      <categories>
        <category>CleanCode</category>
      </categories>
      <tags>
        <tag>CleanCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大创项目]]></title>
    <url>%2FProjects%2FBigInovation%2F%E5%A4%A7%E5%88%9B%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[这是一个大创项目的备忘录1. 主题暂定地下车库导航利用室内定位技术，结合地下车库地图给予用户路线导航，车辆定位，车位定位等功能。具体论文资料等由老师（的博士生）提供。2. 成员（暂定）李东霖唐葛夫刘聪邢瑞斌3. 大致行程4 月底 - 5 月初，立项，项目文档9 月份第一次检查]]></content>
      <categories>
        <category>工程</category>
        <category>大创</category>
      </categories>
      <tags>
        <tag>工程</tag>
        <tag>大创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VisualNav 编码规范]]></title>
    <url>%2FCleanCode%2FVisualNav%20%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[1. 通用规范VisualNav 项目的代码文件主要包含 Java、XML 以及 Gradle 三种。对于所有的代码文件，都需要遵守以下几条规范：所有代码文件都必须使用 UTF-8 进行编码；使用空格而不是制表符进行缩进，每个缩进的单位为 4 字符（使用 Android Studio 默认配置即可，不要修改缩进配置）；每行仅书写一条语句，多条语句不能写在同一行中；限制代码行的长度，每行不应该超过 100 字符。如果一条语句的长度超过 100 字符，需要适当地进行断行，具体断行的方法会在不同文件类型的规范中进行规定；注释详细。推荐使用英文注释，也可以使用中文进行注释。对注释的具体要求会在不同文件类型的规范中进行规定；每个代码文件的末尾必须有且只有一个空行。2. Java 编码规范2.1 文件组织每个 Java 源文件都必须包含一个唯一的公共类或者接口，这个公共类或者接口与所在文件同名，并且必须是文件中的第一个类或者接口。与公共类相关的私有类和接口可以在公共类的定义之后进行定义。2.2 注释必须使用 Javadoc 标准注释。具体注释要求如下：2.2.1 类/接口注释对于每个类和接口，都应该在类和接口定义之前给出一条注释，介绍这个类的主要功能。注释可以是名词性质的短语，也可以是以第三人称的动词开头的句子例如：123456/** * A request for fetching user info. */public class UserInfoRequest extends Request &#123; ...&#125;2.2.2 方法注释对于类中自建的方法，必须在方法定义之前给出一条注释，描述方法的用途、参数、返回值以及可能抛出的异常。注释是以第三人称的动词开头的句子。例如：12345678910/** * Parses a &#123;@link org.json.JSONObject&#125; into a User object. * * @param userObject &#123;@link org.json.JSONObject&#125; to be parsed * @return a User object * @throws JSONException if JSON is invalid */public User parseJson(JSONObject userObject) throws JSONException &#123; ...&#125;一般情况下，类中属性的 get 和 set 方法不需要 Javadoc 注释。如果 get 和 set 方法会带来特殊的效果，或者对应的属性不容易理解，就需要提供注释。例如：12345678/** * Sets the last name of user. * Name of user will also be update: 2016-11-18 */public void setLastName(String lastName) &#123; this.mLastName = lastName; this.mName = this.mFirstName + " " + this.mLastName;&#125;2.2.3 一般注释主要包括代码块注释和行尾注释。代码块注释编写方法的时候，需要为每个代码块加上一条注释，描述这个代码块的功能。简单的代码块（如变量声明）无需注释。注释是以第三人称的动词开头的句子。如果注释只有一行，使用单行注释（//），否则使用块注释（/* ... */）。语句注释一些关键的、不易理解的语句需要加上注释进行解释。如果注释内容很短，使用单行注释（//）在行尾添加注释，并与语句之间留有一定的间隔使之可读。此时对注释的书写格式没有具体要求。如果注释内容较长或者语句较长，使用单行注释（//）在语句之前添加独立的一行注释。注释的书写格式和代码块注释相同。例如：1234567891011121314151617// Prepares parameters for the request.JSONParams params = new JSONParams();params.addParam("name", mName);// Fills up the request.mRequest = new JsonObjectRequest(mUrl, null, new Response.Listener&lt;JSONObject&gt;() &#123; ... &#125;, new Response.ErrorListener() &#123; ... &#125;);mRequest.setShouldCache(false); // disable caching// Executes the request.super.execure();2.2.4 关于调试用注释master 分支或合并到 master 分支的代码不允许出现调试用的注释所谓调试用的注释即为，为了调试目的而使某些代码暂时失效的注释例如：12345public void doSomeThing() &#123; do1(); do2();// do3(); // 此即为调试用注释，master 分支上的代码不允许出现这种注释&#125;有关 Git 的规范，请看下面的 Git 规范 部分2.3 缩进与排版除了第 1 节中提出的一些通用规范，还应该遵守以下缩进和排版的规范。2.3.1 换行对于长度过长的语句，必须按以下规则断行：可以在逗号后断行；可以在运算符前面断行；新的一行开头应该与上一行同一级别的表达式开头对齐；如果满足以上规则导致代码较为混乱，新的一行开头可以改为缩进8个字符。以下是一些对长语句断行的例子：长度过长的方法定义和调用，可以在参数处进行断行，并保持参数对齐。123public UserInfoRequest(Context context, String name, RequestSuccessListener&lt;User&gt; successListener, RequestErrorListener errorListener)在运算符处断开较长的表达式。1234567num1 = num2 * (num3 + num4 - num5) / num6 + (num7 - num8) * num9 / num10;if ((condition1 || condition2) &amp;&amp; (condition3 || condition4) &amp;&amp; !(condition5 || condition6)) &#123; ...&#125;大括号的使用规则：在任何情况下，左大括号（{）都要与语句在同一行，右大括号（}）独占一行。12345// 正确 错误if (a == 1) &#123; if (a == 1) ... &#123;&#125; ... &#125;编写方法时，按功能、步骤对代码进行分块，以一个空行分开不同的代码块。每个代码块都需要给出解释其作用的注释，具体格式参考 2.2.3 节。2.3.2 空格与括号需要在适当的位置插入空格或使用括号，使代码更可读。除一元运算符和 . 之外，运算符与运算数之间需要以空格分隔。12345678// 正确 错误a = 0 a=0a + b a+ba &lt; b a&lt;ba &amp;&amp; b a&amp;&amp;b!a ! aa++ a ++user.getName() user . getName()for 循环头的写法为：1for (int i = 0; i &lt; n; i++)括号与操作数之间不需要空格，例如：12// 正确 错误if (a == 1) if ( a = 1 )左大括号（{）之前需要一个空格，例如：1234// 正确 错误if (a == 1) &#123; if (a == 1)&#123; ...&#125; &#125;关键字与括号之间要添加 1 个空格，方法名、类名和括号之间不需要空格。12345// 正确 错误if (a == 1) if(a == 1)while (b == true) while(b == true)User user = new User(); User user = new User ();user.setName("Name"); user.setName ("Name");注释符号（//、/* 和 */）与注释内容之间需要加一个空格。12// 注释符号与注释之间有一个空格/* 就像这样 */强制类型转换后需要有一个空格。1mTextView = (TextView) findViewById(R.id.text)必要时需要为一些表达式加上括号（即使并没有出现运算符优先级的问题），以增强代码的可读性。例如：123if ((a &amp;&amp; b) || (c &amp;&amp; d) || e) &#123; ...&#125;2.3.3 空行在适当的位置插入空行使得代码更具有可读性：在两个方法之间要空两行123456789101112131415161718192021222324252627282930public void doSomeThing() &#123; // There // are // a // lot // of // stuffs /* * I cannot * simply * count */&#125;public void doOtherThing() &#123; // There // are // a // lot // of // stuffs /* * I cannot * simply * count */&#125;在类的不同的属性集合之间要有空行1234567891011// 上下文和视图 containerprotected View mRootView;protected SetPersonalizedInfoActivity mContext;// 各视图组件private WheelView firstTypeLpv;private WheelView secondTypeLpv;private TextView nextQuestionTxt;// 数据域private UserBean userBean = UserBean.getInstance();类的成员变量和方法之间要有空行1234567891011121314151617// 上下文和视图 containerprotected View mRootView;protected SetPersonalizedInfoActivity mContext;// 各视图组件private WheelView firstTypeLpv;private WheelView secondTypeLpv;private TextView nextQuestionTxt;// 数据域private UserBean userBean = UserBean.getInstance();//方法public void doSomeThing() &#123;&#125;public void doOtherThing() &#123;&#125;如果有内部类或内部接口，内部类与上下文要空两行若内部类或接口在所有代码的尾部，则不需要与下文有空行1234567891011121314public class OuterClass &#123; public void doSomeThing() &#123;&#125; public void doOtherThing() &#123;&#125; class InnerClass &#123; // 这里是内部类的一些东西 &#125; public void methodBehindInnerClass() &#123;&#125;&#125;方法内部不同功能的代码块要空行123456789101112131415161718192021222324public void onPrevFragment() &#123; // Pop back stack fragmentManager.popBackStack(); int index; // Find index for (index = 0; index &lt; fragmentTitles.length; index++) &#123; if (currentFragmentTag.equals(fragmentTitles[index])) &#123; break; &#125; &#125; // Set currentFragmentTag if (index &gt; 0) &#123; currentFragmentTag = fragmentTitles[index - 1]; &#125; // Set title assert getSupportActionBar() != null; getSupportActionBar().setTitle(currentFragmentTag);&#125;2.4 命名规范2.4.1 通用规范将缩写词作为普通单词处理。例如在类名中：1class XmlParser &#123;...&#125; // 而不是 XMLParser不允许出现 a, an, the 等冠词123void getTheResult() // 错误void getResult() // 正确除常量外，其余命名不允许出现下划线字符(_)2.4.2 包名包名必须为全小写字母。如果出现多个单词构成的包名，不进行分隔。例如：1com.example.packagename2.4.3 类名类名必须是名词或名词短语，每个单词首字母均大写。例如：1class ImageDownloader &#123;...&#125;2.4.4 接口名与类名规则相同。不需要加 I 前缀。12// 而不是IOnButtonClickListenerinterface OnButtonClickListener &#123;...&#125;2.4.5 方法名方法名是一个动词或动词短语，第一个单词的首字母小写，其余单词首字母均大写。例如：12public int getId()private void start();2.4.6 变量与常量名常量名所有字母均大写，单词之间以下划线（_）分隔。例如：1public static final String DATABASE_NAME = "...";类中的成员变量需要加前缀 m，每个单词首字母大写。例如：12private String mLastName;public int mAge;~类的静态成员变量需要添加前缀 s，其余每个单词首字母大写。例如：~12// 抛弃的旧规范private static int sCountOfInstances;局部变量第一个单词首字母小写，其余每个单词首字母大写。例如：1234public void method() &#123; int tempVariable; ...&#125;2.5 其他规范2.5.1 异常处理异常处理的首要原则是不能忽略异常。例如以下代码是不可取的：123try &#123; JSONTokener jsonTokener = new JSONTokener(jsonString);&#125; catch (JSONException ex) &#123; &#125;捕获到异常，必须对异常进行处理。不能捕获顶级异常（Exception）。必须根据异常的种类分别进行捕获和处理，不能直接捕获 Exception。以下代码是不可取的：12345try &#123; ... // 这里会抛出多种异常&#125; catch (Exception ex) &#123; ...&#125;正确的做法是：1234567try &#123; ...&#125; catch (OneKindOfException ex1) &#123; // 处理 ex1&#125; catch (AnotherKindOfException ex2) &#123; // 处理 ex2&#125;2.5.2 import 规范不要手动输入 import 语句或手动调整 import 之间的顺序，而应通过 Android Studio 提供的自动 import 功能来管理。例如，如果需要导入 java.util 包的 ArrayList 类，只需要输入 ArrayList，根据 Android Studio 自动弹出的提示选择正确的类，即可自动添加一条 import java.util.ArrayList; 语句。如果出现了导入之后没有使用的情况，应该对废弃的 import 语句进行清理。2.5.3 Java Annotation 的使用规范Annotation 必须出现在其他任何修饰符之前，每个 Annotation 独占一行。例如：1234@Overrideprotected void onCreated(Bundle savedInstanceState) &#123; ...&#125;只要类中的一个方法覆盖了所在类或者父类中的方法，必须为这个方法加上 @Override。2.5.4 使用 TODO 注释TODO 注释用于标记和管理待办事项。在当前无法完成某项工作时，必须将待办的工作用 TODO 注释写在相应的位置。TODO 注释的用法是：只要在注释中出现独立的（作为一个独立单词的）TODO，即可生成 TODO 注释。一般的做法是在注释开头标记 TODO。例如：1// TODO: add a click listener for button3. XML 编码规范XML 文件的编码规范以 Android Studio 默认格式为准，主要包括以下几条要求：命名空间（xmlns）全部写在 XML 文件根元素的开始处，并按字母顺序排序；元素的 id 属性必须位于其他所有属性之上，布局和尺寸属性位于 id 属性下方、其他属性之上；不同元素之间必须以一个空行分隔；元素的开始标签中，属性不能和元素出现在同一行，并且向右缩进4个字符；所有字符串不允许硬编码，必须统一写入 strings.xml 资源文件并通过 @string 标记引用；不含有内容的元素必须使用闭合标签（&lt;name /&gt;），不能使用标签对（&lt;name&gt;&lt;/name&gt;）；编辑完成 XML 文件后，请使用 Android Studio 的 Code 菜单中的 Reformat Code 功能对格式进行自动调整。4. Git 规范这里主要遵循的是 Git Flow 的简化版，主要包括以下几点要求：4.1 提交请保证以下操作在 commit 之前完成进行代码分析，解决可以解决的 Warning。优化 import 语句Reformat 代码关于 Commit Message以动词开头的祈使句，首字母大写1git commit -m "Add GSON module"信息过多，应进行折行，而不能在一行内写完此时应使用 git commit 在弹出的编辑器中填写多行信息1234567git commit"""Fix the moudule:1. Remove the unnessary method2. Replace the ListView with RecyclerView"""Commit Message 内容应要尽量意义丰富。尽量说明操作内容和所涉及到的部分12"Fix bug" // 错误"Fix not render bug of the register page" // 正确建议采用 “Fix issue” 形式来让 Message 更加简洁相应的，在对应的 issue 就要对问题进行详细的描述1234// 都是正确的"Fix #1""Fix the bug of #2""Fix the render bug of #3"4.2 拉取养成良好习惯，编码前先同步 master 分支如果有重构相应事项，先进行处理后再编码采用 git pull --rebase 代替简单的 git pullrebase 可以生成相对简洁的版本线图4.3 分支不设立 develop 分支master 分支应是随时可以运行的，不允许出现不可运行的错误（编译错误，打开即 Crash 等）各分支的内容应基于最新的 master 分支程序架构进行编写，可以随时无冲突的 merge 到 master4.4 合并向 master 分支的合并原则必须通过 Pull Requet 进行合并到 master 分支的代码不允许出现调试用的注释所有分支应保证彻底运行无误后，才能 merge 到 masterFeature 分支向 master 分支的合并原则上，管理员应在 18 小时之内回应项目组成员的 PullRequest，若管理员超时未进行回应或合并操纵，开发者可经测试后自行合并。但仍然需要提出 Pull Request 并阐述分支的 Changelog, 以便代码审查。HotFix 分支向 master 分支的合并HotFix 分支的合并可以不经管理员批准或等待流程快速合并到 master 上。但仍需要提出 Pull Request，保留 Changelog （紧急的可以合并后再写）其他分支的相互合并不允许使用 Pull Request 进行其他分支的相互合并由负责成员之间相互协商解决其他要求放宽可以存在不能运行的 bug，但是必须在 merge 到 master 分支之前解决。4.5 冲突冲突必须立即解决，不允许忽视冲突 force push由其他分支相互合并引起的冲突，由相应开发者进行协商处理关于向 master 合并的冲突，请查看部分由于所有分支必须基于最新 master 程序架构编写，会出现此种冲突的场景仅存在于重构和 HotFix4.6 重构重构前需要重构时,重构发起人 必须发起 Issue 阐述重构 TODO 事项和最终的 Changelog重构中重构不允许直接在 master 分支进行修改，应新建分支进行重构 commit重构完成后重构完成后，向 master 提交 Pull Request，视为 Feature 分支向 master 分支合并进行处理流程。分支一旦被合并，合并操作者（管理员或相应重构开发者）应立即在各类有效平台通知各分支开发者。各分支开发者应在接收到通知后立即 merge master 分支，以保证基于最新 master 分支进行编写。关于冲突重构 Issue 应说明相应文件和目录结构变化情况当各分支 merge master 出现冲突时，按照相应 Issue 的修改进行 resolve conflict.4.7 热修补 （HotFix）热修补即是紧急的重构热修补发起人必须尽快通知管理员和项目组其他成员应使用可能的包括但不限于以下的通知方式:项目 Issue，QQ，微信，Telegram，邮件，电话，各协作平台等。热修补可以不提出 Issue，但应在对应的 Pull Request 中说明对应的修改内容。热修补仍然需要在新分支进行操作，但合并时无需经等待或批准流程。但仍然需要提出 Pull Request，之后可自行合并。注意，必须要在 Pull Request 中说明热修补的修改事项。（可以在合并后添加评论）其余事项均遵守重构相关规范]]></content>
      <categories>
        <category>CleanCode</category>
      </categories>
      <tags>
        <tag>CleanCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Coding Standards]]></title>
    <url>%2FCleanCode%2FJava%20Coding%20Standards%2F</url>
    <content type="text"><![CDATA[1. Naming1.1 CommonDo not allow a, an, the appear in the nametheCode, anException, getTheResult(), are all NOT correct.Name should be divide into wordsreSetStatus are not correct, it should be resetStatusNot allow single character prefix of variable nameThe aName, kFlag, cBook are all NOT correctThe name should be as meanningful as possible1.2 Special for identifiers1.2.1 ClassClassName use the UpperCamelCase1.2.2 VariablevariableName use the lowCamelCaseSingle character name should only appears in the Iterator12345678910// They are okayfor(int i : int[])for(int i = 0;i&lt;50;i++) &#123;&#125;// They are badint k;int i;for (int j = 0; j &lt; 50; j++) &#123; int i;&#125;But avoid using the single character name as possibleNot allow underscores12// That's not allowint red_color;1.2.3 MethodmethodName() use the lowCamelCaseDo NOT allow single chracter12// That's not allowpublic void a() &#123;&#125;Do NOT allow underscores12// They are not allowpublic void ini_Data() &#123;&#125;1.2.4 ParamaterDo NOT allow 1 character paramater12// That's not allowpublic void resetPosition(int a) &#123;&#125;1.2.5 ConstantConstant name use CONSTANT_NAME style. All UPPERCASE character and sperated by underscores.Every constant is in static final field, but not all static final field is constant1234567891011121314// Constantsstatic final int NUMBER = 5;static final ImmutableList&lt;String&gt; NAMES = ImmutableList.of("Ed", "Ann");static final Joiner COMMA_JOINER = Joiner.on(','); // because Joiner is immutablestatic final SomeMutableType[] EMPTY_ARRAY = &#123;&#125;;enum SomeEnum &#123; ENUM_CONSTANT &#125;// Not constantsstatic String nonFinal = "non-final";final String nonStatic = "non-static";static final Set&lt;String&gt; mutableCollection = new HashSet&lt;String&gt;();static final ImmutableSet&lt;SomeMutableType&gt; mutableElements = ImmutableSet.of(mutable);static final Logger logger = Logger.getLogger(MyClass.getName());static final String[] nonEmptyArray = &#123;"these", "can", "change"&#125;;1.2.6 Camel case: definedWith the defined name, should still obey the camelCaseProse formCorrectIncorrect“XML HTTP request”XmlHttpRequestXMLHTTPRequest“new customer ID”newCustomerIdnewCustomerID“inner stopwatch”innerStopwatchinnerStopWatch“supports IPv6 on iOS?”supportsIpv6OnIossupportsIPv6OnIOS“YouTube importer”YouTubeImporter2. Formatting2.1 Braces2.1.1 Braces is used as much as possibleBraces are used with if, else, for, do and while statements, even when the body is empty or contains only a single statement.2.1.2 Non-Empty braces:use the K &amp; R style{ should after a space and appear at the end of line( of control statement should have a space before it( of method should have no space before it1234567891011return new MyClass() &#123; @Override public void method() &#123; if (condition()) &#123; try &#123; something(); &#125; catch (ProblemException e) &#123; recover(); &#125; &#125; &#125;&#125;;2.2 BlankBlank should appear:Between methods123public void doSomeThing() &#123;&#125;public void doOtherThing() &#123;&#125;Between Set of attrs1234567891011// That's attrs set of context and containerprotected View mRootView;protected SetPersonalizedInfoActivity mContext;// That's attrs set of widgetprivate WheelView firstTypeLpv;private WheelView secondTypeLpv;private TextView nextQuestionTxt;// That's attrs set of dataprivate UserBean userBean = UserBean.getInstance();]]></content>
      <categories>
        <category>CleanCode</category>
      </categories>
      <tags>
        <tag>CleanCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[好用的工具]]></title>
    <url>%2FTools%2F%E5%A5%BD%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[这里收集一些好用的 WEB 生产力工具和网站。自动机绘图这是一个绘制自动机状态转移图的工具，做编译解析的一般都会用到。使用上一般没什么问题，需要注意的就是拖动箭头，可以使它弯曲。Processon一个在线的流程图、UML 图、UI 图等等的绘图工具。具有不错的界面，而且支持的图例也很多。强烈建议使用。不过对于 UML 的类图方面的支持不是很好。但是对于流程图来说已经是很不错的了。PlantText一个绘制 PlantUML 的在线网站，还支持导出 PNG 和 LaTex。虽然不能实时渲染，不过 UML 对实时渲染的要求也不是很高。]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[README]]></title>
    <url>%2FDesignPattern%2FREADME%2F</url>
    <content type="text"><![CDATA[本目录内容基于 Head First 设计模式。代码实例点这里为什么要学习设计模式设计模式是程序员的共通语言，减少沟通成本设计模式会让你保持高层级的观感设计模式可以让开发团队和开发人员快速成长有没有现成的设计模式轮子没有，学习设计模式以组织类来解决对应的问题是程序员责无旁贷的事情。虽然库和框架可能使用了某种设计模式，但是不代表它就是一个设计模式的库如果找不到对应的设计模式怎么办记住设计原则，从设计原则出发来解决问题。]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
      <tags>
        <tag>DesignPattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Material Drawer Tint Icon]]></title>
    <url>%2FAndroid%2FMaterailDrawer%2FMaterial%20Drawer%20Tint%20Icon%2F</url>
    <content type="text"><![CDATA[Material Drawer 是 GitHub 上有名的 Android Navigation Drawer 的实现库，目前有 6000 左右个星，充分说明它的流行和稳定性。这里来说说它的 Account Header 的 Profile Icon 的染色问题。目前，对于透明背景的图片，Profile Item 不会对背景进行染色；这样就可能导致在有背景图的时候，对于这种 Icon 有看不清的问题。作者对此表示不想修复，于是提供了一个 workaround 进行图片的染色。以下的 Kotlin 就是对一个默认的用户图标进行染色，然后返回染色后的 Drawable 的代码1234567891011fun getTintDefaultProfileIcon(activity: Activity): LayerDrawable &#123; val res = activity.resources val background = ShapeDrawable() background.paint.color = res.getColor(R.color.default_icon_bg, activity.theme) val icon = res.getDrawable(R.drawable.default_user_icon, activity.theme) return LayerDrawable(arrayOf(background, icon))&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>Materail Drawer</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>MaterailDrawer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 获取屏幕尺寸]]></title>
    <url>%2FAndroid%2FAndroid%20%E8%8E%B7%E5%8F%96%E5%B1%8F%E5%B9%95%E5%B0%BA%E5%AF%B8%2F</url>
    <content type="text"><![CDATA[有时候为了实现 Respnsive 或者一些其他的需求，我们就需要拿到当前屏幕的尺寸。那么在 Android 中该如何做到呢？请看如下代码：123456789fun getScreenSizeDp(activity: Activity): Pair&lt;Float, Float&gt; &#123; val display: Display = activity.windowManager.defaultDisplay val displayMetrics = DisplayMetrics() display.getMetrics(displayMetrics) val density = activity.resources.displayMetrics.density return Pair(displayMetrics.widthPixels / density, displayMetrics.heightPixels / density)&#125;首先，我们使用 Activity 对象来获取到 WindowManager 的 defaultDisplay。然后，我们构建一个 DisplayMetrics 对象，用来存储特定的尺寸数据。注意，我们只能获取到屏幕的像素大小，而不能获取到 Android 常用的 dp。所以，我们就要先拿到屏幕的像素密度，然后再用像素除以像素密度来得到屏幕的 dp 尺寸。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 官方 Navigation Drawer]]></title>
    <url>%2FAndroid%2FAndroid%20%E5%AE%98%E6%96%B9%20Navigation%20Drawer%2F</url>
    <content type="text"><![CDATA[&emsp;1. 概述&emsp;2. 添加依赖&emsp;3. 设计 layout/activity_main.xml&emsp;4. 构建 layout/drawer_header.xml&emsp;5. 定义 menu/drawer_item.xml&emsp;6. 显示汉堡包图标&emsp;7. 使状态栏透明&emsp;&emsp;7.1 去除 Actionbar&emsp;&emsp;7.2 v21 增加关于状态栏的属性&emsp;&emsp;7.3 设置 DrawerLayout 使用 fitsSystemWindow&emsp;&emsp;7.4 补充：动态改变 status bar 颜色&emsp;8. 总结1. 概述Navigation drawer 作为 Android Material Design 中主流的一种导航方式，当然受到 Google 的重视，所以，作为 MD 设计推出的实现部分，Android 更新了 support library 增加了关于 Navigation Drawer 的支持。下面就来看看如何进行 Navigation Drawer 的构建。2. 添加依赖官方的 Navigation Drawer 需要用到 DrawerLayout 和 NavigationView，它们都在 support design 包下。1compile 'com.android.support:design:24.2.1'这里不使用最新的 25.0.0 的原因在于，最新版在 UI Editor 渲染时存在 bug。Google 不愧是世界上最伟大的半成品公司。3. 设计 layout/activity_main.xml12345678910111213141516171819202122&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.v4.widget.DrawerLayout android:id="@+id/drawer_layout" xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:fitsSystemWindows="true" tools:context="com.wafer.toy.github_client.ui.activity.MainActivity"&gt; &lt;!-- Your main content --&gt; &lt;android.support.design.widget.NavigationView android:id="@+id/navigation_drawer" android:layout_width="wrap_content" android:layout_height="match_parent" android:layout_gravity="start" app:headerLayout="@layout/drawer_header" app:menu="@menu/drawer_item"/&gt;&lt;/android.support.v4.widget.DrawerLayout&gt;需要注意的是，DrawerLayout 是布局的根目录，同时要设置 fitsSystemWindows=&quot;true&quot;，否则，将会覆盖掉顶部状态栏。还有，注意要设置 NavigationView 的 layout_gravity=&quot;start&quot;，否则不会生效。4. 构建 layout/drawer_header.xml一般来说，Nav Drawer 都需要有一个 header 来存放用户头像等等有关用户账户的概览信息。所以我们还要定义一个 header 的布局，然后像上面一样，将其赋予 app:headerLayoutheader 的布局注意满足 Material Design 即可；布局样式和摆放不限。5. 定义 menu/drawer_item.xml是时候给我们的 Nav Drawer 加上一点内容了，通过在 menu/drawer_item.xml 中定义相应的组件即可。1234567891011121314151617181920212223242526272829303132&lt;menu xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;group android:checkableBehavior="single"&gt; &lt;item android:id="@+id/nav_home" android:icon="@drawable/ic_drawer_home" android:title="@string/nav_home" /&gt; &lt;item android:id="@+id/nav_about" android:icon="@drawable/ic_drawer_about" android:title="@string/nav_about" /&gt; &lt;item android:id="@+id/nav_settings" android:icon="@drawable/ic_drawer_settings" android:title="@string/nav_settings" /&gt; &lt;item android:id="@+id/navigation_subheader" android:title="@string/nav_sub_header"&gt; &lt;menu&gt; &lt;item android:id="@+id/navigation_sub_item_1" android:icon="@drawable/ic_drawer_about" android:title="@string/nav_sub_item_1" /&gt; &lt;item android:id="@+id/navigation_sub_item_2" android:icon="@drawable/ic_drawer_home" android:title="@string/nav_sub_item_2" /&gt; &lt;/menu&gt; &lt;/item&gt; &lt;/group&gt;&lt;/menu&gt;注意，项目的分界通过内嵌的 &lt;menu&gt; 来实现。需要注意的是，官方的 nav drawer 中的 item 没有 ripple，只有长按才能显示。最后我们再将这个 menu 赋到 NavgationView的 app:menu=&quot;@menu/drawer_item&quot;上6. 显示汉堡包图标Drawer 到这里就完全搭建好了，但是，没有汉堡包图标，用户就不知道我们的应有有个 Nav Drawer。所以，我们就需要给 toolbar 加上一个汉堡包图标来凸显 Nav Drawer 的存在。在这里，我们需要进入到 java 文件中进行修改了，由于我用的是 Kotlin，这里使用 Kotlin 来做演示。下面就是增加显示汉堡包的方法：1234567891011121314151617181920212223242526272829class MainActivity : BaseActivity() &#123; private val actionBarDrawerToggle: ActionBarDrawerToggle by lazy &#123; createActionBarDrawerToggle() &#125; override fun initView() &#123; initToolbar() initActionBarDrawerToggle() &#125; private fun initActionBarDrawerToggle() &#123; drawer_layout.addDrawerListener(actionBarDrawerToggle) actionBarDrawerToggle.syncState() &#125; private fun initToolbar() &#123; setSupportActionBar(toolbar) &#125; private fun createActionBarDrawerToggle(): ActionBarDrawerToggle &#123; return ActionBarDrawerToggle( this, drawer_layout, toolbar, R.string.open_drawer, R.string.close_drawer) &#125; override fun getLayoutRes(): Int &#123; return R.layout.activity_main &#125;&#125;首先，使用 DrawerLayout 对象和 toolbar 对象来构建一个 ActionBarDrawerToggle 对象；然后让 ActionBarDrawerToggle 成为 drawer_layout 的一个接口；最后设置 actionBarDrawerToggle.syncState() 即可。7. 使状态栏透明我们已经成功的构建出了一个 Navigation Drawer，但是，其显示出来的效果是这样的而官方的 MD 规范上，状态栏的效果是半透明的。所以，我们还要做一些额外的步骤来让我们的 Nav Drawer 更符合规范。7.1 去除 Actionbar这个步骤通常已经在初步搭建构架的时候就完成了。也就是说为 style.xml 增加如下两项：12&lt;item name="windowActionBar"&gt;false&lt;/item&gt;&lt;item name="windowNoTitle"&gt;true&lt;/item&gt;并且继承 Theme.AppCompact.Light.DarkActionBar7.2 v21 增加关于状态栏的属性在 value-21/style.xml 中，增加另外的两项：1234&lt;item name="windowActionBar"&gt;false&lt;/item&gt;&lt;item name="windowNoTitle"&gt;true&lt;/item&gt;&lt;item name="android:windowDrawsSystemBarBackgrounds"&gt;true&lt;/item&gt;&lt;item name="android:statusBarColor"&gt;@android:color/transparent&lt;/item&gt;7.3 设置 DrawerLayout 使用 fitsSystemWindow12345&lt;android.support.v4.widget.DrawerLayout ... android:fitsSystemWindows="true" app:insetForeground="@color/inset_color" &gt;OK，到这里就大功告成了！7.4 补充：动态改变 status bar 颜色如果你想动态改变状态栏颜色的话，也有相应的 Java 接口。123drawerLayout.setStatusBarBackgroundColor(ContextCompat.getColor(this, R.color.wierd_green));drawerLayout.setScrimColor(ContextCompat.getColor(this, R.color.wierd_transparent_orange));8. 总结这样构造出来的 Nav Drawer 和 MaterialDrawer 不同的一个地方在于，Nav Drawer 是在设计层面上进行修改，而 MaterialDrawer 是在代码层面上进行修改，侵入性不强，不过也较为麻烦。总的来说，如果要快速搭建，则选择 MaterialDrawer；但是要选择使用清真的写法，那么 Nav Drawer 则会更好。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Material Drawer Tutorial]]></title>
    <url>%2FAndroid%2FMaterailDrawer%2FMaterial%20Drawer%20Tutorial%2F</url>
    <content type="text"><![CDATA[添加依赖按照官方网站上的依赖添加即可。不过需要注意的是，必须等到 MavenCentral 同步了最新版本才能使用最新版本，否则请退回前一个版本。不然的话就要自己管理 Material Drawer 的依赖了。建立 Drawer最简单的版本1new DrawerBuilder().withActivity(this).build();带有汉堡包的版本12345Drawer drawer = new DrawerBuilder() .withActivity(this) .withToolbar(toolbar) .withActionbarToggle(true) .build();汉堡包会动的版本123456Drawer drawer = new DrawerBuilder() .withActivity(this) .withToolbar(toolbar) .withActionbarToggle(true) .withActionBarDrawerToggleAnimated(true) .build();带有 Header 的版本12345Drawer drawer = new DrawerBuilder() .withActivity(this) .withAccountHeader(accountHeader) // ... .build()调整宽度可以通过 DrawerBuilder 中的 withDrawerWidth*() 来调整宽度。其中 * 可以是 dp 也可以是 px1234567Drawer drawer = new DrawerBuilder() .withActivity(this) .withToolbar(toolbar) .withActionbarToggle(true) .withActionBarDrawerToggleAnimated(true) .withDrawerWidthDp(100) .build();建立 AccountHeader上面演示了如何建立带有 Header 的版本，但是，其中的 accountHeader 也是要我们自己建立和配置的。最简单的版本1234AccontHeader accountHeader = new AccountHeaderBuilder() .withActivity(this) .withHeaderBackground(R.drawable.header) .build()单个账户时关闭下拉菜单1builder.withSelectionListEnabledForSingleProfile(false)]]></content>
      <categories>
        <category>Android</category>
        <category>Materail Drawer</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>MaterailDrawer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Retrofit2 高级配置]]></title>
    <url>%2FAndroid%2FRetrofit%2FRetrofit2%20%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[1. 介绍有时候，retrofit 提供的基础功能不够我们使用，比如我们需要打网络日志、强制缓存，设置公有头等。此时，我们就需要对 OkHttp 的 client 进行定制，随后让 retrofit 使用我们定制的 client，从而实现我们的需求。2. 初始化操作为了定制我们自己的 Okhttp client，需要先获取 Okhttp.Builder 对象，通过对 builder 的不断处理，从而构建出我们所需要的 client。1OkHttpClient.Builder builder = new OkHttpClient.Builder();3. 设置缓存Retrofit 在很长的一段时间内，都没有内置的缓存处理框架，但是在 Retrofit2 强制使用 OkHttp 之后，这个问题就不再存在了。我一开始入门 retrofit 的时候也是花了很长时间在找如何建立缓存处理机制，实际上这是没有必要的。只要服务端提供正确的头信息，OkHttp 就能对应的实现缓存功能，而不需要其他设置。当然，如果需要强制使用缓存的话，可以通过增加拦截器的办法设置 Cache-Control 头，从而构建客户端自己的缓存处理。但是，只要服务端提供正确的头信息，这一步就可以省略，OkHttp 会自动进行缓存。不过，我们还是需要通过 builder 的 cache() 方法来设置缓存的路径123File cacheDir = getCacheDir();Cache cache = new Cache(cacheDir);builder.cache(cache);3.1 构建自己的缓存处理策略通过拦截器设置 Cache-Control 头，可以构建自己的缓存处理策略。12345678910111213141516171819202122232425262728293031File cacheFile = new File(DemoApplication.getContext().getExternalCacheDir(), "WuXiaolongCache");Cache cache = new Cache(cacheFile, 1024 * 1024 * 50);Interceptor cacheInterceptor = new Interceptor() &#123; @Override public Response intercept(Chain chain) throws IOException &#123; Request request = chain.request(); if (!AppUtils.networkIsAvailable(DemoApplication.getContext())) &#123; request = request.newBuilder() .cacheControl(CacheControl.FORCE_CACHE) .build(); &#125; Response response = chain.proceed(request); if (AppUtils.networkIsAvailable(DemoApplication.getContext())) &#123; int maxAge = 0; // 有网络时 设置缓存超时时间0个小时 response.newBuilder() .header("Cache-Control", "public, max-age=" + maxAge) .removeHeader("WuXiaolong")// 清除头信息，因为服务器如果不支持，会返回一些干扰信息，不清除下面无法生效 .build(); &#125; else &#123; // 无网络时，设置超时为4周 int maxStale = 60 * 60 * 24 * 28; response.newBuilder() .header("Cache-Control", "public, only-if-cached, max-stale=" + maxStale) .removeHeader("nyn") .build(); &#125; return response; &#125;&#125;;builder.cache(cache).addInterceptor(cacheInterceptor);4. 头信息有时候我们需要自己定义头信息；包括最基本的 Accept 和 Content-Type 信息；还有就是服务器要求验证的时候，我们需要提供 Authentication 信息。头信息当然可以在 ApiServices 接口中通过注解来指定；但是如果我们要所有的请求都带上头信息的话，使用注解来指定势必显得太过麻烦了。此时，我们使用 OkHttp 的 Interceptor 来进行。123456789101112131415Interceptor interceptor = new Interceptor() &#123; @Override public Response intercept(Chain chain) throws IOException &#123; // 直接使用旧请求新建 Request originalRequest = chain.request(); Request request = originalRequest.newBuilder() .header("Accept", "application/json"); .header("Content-Type", "application/json"); return chain.proceed(request); &#125;&#125;;builder.addInterceptor(interceptor);5. 日志众所周知，网络如果没有日志打印是无法调 bug 的。那么如何在使用 retrofit 时打印网络日志呢？同样，我们使用还是 OkHttp 的 Interceptor。但是，这次稍微有点不同，因为我们使用的是 retrofit 提供的官方打日志专用拦截器。注意，日志拦截器必须在第一位！5.1 添加依赖1compile 'com.squareup.okhttp3:logging-interceptor:3.4.1'5.2 配置拦截器1234HttpLoggingInterceptor logging = new HttpLoggingInterceptor();logging.setLevel(Level.BASIC);builder.addIntercetor(logging);6. 构建 client当配置完毕后，就可以用我们的 Builder 生成 client 了。1client = builder.build();7. 将 client 加入 retrofit builder最后，要让我们的 retrofit 使用 client 才能达到效果。1retrofitBuilder.client(client);]]></content>
      <categories>
        <category>Android</category>
        <category>Retrofit</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Retrofit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Consistent Hash]]></title>
    <url>%2FDHT%2FConsistent%20Hash%2F</url>
    <content type="text"><![CDATA[1. 概述大多数 DHT 使用稳定散列方法(consistent hash)来将关键值对应到节点。在使用稳定散列算法后，哈希表槽位数（大小）的改变平均只需要对 $K/n$ 个关键字重新映射，其中 $K$ 是关键字的数量， $n$ 是槽位数量。而不需要对整个哈希表进行重新映射。下面就来介绍几种主流的 DHT 稳定散列协议算法。2. Chord 算法Chord 在 2001 年由 MIT 提出，它不关心资源是如何存储的，只关心资源的快速取得。2.1 散列计算方法Chord 使用 SHA-1 作为散列计算函数，保证了散列值的非重复性。SHA-1 会产生一个 $2^{160}$ 的整数空间，每项为一个 160 bit 的大整数，它们首尾相连，形成 Chord 环。2.2 查找算法显然任何查找只需要绕 Chord 环一圈即可完成，此时时间复杂度为 $O(N)$，这对于一个上百万节点，而且节点随时处于动态变化中的 P2P 网络是不可承受的，所以 Chord 提出如下的非线性查找算法：每个节点维护一个 $m$ 个其他节点信息的查询表，（$m$ 为位数，Chord 中为 160，表格中的节点的 ID 间距为 $2^i$，这样实际形成了一个二分查找所需要的查找关系表查询时，查询节点将请求发送到与键值最接近的节点上，收到请求的节点如果存储了信息，则返回；否则，按照查询表将请求转发到与键值最接近的节点上；直到找到相应节点为止。由于节点的查询表采用的是二分查找式的分布方式，不难看出，查询过程实际上就是二分查找的过程。经过优化，Chord 查询所需的跳数由 $O(N)$ 下降为 $O(logN)$2.3 优点负载均衡所有的节点都以同样的几率负担系统负荷，从而可以避免某些节点负载过大。分布性所有的节点平等的完成同样的工作，所以 Chord 具有比较高的健壮性，能抵御 DoS 攻击可扩展性Chord 的系统开销按照 $O(logN)$ 增加，增加比例不大，因此它可以用于较大规模的系统可用性Chord 可以根据网络的变化更新查询表，及时恢复查找关系，使得查询可以可靠进行灵活性Chord 并未限制查询的内容结构，因此应用层可以灵活的将内容映射到键值空间，而不用受到协议的限制。3. CAN 算法CAN 是 2001 年由加州大学伯克利分校提出的。与 Chord 一样，也是 DHT 的一种实现形式。3.1 哈希算法在 CAN 中，每个节点自身的 ID 经过哈希后，能得到一个 d 维向量，所以整个 P2P 系统将被映射到一个 d 维的笛卡尔空间去。而 Chord 使用的 SHA-1 算法生成的结果是一维的。其中 d 为一个系统决定的常量3.2 查找算法CAN 的节点通过维护一个相邻节点表来进行非线性搜索。与 Chord 不同的是，CAN 不要求查询表的邻居节点保持 $2^i$ 的关系，而采用笛卡尔空间的相邻定义：在 $d$ 维笛卡尔空间中，2个节点的 $d$ 维坐标中有 $d-1$ 维是相等的，剩余的一维是相邻的节点称之为相邻节点。在查询的过程中，查询节点首先计算出被查询内容的键值 (d 维向量)，然后在节点列表中查找与之最近的相邻节点，向其发送查询请求；如果被查询节点包含资源，则返回；否则，被查询节点就根据查询表转发到相应最近节点，直到查询完毕为止。如果相邻节点表中没有可用的下一跳节点，则开始进行扩展环搜索（从最近的n个节点开始，层层转发直到找到目标或超出了跳数的上限为止），直到找到可用节点。经过CAN的优化后，查询需要的跳数由 $O (N)$ 减少到均值为$(d/4)(n1/d)$ 的随机制，考虑到 $d$ 为常数，这一值可以表示为$O(n1/ d)$。3.3 比较CAN 和 Chord 的主要区别在于查找算法不同。相比之下，在节点数量非常大时，CAN 的平均查询跳数要比 Chord 增加得更快。而且 CAN 查询过程中需要的运算量也要高于 Chord 。但 CAN 使用的 $d$ 为预先设置的常量，因此并不假设系统节点数量。但是在节点总数动态变化范围很大的系统中，CAN 的相邻节点表结构保持稳定，这在 P2P 这一时常在变化的网络系统中有很大优点。4. PastryPastry 于 2001 年位于英国剑桥的微软研究院和莱斯(Rice)大学提出。4.1 哈希算法在 Pastry 中，每个节点拥有一个 128 bit 的标识，为了保证 ID 的一致性，一般采用节点的 IP 地址进行哈希计算。Pastry 并没有规定应该使用何种哈希算法，而只规定了哈希键值为一维。（实际上则是使用了 128 bit 的整数空间）4.2 查找算法在 Pastry 中，每个节点拥有一个路由表 $R$，一个邻居节点表 $M$，和一个叶子节点表 $L$，它们一起构成了节点的状态表。路由表 $R$ 共有 $logBN$ 行，其中，$B = 2b$ 为系统参数，$N$ 为节点的总数。每行包括 $B - 1$ 个项，每个项记录了一个邻居节点的信息。叶子节点表存放的是在空间中与当前节点最近的 $|L|$ 个节点的信息；其中，一半节点的标识大于当前节点，另一半小于当前节点。一般取 $|L| = 2b$ 或者 $4b$。邻居节点存放着在 真实网络 中与当前节点最近的 $|M|$ 个相邻节点的信息。距离在这里的定义指的是由多种因素综合得到的转发开销。Pastry 并未提供距离节点的获取方法，而是由应用层来进行相邻节点的配置。具体的查找过程如下：首先，节点获取到被查询对象的 ID 后，检查 ID 是否在叶子节点的范围内如果不在，则从路由表中按照最长前缀优先原则查找一个转发节点如果不存在这样的节点，则从所有邻居节点集合（包括路由表中的子叶子表和邻居节点表）选择最近的节点进行消息转发，直到查询完毕为止。从过程中看，如果路由表不为空，则每步查找至少能夠增加一個前綴匹配数位，所以在路由表始终有效时，步数最多为 $logBN$4.3 比较Pastry的查找利用了成熟的最大掩码匹配算法，因此实现时可以利用很多现成的软件算法和硬件框架，可以获得很好的效率。与 Chord 和 CAN 相比，Pastry 引入了叶子节点和邻居节点集合的概念。在应用层能够及时准确地获得这两个集合的节点信息时，可以大大加快查找查找的速度，同时降低因查找引起的网络传输开销；不过在动态变化的 P2P 网络中如何理想地做到这一点有很大的难度。]]></content>
      <categories>
        <category>DHT</category>
      </categories>
      <tags>
        <tag>DHT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ToolBar]]></title>
    <url>%2FAndroid%2FToolBar%2F</url>
    <content type="text"><![CDATA[1. 使用1 定义风格在使用 Toolbar 之前，我们首先要对其风格进行一些调整。使用 AppTheme.Base 进行一些方便的全局设定5.0(API 21) 之后，Google 发表了 Material Design，由于和之前的风格有很大的不同， Google 采用了两个文件—— res/values/style.xml 和 res/values-v21/style.xml123456789101112131415161718192021&lt;resources&gt; &lt;!-- Base application theme. --&gt; &lt;style name="AppTheme" parent="AppTheme.Base"&gt; &lt;/style&gt; &lt;style name="AppTheme.Base" parent="Theme.AppCompat"&gt; &lt;!-- 取消 ActionBar，使用 ToolBar 来代替 ActionBar --&gt; &lt;item name="windowActionBar"&gt;false&lt;/item&gt; &lt;!-- 用这条语句来防止复制粘贴时把 ToolBar 挤下去的问题； 两句只能选一句来使用 --&gt; &lt;!-- 编译 API 低于 22 时，使用下面这条 --&gt; &lt;del&gt;&lt;item name="android:windowNoTitle"&gt;true&lt;/item&gt;&lt;/del&gt; &lt;!-- 使用 API Level 22 编译的话，使用下面这条 --&gt; &lt;item name="windowNoTitle"&gt;true&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt;1.2 添加组件到界面在 Activity 或 Fragment 的布局 xml 文件中添加 Toolbar 控件123456&lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/toolbar&quot; android:layout_height=&quot;?attr/actionBarSize&quot; android:layout_width=&quot;match_parent&quot; &gt;&lt;/android.support.v7.widget.Toolbar&gt;注意采用 support v7 包的 toolbar 否则只有 API 21 以后的版本才能使用，即不兼容 4.01.3 自定义颜色等其他属性在上述的两个 style 文件中设定你想要的 Toolbar 的各种属性。添加属性时，在 &lt;style&gt; 下添加一个 &lt;item&gt; 即可。例如：12345678910&lt;style name="AppTheme.Base" parent="Theme.AppCompat"&gt; &lt;item name="windowActionBar"&gt;false&lt;/item&gt; &lt;item name="android:windowNoTitle"&gt;true&lt;/item&gt; &lt;!-- Actionbar color --&gt; &lt;item name="colorPrimary"&gt;@color/accent_material_dark&lt;/item&gt; &lt;!--Status bar color--&gt; &lt;item name="colorPrimaryDark"&gt;@color/accent_material_light&lt;/item&gt; &lt;!--Window color--&gt; &lt;item name="android:windowBackground"&gt;@color/dim_foreground_material_dark&lt;/item&gt;&lt;/style&gt;可以设定的属性有：App bar : 即原来 ActionBar 的底色，通过添加 colorPrimary 属性即可。navigationBarColor : 此为导航栏底色，仅在 API 21 以上 才有效, 必须设置在 res/values-v21/style.xml 中windowBackground : 主视窗底色。1.4 设置控件一般来说 ，Toolbar 有以下控件有关的代码如下，文件为 Activity 的对应 .java 文件 MainAcitivity.java1234567891011121314Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);// App Logotoolbar.setLogo(R.drawable.ic_launcher);// Titletoolbar.setTitle("My Title");// Sub Titletoolbar.setSubtitle("Sub title");setSupportActionBar(toolbar);// Navigation Icon 要设定在 setSupoortActionBar 之后才有作用// 否則會出現 back buttontoolbar.setNavigationIcon(R.drawable.ab_android);菜单部分：先在相应的menu 文件设置MenuItem res/menu/menu_main.xml12345678910111213141516171819202122&lt;menu xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" tools:context=".MainActivity"&gt; &lt;item android:id="@+id/action_edit" android:title="@string/action_edit" android:orderInCategory="80" android:icon="@drawable/ab_edit" app:showAsAction="ifRoom" /&gt; &lt;item android:id="@+id/action_share" android:title="@string/action_edit" android:orderInCategory="90" android:icon="@drawable/ab_share" app:showAsAction="ifRoom" /&gt; &lt;item android:id="@+id/action_settings" android:title="@string/action_settings" android:orderInCategory="100" app:showAsAction="never"/&gt;&lt;/menu&gt;在 java 文件中设定 OnMenuItemClickListener1234567891011121314151617181920212223242526private Toolbar.OnMenuItemClickListener onMenuItemClick = new Toolbar.OnMenuItemClickListener() &#123; @Override public boolean onMenuItemClick(MenuItem menuItem) &#123; String msg = ""; switch (menuItem.getItemId()) &#123; case R.id.action_edit: msg += "Click edit"; break; case R.id.action_share: msg += "Click share"; break; case R.id.action_settings: msg += "Click settings"; break; &#125; if(!msg.equals("")) &#123; Toast.makeText(MainActivity.this, msg, Toast.LENGTH_SHORT).show(); &#125; return true; &#125;&#125;;// 将 Listener 传给设置方法// 其实也可以使用匿名类构造toolbar.setOnMenuItemClickListener(onMenuItemClick)需要注意的是，setOnMenuItemClickListener() 需要在 setActionBar() 或 setSupportActionBar() 之后才能生效2. 动态加载这里所指的是 在使用 Fragment 时，由于不同 Fragment 可能需要不同的 ActionBar 标题或者其他组件，由此产生的动态加载问题。2.1 动态更改标题当 Title 需要根据 Fragment 的内容进行动态加载，不要直接使用 Toolbar 的 setTitle()，而应该使用 getActionBar() 来进行标题更改。由于 Android Studio 会自动产生 Warning，认为 getActionBar() 有可能返回一个空值，可以使用 assert 来进行断言，说明其不会返回 null1234// 此处断言用于取消 Warnning，// 但必须保证已经 setActionBar(toolbar);assert getActionBar() != null;getActionBar().setTitle("需要的标题");2.2 动态加载 MenuItem需要动态加载 MenuItem 时，应该在各个 Fragment 重载 onCreateOptionsMenu() 方法。12345@Overridepublic void onCreateOptionsMenu(Menu menu, MenuInflater inflater) &#123; inflater.inflate(R.menu.pictrue_list, menu); super.onCreateOptionsMenu(menu,inflater);&#125;同时，需要在 Fragment 的 onCreate() 方法中添加 setHasOptionMenu(true)，指明 Fragment 应显示菜单并对菜单进行响应。123456@Overridepublic void onCreate(Bundle savedInstanceState) &#123; // TODO Auto-generated method stub super.onCreate(savedInstanceState); setHasOptionsMenu(true); // 必须添加，否则无法显示 menu&#125;需要注意的是， Fragment 会自动继承 Activity 已经 inflate 的 MenuItem，所以如果 Fragment 需要一个全新的 MenuItem 那就最好重新 inflate 新的 xml。否则，MenuItem 将会重复出现，而且其点击事件也会同时在 Activity 和 Fragment 中得到响应]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin lateinit vs lazy]]></title>
    <url>%2FKotlin%2FKotlin%20lateinit%20vs%20lazy%2F</url>
    <content type="text"><![CDATA[lateinit 和 lazy 是 Kotlin 中的两种不同的延迟初始化技术。在 Kotlin 使用中，很可能搞不清楚它们的使用场景和方法。下面就来做一个理清：lateinit 只用于 var，而 lazy 只用于 vallateinit 和 lazy 都不能有 自定义的 getter 和 setter，但是可以对 getter 和 setter 进行可见符修饰lazy 应用于单例模式(if-null-then-init-else-return)，而且当且仅当变量被第一次调用的时候，委托方法才会执行。lateinit 则用于只能生命周期流程中进行获取或者初始化的变量，比如 Android 的 onCreate()当单例对象需要使用外界参数来进行构造时，内部的该参数对应的属性应使用 lateinit比如说网络 ApiManager 需要 context 来进行获取缓存的操作；那么，ApiManager 中的 context 属性就必须使用 lateinit这是因为，lazy 使用委托方法来进行变量初始化，而委托方法不能从外界获取参数，但是 lateinit 可以通过一个 init(context: Context) 来获取到相应的外界参数来初始化属性。]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Material Design 高度和阴影]]></title>
    <url>%2FMaterialDesign%2FMaterial%20Design%20%E9%AB%98%E5%BA%A6%E5%92%8C%E9%98%B4%E5%BD%B1%2F</url>
    <content type="text"><![CDATA[1. 概述在 Materail Design 中，物体的行为和真实世界中很相似。在真实世界中，物体堆放和叠加在一起，但是不能穿过彼此，并且会投射出阴影。Material Design 的实体与之类似，也需要投射阴影。Material Design 实体具有以下三个高度属性：高度：指的是一个物体 表面 到另一物体表面的距离。物体的高度决定了它的阴影投射情况默认高度：任何的实体都具有默认高度(Resting Elevation)，在一个平台中，组件的默认高度是 一致的，但是不同的 平台 或者 设备 可能具有不同的默认高度。动态的高度偏移：这个属性指的是实体在 响应事件时 相对于 默认高度 的偏移量。2. 高度（Android）2.1 说明高度的表示单位也是 dp，与 x 和 y 坐标一样。需要注意的是，由于实体也具有厚度(1 dp)，所以高度指的是从一个实体表面到另一个实体表面的距离。同时，一个子对象的高度，指的是其 相对于父对象的距离。2.2 默认高度默认高度是不会变化的，当一个组件的高度变化时，它应该尽快的恢复默认高度。各个 Android 组件的默认高度可以到官网查看。对于桌面环境来说，为了容纳鼠标和其他非触摸事件，它的组件的默认高度要比 Android 组件的默认高度低 2 dp。组件的高度在不同的 App 之间应该相同，但是在不同设备之间不同。比如说电视和 PC 就比手机具有更深的层次。2.3 感应高度和动态的高度偏移一些组件可能拥有感应高度，也就是说它会根据用户的输入（比如说触摸事件）来改变自己的高度。一般来说，触摸，或者按压一个组件会使它的高度变高。这些高度变化是通过 动态高度偏移 实现的。动态高度偏移是相对于默认高度来说，组件需要移动的高度量。动态高度偏移保证了在移动应用中组件高度偏移量的一致性。组件接受到触摸事件后，都能有一个不变的高度偏移量。一旦触摸事件完毕，或者被取消，那么组件就必须恢复到其默认高度。2.4 避免高度冲突拥有感应高度的组件可能会导致其他组件随着其高度变化而变化，这是因为 组件不可以相互穿透。避免冲突的方法有很多：在某一元素水平上，元素可以在它们产生冲突前提前移动或者消失。比如说一个 FAB 就可以在用户选择一个卡片的时候消失或者移出屏幕。在布局水平上，你需要通过设计你的 App 布局来减少冲突的可能性。比如说将 FAB 置于卡片列表的一端来避免 FAB 与卡片出现的冲突。2.5 组件高度比较图中只有组件的高度是正确的，其他的属性(比如面积)不一定正确![whatismaterial_3d_elevation3](https://ooo.0o0.ooo/2016/10/25/580f985cb48ba.png)一个卡片，App Bar 和 FAB 的例子![whatismaterial_3d_elevation4](https://ooo.0o0.ooo/2016/10/25/580f989bbcbd6.png)另一个 Navigation Drawer 的例子 ## 3. 阴影 阴影给物体的高度和其运动的方向给予了一个重要的视觉线索。 它们也是唯一的用于区分不同平面的视觉线索。 一个物体的阴影由其高度决定。不可取，没有阴影，无法区分 FAB 和背景不可取，过于脆弱的阴影表示 FAB 和蓝色背景是在同一个平面的可取，较大且柔软的阴影表示 FAB 的高度比蓝色背景要高。当出现触摸事件时，阴影可以提供一个物体运动方向的视觉线索，以体现物体和平面之间的相对距离。不可取，没有阴影无法指示物体是增大体积还是增加高度可取，阴影变得更大，更柔软表明了物体的高度在增加；反之，阴影变得更小，更脆弱表明物体的高度在减少可取，阴影不改变，表明物体的高度没有增加，而只是体积增大了。3.1 组件参考高度下面列出一些组件的参考高度，它们应当作为高度的典范来使用。3.1.1 App Bar4dp3.1.2 Raised Button默认高度： 2dp按下高度： 8dp3.1.3 Floating Action Button(FAB)默认高度： 6dp按下高度： 12dp3.1.4 Card按下高度： 2dp抬起高度： 8dp3.1.5 Menus and sub menus菜单： 8dp每个子菜单相对于父菜单增加 1dp3.1.6 Dialogs24dp3.1.7 Nav Drawer and Right Drawer16dp3.1.8 Modal Button Sheet16dp3.1.9 Refresh indecator3dp3.1.10 Quick entry/Search bar默认高度： 2dp滚动高度： 3dp3.1.11 Snackbar6dp3.1.12 Switch1dp4. 对象间关系对象和对象集合间的关系和组织结构就决定了，当某个对象移动时，其他的对象是否随其移动。对象可以独立的移动，也可以被其他上层对象的移动而随其移动4.1 对象的层次结构所有的对象都在一个 父子关系 的组织结构中。由于 Android 采用 XML 标签结构一个对象可以是系统的子对象，也可以是另一个对象的子对象。父子关系的说明：任何一个对象都有一个父对象任何一个对象可以拥有 0 或多个子对象子对象从父对象中继承可变属性，例如位置，旋转角度，放大倍数，和高度同一层级的两个对象称为兄弟对象如图，卡片上的按钮随着内容的滚动而滚动4.2 例外父对象是根对象的对象，例如一些主要的 UI 组件，它们的移动是独立于其他对象的。比如说，一个 FAB 是不会随着内容的移动而滚动的。其他的这种对象还包括：Nav drawerApp barDialogs如图，FAB 不随着内容的滚动而滚动4.3 交互对象和其他对象的交互动作由它所在的结构位置决定。例如：子对象具有一个能与父对象区分的最小 z 轴高度。其他的对象不能插入到这个父对象和子对象之间滚动的卡片是兄弟对象，所以它们会一起移动。而控制它们移动的就是它们的父对象。4.4 高度对象的高度取决于它的内容的结构还有它是否能独立于其他对象移动。]]></content>
      <categories>
        <category>MaterialDesign</category>
      </categories>
      <tags>
        <tag>MaterialDesign</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Retrofit 离线缓存]]></title>
    <url>%2FAndroid%2FRetrofit%2FRetrofit%20%E7%A6%BB%E7%BA%BF%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[1. 概述Retrofit2 自从默认使用 OkHttp 库之后，自带了缓存功能；但是，这个缓存功能是在线缓存，也就是向服务器发起请求，服务器返回 304，而不是直接从缓存读取而不发起网络请求。这样，当我们的应用处在离线状态时候，就无法读取缓存中的内容了。这对于用户体验来说显然是不好的，所以这篇文章就介绍一下如何配置 Retrofit 和 OkHttp 来进行离线缓存2. 设置缓存路径为了使用 OkHttp 的缓存，我们就必须设置相应的缓存路径。1234File cacheDir = getCacheDir();Cache cache = new Cache(cacheDir);client = builder.cache(cacheDir).build();3. 配置拦截器OkHttp 可以通过拦截器来实现对请求(Request)和响应(Response)的魔改。我们实现离线缓存的方式，就是采用这个拦截器对响应进行魔改。3.1 通过 CacheControl 配置缓存首先，我们要对我们的缓存策略进行配置，最好的当然就是使用 OkHttp 自带的 CacheControl 进行配置。1234CacheControl.Builder cacheBuilder = new CacheControl.Builder();cacheBuilder.maxAge(0, TimeUnit.SECONDS);//这个是控制缓存的最大生命时间cacheBuilder.maxStale(365,TimeUnit.DAYS);//这个是控制缓存的过时时间CacheControl cacheControl = cacheBuilder.build();3.2 建立拦截器和自定义 Response 缓存不同，对于离线缓存，我们对 Request 进行处理；当离线时，给 Request 赋予一个缓存控制对象，然后直接 proceed 即可。12345678910Request request = chain.request();// 离线状态下才进行自定义缓存控制if(!StateUtils.isNetworkAvailable(MyApp.mContext))&#123; request = request.newBuilder() .cacheControl(cacheControl) .build();&#125;Response response = chain.proceed(request);]]></content>
      <categories>
        <category>Android</category>
        <category>Retrofit</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Retrofit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工作总结报告]]></title>
    <url>%2FProjects%2FBigInovation%2F%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[负责了地图 UI 界面的构建和与整个应用的集成，以及应用的网络模块、和后端交互的逻辑，还有整个项目工程的代码管理。地图的 UI 界面使用了 GitHub 上的一个耦合度较低的表示层地图视图库，将其进行一定程度的优化后，应用到本项目中，之所以选择它是因为目前的优秀地图显示层均与对应的地图框架高度耦合，不方便二次开发和 Bug 修复。应用网络模块采用了目前 Android 上最为优秀的 Retrofit 2 作为网络加载库，通过完全 RESTful 的网络调用和后端服务器进行交互，与后端的 Django 框架完美契合。整个项目的工程代码使用了全球最大的代码托管网站 GitHub ，以私有仓库的方式将代码托管在其服务器上。采用 Git 作为代码版本管理工具，并采用 GitHub 上最流行的 Pull Request 工作流，保证了成员即使采用远程工作模式，也可以无障碍的与组员沟通；同时，将主分支设置为保护分支，要求代码经过审查后方可合并，确保了代码的可用性，正确性和可维护性。]]></content>
      <categories>
        <category>工程</category>
        <category>大创</category>
      </categories>
      <tags>
        <tag>工程</tag>
        <tag>大创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Create Asserts Folder]]></title>
    <url>%2FAndroid%2FCreate%20Asserts%20Folder%2F</url>
    <content type="text"><![CDATA[概述Android 如何创建 Asserts 文件夹，用来存储一些需要内置在 app 里的大资源呢？步骤如下：1. 右边栏移动到 Android 视图2. 在 app 处右键New -&gt; Folder -&gt; Asserts Folder3. 按照对话框提示进行即可]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 多个 icon 问题]]></title>
    <url>%2FAndroid%2FAndroid%20%E5%A4%9A%E4%B8%AA%20icon%20%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[最近在开发中遇到的 Android App 安装后，同一个 app 居然在应用列表里出现了两个或者以上的图标，这是怎么回事呢？原来，Android 只要指定了 action.MAIN 的 Activity 就会显示一个图标，而且图标的名字和 Activity 的 android:label 相同。所以，解决办法就是只保留一个 action.MAIN。同时，如果引入了其他 module，也要检查那个 module 的 manifest；保证整个工程就只有一个 action.MAIN]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Material Design 实体属性]]></title>
    <url>%2FMaterialDesign%2FMaterial%20Design%20%E5%AE%9E%E4%BD%93%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[概述Material 具有某些不可变的特点和固有的行为模式了解关于 Material 的特点能有助于你更好的利用 Material，以期与 Material Design 具有一致性。Material 的特点固体占用空间中唯一的位置不可穿透的形状可改变只在平面方向上改变大小不可弯折可以融入其他 Material可以分割，分裂，和恢复可以被创建和摧毁可以在任何轴进行移动物理特性厚度实体具有可变化的长宽尺寸，和 1 dp 的厚度。Do，材料的长和宽可以变化Don't，材料的厚度为 1 dp投射阴影投射阴影是用来表示两个实体之间的相对距离。Do，材料的阴影是实体间距离的体现Don't，阴影不能用来描边内容内容能以任意的形状和颜色在实体上显示，内容不给实体增加厚度。Do，内容能以任意的形状和颜色来展示内容的行为可以独立于实体，但是被实体的大小所限制。Do，内容被实体大小所限制点击事件实体是固体。点击事件不能穿过实体。Do, 点击事件只能影响前台实体Don't，点击事件不能穿过实体]]></content>
      <categories>
        <category>MaterialDesign</category>
      </categories>
      <tags>
        <tag>MaterialDesign</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Volley 构建自定义请求]]></title>
    <url>%2FAndroid%2FVolley%2FAndroid%20Volley%20%E6%9E%84%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[1. 介绍Volley 提供了基本的 StringRequest，JsonObjectRequest 和 JsonArrayRequest 来满足字符串请求和 JSON 请求。但是有时候这可能还不能满足我们对网络通信的需求。比如说使用 Gson 库来自动的对响应的 JSON 进行解析等。此时就需要构建自定义的 Volley 请求。2. 基本步骤2.1 继承 Request&lt;T&gt; 类自定义请求首先是通过继承基本的 Request&lt;T&gt; 类来实现的。123public class GsonRequst&lt;T&gt; extends Requst&lt;T&gt; &#123; // class body&#125;2.2 实现构造器然后，我们要实现构造器满足基本的 Request 的构造方法。12345678910public GsonRequest(String url, Class&lt;T&gt; clazz, Response.Listener&lt;T&gt; listener, Response.ErrorListener errorListener) &#123; // Fulfill the super constructor super(Method.GET, url, errorListener); this.clazz = clazz; this.listener = listenr;&#125;当然，这里作为一个 GsonRequest，仅仅要求满足父类的构造参数是不够的，我们还要指定 Gson 转换的 class 类型，以及必要的 Response Listener2.3 重载必要方法为了实现 GsonRequest 我们要重载必要的方法parseNetworkResponse() 和 deliverNetworkResponse()重载 parseNetworkResponse(Response response)顾名思义，这个方法是用来解析网络的回复的，对于我们的 GsonRequest，我们首先要将网络的回复（二进制流）转换成 JSON，然后由 Gson 解析成相应的类。123456789101112@Overrideprotected Response&lt;T&gt; parseNetworkResponse( NetworkResponse response) &#123; try &#123; String json = new String(response.data, HttpHeaderParser.parseCharset(response.headers)); return Response.success(gson.fromJson(json, clazz), HttpHeaderParser.parseCacheHeaders(response)); &#125; // handle errors ...&#125;重载 deliverNetworkResponse(T response)这个方法是将 parseNetworkResponse() 的解析结果发送给我们的 Response listener 的。所以，代码较为简单，直接把解析出来的 response 传给 listener 的回调方法即可。1234@Overrideprotected void deliverResponse(T response) &#123; listener.onResponse(response);&#125;2.4 完整示例完整的可用代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class GsonRequest&lt;T&gt; extends Request&lt;T&gt; &#123; private final Gson gson = new Gson(); private final Class&lt;T&gt; clazz; private final Map&lt;String, String&gt; headers; private final Listener&lt;T&gt; listener; /** * Make a GET request and return a parsed object from JSON. * * @param url URL of the request to make * @param clazz Relevant class object, for Gson&apos;s reflection * @param headers Map of request headers */ public GsonRequest(String url, Class&lt;T&gt; clazz, Map&lt;String, String&gt; headers, Listener&lt;T&gt; listener, ErrorListener errorListener) &#123; super(Method.GET, url, errorListener); this.clazz = clazz; this.headers = headers; this.listener = listener; &#125; @Override public Map&lt;String, String&gt; getHeaders() throws AuthFailureError &#123; return headers != null ? headers : super.getHeaders(); &#125; @Override protected void deliverResponse(T response) &#123; listener.onResponse(response); &#125; @Override protected Response&lt;T&gt; parseNetworkResponse(NetworkResponse response) &#123; try &#123; String json = new String( response.data, HttpHeaderParser.parseCharset(response.headers)); return Response.success( gson.fromJson(json, clazz), HttpHeaderParser.parseCacheHeaders(response)); &#125; catch (UnsupportedEncodingException e) &#123; return Response.error(new ParseError(e)); &#125; catch (JsonSyntaxException e) &#123; return Response.error(new ParseError(e)); &#125; &#125;&#125;3. 关于 POST 方法以上的例子是基于 GET 方法来介绍的，如果使用 POST 方法则略有不同。仍然以 GsonRequest 举例子：首先，我们需要接受一个新的参数用来承接 POST 的实例对象使用 Gson 将对象序列化成 JSON 字符串将 JSON 字符串转换成 Params 或者直接 POST JSON 字符串此时，我们需要重载几个新方法。3.1 重载 getParams() 或 getBody() 方法getParams() 方法实质上会在 getBody() 方法中被调用，如果你只需要 POST 简单的 Params 形式(key=val&amp;another_key=another_val)，那么重载 getParams() 方法即可。但如果普通的 Params 形式无法满足需要，那么就需要重载 getBody() 方法，其返回的内容会成为 HTTP POST 报文中的 Body。注意：两个方法只能选择重载其中一个3.1.1 重载 getParams() 方法一般的 POST 使用，我们重载此方法即可，该方法返回类型是 Map&lt;Sting, String&gt;。在 GsonRequest 中，我们只需要使用 Gson 将需要 POST 的对象序列化成 JSON，随后将 JSON 反序列化成 Map即可。即 Object -&gt; JSON -&gt; Map&lt;String, String&gt;123456789@Override Map&lt;String, String&gt; getParmas() &#123; String json = gson.toJson(mPostObject); // Use TypeToken to avoid the unchecked cast // and the floating number converted from primitive integer return gson.fromJson( json, new TypeToken&lt;Map&lt;String, String&gt;&gt;()&#123;&#125;.getType());&#125;3.1.2 重载 getBody() 方法如果基本的 getParams() 方法不能满足需要，那么我们可以直接重载 getBody() 方法来实现对 HTTP body 的高度定制。在 GsonRequest 中，假如碰到有时需要 POST 带 List 或者数组类型的对象，由于 List 不能被 cast 成 Map&lt;String, String&gt; 的类型，那么就不能使用 getParams() 方法。应该要使用 getBody() 方法。注意 getBody() 返回的是 byte[] 类型，我们需要使用 String 的 getBytes() 方法来将 JSON 转换成二进制流。1234567891011121314151617@Overridepublic byte[] getBody() throws AuthFailureError &#123; if (mPostObject != null) &#123; String postJson = gson.toJson(mPostObject); try &#123; return postJson.getBytes(PROTOCOL_CHARSET); &#125; catch (UnsupportedEncodingException e) &#123; VolleyLog.wtf( &quot;Unsupported Encoding while trying to get the byte of %s using %s&quot;, postJson, PROTOCOL_CHARSET); &#125; &#125; return null;&#125;3.2 重载 getBodyContentType() 方法为了我们的 POST body 能被成功解析，我们还需要重载 getBodyContentType() 方法来指定我们 POST 的数据的类型1234@Overridepublic String getBodyContentType() &#123; return PROTOCOL_CONTENT_TYPE;&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>Volley</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Volley</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin 操作符重载]]></title>
    <url>%2FKotlin%2FKotlin%20%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[&emsp;1. 概述&emsp;2. 公约&emsp;&emsp;2.1 一元操作符&emsp;&emsp;2.2 二元操作符&emsp;&emsp;&emsp;2.2.1 数学运算与范围&emsp;&emsp;&emsp;2.2.2 in 操作符&emsp;&emsp;&emsp;2.2.3 方括号操作符&emsp;&emsp;&emsp;2.2.4 圆括号操作符&emsp;&emsp;&emsp;2.2.5 复合赋值操作&emsp;&emsp;&emsp;2.2.6 相等性检查&emsp;&emsp;&emsp;2.2.7 比较运算符&emsp;3. 中缀函数1. 概述Kotlin 中的操作符都是由函数实现的，包括成员函数、扩展函数和中缀函数。重载一个操作符，我们只要给对应的类提供一个成员函数或者扩展函数即可。重载操作符的函数必须使用 operator 进行标识。遗憾的是，Kotlin 不支持自定义操作符，只能对现有的操作符进行重载。2. 公约这里阐述的是 Kotlin 中各种操作符的对应函数和重载约定。没有在以下列出的操作符，不允许被重载。关于 Kotlin 中所有的操作符，请查看这个链接2.1 一元操作符ExpressionTranslated to+aa.unaryPlus()-aa.unaryMinus()!aa.not()当编译时，上面的操作符会被替换为对应的函数，步骤如下:确定 a 的类型，比如 T在 T 中寻找方法，比如说 unaryPlus()当寻找不到方法时，报错如果 unaryPlus() 返回类型 R，那么 +a 的类型为 R注意，所有的操作符都会对基本类型进行优化，以减少函数调用的开支。ExpressionTranslated toa++a.inc() + see belowa--a.dec() + see below这些操作符是用来改变它们的接收者的。注意，所谓的改变接收者指的是改变其内部的值，而不是改变其对象。事实上，应该创建并返回一个拥有新值的对象，而不是对对象本身进行操作。编译器会对这样的操作符采取以下步骤的操作：确定 a 的类型 T在 a 中寻找 inc() 方法如果 inc() 返回类型为 R，那么它必须是 T 的子类对于后缀操作符的计算过程如下(a++)：将 a 的初始值存储在临时对象 a0 中将 a.inc() 的结果赋予 a返回 a0a-- 与之相同对于前缀操作符的计算过程如下(++a)：将 a.inc() 的结果赋予 a返回 a2.2 二元操作符2.2.1 数学运算与范围ExpressionTranslated toa + ba.plus(b)a - ba.minus(b)a * ba.times(b)a / ba.div(b)a % ba.mod(b)a..ba.rangeTo(b)这些操作符在执行时会自动翻译成相应的函数执行。2.2.2 in 操作符ExpressionTranslated toa in bb.contains(a)a !in b!b.contains(a)对于这些方法，执行的步骤一样，但是只不过把调用关系颠倒了过来。2.2.3 方括号操作符SymbolTranslated toa[i]a.get(i)a[i, j]a.get(i, j)a[i_1, ..., i_n]a.get(i_1, ..., i_n)a[i] = ba.set(i, b)a[i, j] = ba.set(i, j, b)a[i_1, ..., i_n] = ba.set(i_1, ..., i_n, b)方括号操作符的对应方法为 get()，根据参数个数来调用不同的 get() 方法，如果有赋值操作则调用 set() 方法。2.2.4 圆括号操作符SymbolTranslated toa()a.invoke()a(i)a.invoke(i)a(i, j)a.invoke(i, j)a(i_1, ..., i_n)a.invoke(i_1, ..., i_n)圆括号操作符会根据参数调用相应的 invoke() 方法2.2.5 复合赋值操作ExpressionTranslated toa += ba.plusAssign(b)a -= ba.minusAssign(b)a *= ba.timesAssign(b)a /= ba.divAssign(b)a %= ba.modAssign(b)对于复合赋值操作，编译器做以下处理(a += b)：如果右边一列中的函数在类中存在，那么：检查对应的二元函数是否存在，比如 plus() 对应 plusAssign()，如果存在，报错检查函数的返回值是否为 Unit，如果不是，报错上面检查通过后，生成相应代码如果右边一列中的函数在类中不存在，那么尝试生成 a = a + b，包括类型检查（a + b 的返回值必须是 A 或其子类型）不允许 plus() 和 plusAssign() 同时存在的原因：这是因为编译器会默认转为 a = a + b 进行处理，所以当存在 plus() 时，就没必要编写重复代码。需要注意的是，复合赋值是赋值语句的一种，而在 Kotlin 中，赋值不是一个表达式这主要是为了避免赋值语句和单行函数的冲突1fun attachView(view: View) = this.view = view上面的代码出现了二义性。但是在 Java 中，赋值是一种表达式，也就是说 Java 允许1234int a = 1, b = 1, c = 1;if ((a = b) != c) &#123; ....&#125;而 Kotlin 只能将赋值语句移到括号外。这个链接中还有更多方法2.2.6 相等性检查ExpressionTranslated toa == ba?.equals(b) ?: b === nulla != b!(a?.equals(b) ?: b === null)相等性检查只需要提供 equals() 方法即可。注意：引用相等性检查 === 和 !== 是不允许重载的。相等性检查被转换成如此复杂的表达式是为了筛选 null 值，而且保证 null == null 返回 true2.2.7 比较运算符SymbolTranslated toa &gt; ba.compareTo(b) &gt; 0a &lt; ba.compareTo(b) &lt; 0a &gt;= ba.compareTo(b) &gt;= 0a &lt;= ba.compareTo(b) &lt;= 0所有的比较运算符都会被转换成 compareTo() 方法；compareTo() 方法必须返回一个 Int 值。3. 中缀函数除此之外，我们还可以通过定义中缀函数来定义新的“运算符”比如数字类型的位运算就是通过中缀函数实现的。]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[局域网内网服务器简易开启方法]]></title>
    <url>%2F%E5%B1%80%E5%9F%9F%E7%BD%91%E5%86%85%E7%BD%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%80%E6%98%93%E5%BC%80%E5%90%AF%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1. Windows12# python3python -m http.serverWindows 虽说自带局域网功能，但需要配置一大堆东西甚是麻烦。装上 python，直接一条指令搞定。2. Unix-like*.nix 系统的同学应该很熟悉了，使用 darkhttpd 命令行工具就可以开启本地服务器。当然也可以使用 python 的方法。]]></content>
      <tags>
        <tag>LocalNetwork</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin Android Getting Started]]></title>
    <url>%2FKotlin%2FKotlin%20Android%20Getting%20Started%2F</url>
    <content type="text"><![CDATA[1. 概述由于 Android Studio 基于 IntelliJ IDEA 开发，所以很容易在 Android Studio 上使用 Kotlin 开发 Android。2. 创建工程这步和普通的 Android 创建工程没有什么区别。创建完毕后，你一般会拥有一个由 AS 创建的 Java Activity 类。3. 将 Java 代码转换成 Kotlin 代码IDEA 内建了代码转换功能，只需要通过 Find Action(cmd + shift + a) 即可找到 Convert Java File to Kotlin File经过转换之后，我们就能拥有一个使用 Kotlin 来编写的 Activity 类了。4. 在工程中配置 Kotlin由于 Kotlin 是一个外部库，所以我们需要对工程进行一些配置。当然，Android Studio 内置了自动配置方法，只需要在 Find Action 中搜索 Configure Kotlin in Project 即可。接下来会弹出一个对话框，选择最新的 Kotlin 版本即可。最后，我们只需要同步一下 Gradle 即可。5. 剩下的工作由于 Kotlin 最终还是会被编译成字节码，所以剩下的 UI 开发和 APK 构建与使用 Java 语言时并没有任何区别。尽情享受 Kotlin 所带来的便利吧！]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OS X Using ShimakazeGo + Poi to play kancolle]]></title>
    <url>%2FKancolle%2FOS%20X%20Using%20ShimakazeGo%20%2B%20Poi%20to%20play%20kancolle%2F</url>
    <content type="text"><![CDATA[1. IntroThis is the instruction of how to bulid a kancolle playing enviroment in Mac OS X.My current OS X version is 10.11Necessary tools: Automator2. Install ShimakazeGoShimakazeGo is a proxy for playing Kancolle. Because DMM has banned the IP addresses of foreigners, you need to use a proxy to connect to the game site.Here is the ShimakazeGo official site. There is a instruction how to install it on Mac OS X3. Pack ShimakazeGo as a OS X APPThis section is pretty important.The ShimakazeGo developer offer a shell scipt to start the program.Therefore, it’s very easy to convert it to a application by using Automator, a convient and easy-to-use app buliding tool on Mac OS X.Open Automator, choose the Application and serch for Run Apple Script at the search bar.And then paste this script inside the input frame.1234on run do shell script &quot;/path/to/the/ShimakazeGo/run_mac &gt; /dev/null 2&gt;&amp;1 &amp;&quot; quitend runSave the App, copy to your /Application and close the Automator, using a text editor, such as vim to open the run_mac script and delete the last two lineThe script will appear like this1234567891011#!/bin/bashexport LANG=&quot;zh-CN.UTF-8&quot;export LC_ALL=&quot;zh-CN.UTF-8&quot;defaults write mono NSAppSleepDisabled -bool YESMONO_LIB=/Library/Frameworks/Mono.framework/Versions/Current/bin/monodir=$(dirname $&#123;BASH_SOURCE:-$0&#125;)$MONO_LIB $dir/ShimakazeGo.exe &gt; /dev/null &amp;And done. Start the app and you will see the ShimakazeGo window.4. Supplement: Change App IconThe app that we generate will come with a default Automator icon like a robot.Some people may dislike it and want to changge to another icon.It is very easy, just follow these instructions:Open the App info window(cmd + i)Open the icon img you want to replace with.Select the whole img(cmd + a) and copy(cmd + c)Click the icon inside the App info window, and paste(cmd + v)Done!5. Install PoiPoi is a Scalable KanColle browser and tool.Due to using the web techology, it is totally cross-platformHere is the GitHub repo]]></content>
      <categories>
        <category>Kancolle</category>
      </categories>
      <tags>
        <tag>Kancolle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSH clone GitHub Gist]]></title>
    <url>%2FGitHub%2FSSH%20clone%20GitHub%20Gist%2F</url>
    <content type="text"><![CDATA[Tags: GitHubGitHub 会默认拒绝其 默认给出的 Gist SSH 链接。使用如下格式的链接来进行 Gist SSH clone。1git clone git@github.com:gist_id.git]]></content>
      <categories>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本部宿舍各物品尺寸]]></title>
    <url>%2FDecoration%2F%E6%9C%AC%E9%83%A8%E5%AE%BF%E8%88%8D%E5%90%84%E7%89%A9%E5%93%81%E5%B0%BA%E5%AF%B8%2F</url>
    <content type="text"><![CDATA[说明学九楼未经特别说明单位均为厘米立体物品顺序为 长 $\times$ 宽 $\times$ 高，容器物品为 高 $\times$ 宽 $\times$ 厚度床193 $\times$ 92.3 $\times$ 112（下铺）/ 141（上铺）衣柜外：177.2 $\times$ 47.5 （中线为止） $\times$ 54.7内：144.4 $\times$ 44.2 $\times$ 52桌子70.5 $\times$ 63 $\times$ 77书架 18，电脑空间 47.1床头架整长 82，可用 79上架高 31，下架高 23.5鞋柜外： 29.2 $\times$ 48 $\times$ 55内： 29 $\times$ 46.7 $\times$ 53.5储物柜外： 192 $\times$ 58 $\times$ 65内： 31（单个） $\times$ 54.5 $\times$ 63架床梯子161（高） $\times$ 26（整宽）]]></content>
      <categories>
        <category>Decoration</category>
      </categories>
      <tags>
        <tag>Decoration</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态加载 Fragment]]></title>
    <url>%2FAndroid%2F%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%20Fragment%2F</url>
    <content type="text"><![CDATA[1. 步骤1.1 获取 FragmentManager当位于 Activity 时，调用 getFragmentManager() 方法即可获取到 FragmentManager 实例当位于 Fragment 时，调用 getActivity().getFragmentManager() 获取 FragmentManager 实例如果在 Fragment 内层，即 Fragment 的 container 也是 Fragment 时，调用 getChildFragmentManager() 来获取 FragmentManager 实例注意： getChildFragmentManager() 仅用于两层 FragmentManager 的时候。如果仅仅只是一层 Fragment，那么应该将 Fragment 的切换操作回调到 Activity 进行12345678// when in the activityFragmentManager fragmentManager = getFragmentManager();// when in the fragmentFragmentManager fragmentManager = getActivity().getFragmentManager();// When in the nested fragmentFragmentManager fragmentManager = getChildFragmentManager();1.2 调用 beginTransaction() 启动一个事务这个方法是 FragmentManager 的方法1FragmentTransaction transcation = fragmentManager.beginTransaction();1.3 将 Fragment 加入到容器里面我们有两种添加 Fragment 的方法， add() 和 replace()注意添加的时候带上 tag 参数，以方便后面的弹出和返回。使用 replace() 方法一般的，我们使用 replace() 方法直接替换布局来将 Fragment 添加到 容器里面1transaction.replace(R.id.container, fragment, tag);replace() 方法需要指定一个用于替换 container 的 Fragment 实例，同时还可以给其打上一个 tag（String 类型的）来方便以后寻找。注意，R.id.container是 Activity 布局中的一个 layout 一般不将根布局替换，而是将其内部的一个子布局替换掉。例如下面的 xml，一般不替换根目录，而是上面的 &lt;RelativeLayout&gt;123456789101112131415&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:fitsSystemWindows="true" android:orientation="vertical"&gt; &lt;include layout="@layout/include_toolbar" /&gt; &lt;RelativeLayout android:id="@+id/container" android:layout_width="match_parent" android:layout_height="wrap_content"/&gt;&lt;/LinearLayout&gt;add() 方法另外还有另一种添加 Fragment 的方法 add()，与 replace() 的调用方式相同，将 replace() 替换成 add() 即可一般来说，add() 方法的效果和 replace() 方法相同，但在一些情况下有所区别。1.4 使用 commit() 方法来提交事务1234567// 用这条语句来提交事务使得事务生效transaction.commit();// 当然也可以连着写。fragmentManager.beginTransaction() .replace(R.id.containe, fragment) .commit();另外，还有一个 commitAllowingStateLoss() 方法，关于这个方法和 commit() 方法的区别和注意事项，在下面有所介绍2. 补充部分2.1 添加 Fragment 到返回栈当有需要通过按返回键返回到上一个 Fragment 的时候，可以使用 addToBackStack(null) 方法将当前的 Fragment 添加到返回栈中，此时通过按返回键即可回到上一个 Fragment。addToBackStack() 方法还可以接受一个 tag 作为参数，添加具有特定 tag 的 Fragment 进入返回栈。Fragment 的状态是最后离开这个 Fragment 的状态，也就是说它会保留最后的 Fragment 状态。2.2 add() 和 replace() 的区别replace() 方法会删除当前的 Fragment 然后加入一个新的 Fragment当前仅会存在一个 Fragment 在 container 中此方法会重新实例化 Fragmentadd() 方法只是添加了一个实例到 container 中，而不会删除当前的 Fragment 实例当前有可能会存在多个 Fragment 在 container 中此方法不会重新实例化 Fragment，当且仅当它没有被系统回收的时候如何选用这两个方法一般来说，它们的效果都是一样的，但是为了避免 Layout 的冗余，我们一般使用 replace()但是，当你需要在 Fragment 的生命周期中启动一个异步任务或者加载一些大量的资源文件的时候，replace() 的重新实例化特性会使得资源被大量的消耗，所以在这种情况下，使用 add()2.3 提交事务的注意事项IllegalStateException 异常这个异常通常会在 Activity 的状态保存之后，尝试去提交（即调用 commit() 方法）一个 FragmentTransaction 的时候发生，称为活动状态丢失（Activity State Loss）。这是由于系统会在活动在被挂起或销毁之前会将其当前状态保留为一个快照（例如用户按下 Home 键），但是这个快照并没有将 FragmentTransaction 作为活动的一部分保留，而是将其丢失了，由于活动当前被销毁或挂起，所以无法提交一个 FragmentTransaction123456// 堆栈跟踪和异常代码java.lang.IllegalStateException:Can not perform this action after onSaveInstanceState at android.support.v4.app.FragmentManagerImpl.checkStateLoss(FragmentManager.java:1341) at android.support.v4.app.FragmentManagerImpl.enqueueAction(FragmentManager.java:1352) at android.support.v4.app.BackStackRecord.commitInternal(BackStackRecord.java:595) at android.support.v4.app.BackStackRecord.commit(BackStackRecord.java:574)异常抛出的时间点异常抛出的时间点通常和 commit() 的被调用时间点是一致的，总结为下表|注：Honeycomb 即 3.0(API 11) |Honeycomb 之前的版本|Honeycomb 及更新的版本|——|—-|——|commit() 在 onPause() 前被调用| OK| OKcommit() 在 onPause() 和 onStop() 执行中间被调用|STATE LOSS(此时并没有异常)| OKcommit() 在 onStop() 之后被调用 |EXCEPTION |EXCEPTION如何避免异常谨慎的在除 onCreate() 的其他生命周期函数中提交 Transaction你必须保证 Acitivity 被完全恢复之后才能提交 Transaction。例如，你不应该在 FragmentActivity 的 onResume() 方法中提交 Transactions，有时候这个方法可能在 Activity 被恢复前调用，你应该在 onPostResume() 方法中提交，以保证 Acitivity 完全恢复避免在异步回调函数中提交 Transaction例如，应该避免在 AsyncTask 的 onPostExecute() 方法和 LoaderManager.LoaderCallbacks 的 onLoadFinished() 方法中提交 Transaction。由于它们都没有考虑到 Activity 的实际状态，有可能在 Activity 已经被结束之后仍然被调用。使用 commitAllowingStateLoss() 方法此方法和 commit() 的唯一区别在于，当状态丢失出现的时候，其不会抛出一个异常。通常不应使用这个方法，除非状态丢失无可避免，否则就不应使用此方法3. Fragment 管理3.1 返回到指定的 Fragment当我们开启了太多的 Fragment，想回到指定的某个 Fragment (比如说最开头的那一个) 时，使用 popBackStack(String tag, int flags) 通过指定一个 Fragment 的 tag 来返回到指定的那个 Fragment；第二个 flags 参数用来指定是否要将指定的 Fragment 也 pop 出去，此参数只能有两个值 POP_BACK_STACK_INCLUSIVE 或者 0，如果指定了 POP_BACK_STACK_INCLUSIVE 这个参数，那么就会将指定的 Fragment 也 pop 出去。注意事项：一般采用 tag 参数来定位一个 Fragment当使用 add() 方法添加 Fragment 时，因为一个 ViewGroup 容器可以依附 add() 多个Fragment，它们的 id 自然是相同的。popBackStack(null, FragmentManager.POP_BACK_STACK_INCLUSIVE) 的真正作用。这个方法的官方文档似乎有一些错误（或者缺漏）由于第二个参数的存在，方法会在返回栈中寻找是否存在一个 tag 为 null 的 Fragment，显然，这是找不到的。所以，这个方法实际上会清空返回栈3.2 在 Fragment 之间切换3.2.1 使用 add() show() hide() 方法FragmentPagerAdapter 采用这种模式，需要注意以下几种情况只是显示和隐藏 Fragment，并不进入 Fragment 生命周期当隐藏的时候，Fragment 仍然被激活，依旧会对点击事件作出反应。仍然会响应点击事件的原因在于，由于使用的是 add() 方法，所以当前 container 会有多个 Fragment 实例，然后 show() 和 hide() 仅仅是将视图隐藏了，Fragment 实例依旧处于激活状态，所以会导致多个 Fragment 都会对点击事件做出响应。我们称为点击事件的泄露此时，需要一些技巧防止点击事件的泄露使用 xml 截获点击事件将 内层 Fragment 的根布局设置为 clickable=&quot;true&quot; 即可1234&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;fill_parent&quot; android:clickable=&quot;true&quot; /&gt;使用 java 截获点击事件为根布局设置 OnTouchListener 并重载一个空方法，返回 true12345678910111213@Overridepublic View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstance)&#123; View root; /*here is an implementation*/ root.setOnTouchListener(new View.OnTouchListener() &#123; public boolean onTouch(View v, MotionEvent event) &#123; return true; &#125; &#125;); return root;&#125;解决 Fragment already added 错误在复杂的 Fragment 管理中，经常会遇到 Fragment already added 错误，所以每次在 add Fragment 之前，首先要判断 fragment.isAdded() 如果已经存在了那就不用再 add() 了解决由于屏幕旋转或其他原因引起的 Activity 重构建导致 Fragment 重复问题Android 系统中，Activity 可能在任何时刻被不被通知地销毁和重建，由此则会引起 Fragment 的重叠问题。可以通过检查是否存在 Activity 的快照 savedInstanceState 来决定是否需要重新构建一个 Fragment 实例。如果存在 savedInstanceState，则不需要重新构建，只重新显示最后的当前 Fragment 即可这里是 add() show() hide() 模式的代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/*** This way aims at resolve the following problem* 1. The reinstantiaiton of Fragment* 2. The Layout redundancy of multiple Fragment*///Check the Fragment isAdded. Aim to #1public void switchContent(Fragment from, Fragment to) &#123; // The mContent is the current fragment if (mContent != to) &#123; mContent = to; FragmentTransaction transaction = mFragmentMan.beginTransaction().setCustomAnimations( android.R.anim.fade_in, R.anim.slide_out); if (!to.isAdded()) &#123; // Judge if is added // if not added, hide the current Fragment and add the next to Activity transaction.hide(from).add(R.id.content_frame, to).commit(); &#125; else &#123; //if added, just show the next. transaction.hide(from).show(to).commit(); &#125; &#125;&#125;//Check the saveInstance to avoid the activity reinstance. Aim to #2@Overrideprotected void onCreate (Bundle savedInstanceState) &#123; if (savedInstanceState == null) &#123; getFragmentManager().beginTransaction().add(android.R.id.content, new UIFragment(),"Tag").commit(); &#125; else &#123; //if the instance does be recover, //use `findFragmentByTag()` to find the reference of the Fragment UIFragment fragment1 = getFragmentManager().findFragmentById(R.id.fragment1); UIFragment fragment2 = getFragmentManager().findFragmentByTag("tag"); UIFragment fragment3 = ... ... //show one of them getFragmentManager().beginTransaction() .show(fragment1) .hide(fragment2) .hide(fragment3) .hide(...) .commit(); &#125;&#125;3.2.2 使用 replace() 方法FragmentStatePageAdapter 采用这种模式当前只会存在一个 fragment 实例，简单的使用 replace() 和 popBackStack() 的重载方法即可在 Fragment 之间进行切换但是由于此方法在切换时每次都会重新构建 Fragment 实例，如果需要从网络加载资源的话，会造成很多的网络流量损失和性能浪费。3.2.3 比较和使用场景如果管理 Fragment 的开销比网络流量的开销要大，使用 replace() 方法较好。例如每次仅仅加载 几个k 或 几十b 的数据，就没有必要为了这点微不足道的流量节省从而进行复杂的 Fragment 管理，一是加大开发难度，二是容易出现错误。如果在 Fragment 中需要加载大量的网络资源，或者进行十分耗时的资源加载工作（比如3D绘图），那么就应使用 add() show() hide() 方法]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TextInputLayout 使用]]></title>
    <url>%2FAndroid%2FTextInputLayout%20%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1. 介绍TextInputLayout 是 Android 6.0 提供的新的输入框架，可以显示一个更好的输入效果。以下是 TextInputLaout 的显示效果![](https://blog.incredibleandros.com/images/textInputlayout.gif)2. 基本使用2.1 添加依赖框架TextInputLayout 是 Android design 库的控件，所以需要添加 Android 的 design 库。12compile &apos;com.android.support:appcompat-v7:23.3.0&apos;compile &apos;com.android.support:design:23.3.0&apos;2.2 XML 代码在这里要注意， TextInputLayout 实际上是一个 Layout 控件，不能提供输入框功能输入框应由其中的 TextInputEditText 提供。其实使用 EditText 代替也是可以的，但是 Google 官方更加推崇 TextInput 系列的配套使用1234567891011&lt;android.support.design.widget.TextInputLayout android:layout_width=&quot;fill_parent&quot; android:id=&quot;@+id/your_matchcode_holder&quot; app:errorEnabled=&quot;true&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;android.support.design.widget.TextInputEditText android:id=&quot;@+id/your_matchcode&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&lt;/android.support.design.widget.TextInputLayout&gt;2.3 相应效果的设置TextInputLayout 区别于 EditText 的一点在于，一些提示效果，如 Hint 和 Error Message 需要在 Java 代码中进行设置。注意，因为 TextInputLayout 中内置了 getEditText() 方法，所以只需要给 TextInputLayout 设置 id 即可。2.3.1 Hint 效果设置 TextInputLayout 的 Hint 效果很简单，只需要调用 setHint() 方法即可。1phoneWrapper.setHint(getString(R.string.login_hint_phone));2.3.2 Error 效果设置 TextInputLayout 的 Error 效果则有点 tricky。一般来说，设置 Error 效果和 Hint 一样，调用 setError() 即可。1phoneWrapper.setError(phoneNumberErrorMessage);setError(&quot;error message&quot;) 会判断如果 Error 没有 Enable 的话，会先调用 setErrorEnable(true)，所以设置 Error 不需要事先设置 setErrorEnable(true)但是，当需要清除 Error 效果时，则必须需要两步。设置 setError(null)设置 setErrorEnable(false)原因在于，setError(null) 只会把 Error 设置为 View.INVISIABLE，不会消除错误信息所占的空间。所以，我们需要使用 setErrorEnable(false) 去将显示错误的 TextView 删除掉，从而消除错误所占的空间。那能不能只调用 setErrorEnable(false) 呢？答案是不能。原因在于，setErrorEnable(false)，不会消除存储错误信息的 mError，而当再次出现同样的错误，设置 setError(&quot;error message&quot;) 时，由于 mError 没有更新，导致 setError() 判断前后错误信息一致，直接返回，没有重新生成 TextView，从而错误信息就不会再显示了。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Style 和 Theme 的简明对比]]></title>
    <url>%2FAndroid%2FStyle%20%E5%92%8C%20Theme%20%E7%9A%84%E7%AE%80%E6%98%8E%E5%AF%B9%E6%AF%94%2F</url>
    <content type="text"><![CDATA[1. Style 应用于局部，而 Theme 应用于整体一个 Style 只对一个 View 组件有效；而一个 Theme 对整个 application 或 activity 或者一个 ViewGroup(View 组件和它的子项) 有效。2. Style 是组件多种属性的集合实际上，一个组件的 style 就是其多种属性的集合。也就是说，可以直接在 style 中设置 theme。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio FAQ]]></title>
    <url>%2FAndroid%2FAndroidStudio%2FAndroid%20Studio%20FAQ%2F</url>
    <content type="text"><![CDATA[1. .gitignore 文件如果你想要尽量的减少冲突，就不要直接使用 Android Studio 默认生成的 .gitignore 文件，而是要在 .gitignore 中添加一些项目，或者直接导入其内置的许多模板。这里有一些应该加入的项目:/.idea 文件夹/.idea 文件夹是 gradle 导入工程时生成的文件夹，它会被 gradle 自动生成。在添加一个新依赖的时候，build 流程会自动添加依赖项的描述到 /.idea 文件夹里，所以很容易会引起冲突。.iml 文件iml 文件会在当你导入 gradle 工程的时候被 gradle 自动生成，和上面一样，gradle 会自动添加一些描述到 .iml 文件里面，其中也包括了依赖项的描述/gradle.properties 文件这个文件经常只保存了 gradle 的代理设置，1.5 版本以后的 Anroid Studio 会在当你进行 Gradle Sync 的时候自动将 Android Studio 的代理设置导入到这个文件里面。如果组员各自使用不同的代理设置，那么就应该忽略它补充1：别忘记执行 git rm -r --cached 来删除 git 版本树中的版本.gitigonre 仅对那些没有追踪的文件起作用，如果已经被 git 系统追踪了，仅将其加入到 .gitignore 是没有作用的。补充2：当你需要忽略一个文件夹的时候，别忘记添加 / 后缀例如：当你需要忽略 .gradle 文件夹的时候，你需要输入 /.gradle/ ，这样，它才能忽略整个文件夹，否则，当你删除这个文件夹，然后被重新生成时， Android Studio 就不会识别出它是已经忽略掉的了。综上所述，这里是我的 .gitignore 例子。12345678*.iml/.idea//gradle.properties.gradle//local.properties.DS_Store/build/captures2. 当出现 cannot resolve symbols 时首先，你需要检查依赖是否已经被正确加载了，如果依赖项没有问题那么请依照以下流程来尝试进行修复检查使用的 gradle 是否正确在 Settings 中检查 gradle 的选项，一般推荐使用 Anroid Studio 内置的 gradle。删除本地的代码库，重新克隆一份尝试点击 Gradle Sync 按钮进行 Gradle Sync在 Build 菜单选择 Clean the Project在 Build 菜单选择 Rebuild the Project需要注意的是，当你克隆完毕后，使用 Open existing Project 或者 Import from gradle 来打开工程，而不是在 recently projects 中打开。3. 当不能识别出 Android 框架时如果你的 Android Studio 不能识别出 Gradle 或者整个 Anroid 框架的时候，例如，导航条没有 app module，在 Build 菜单只有一点点东西的时候。备份你的代码库到远端，然后重新克隆它。当你克隆完毕的时候， rebuild project.]]></content>
      <categories>
        <category>Android</category>
        <category>Android Studio</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio 卡 buliding gradle info]]></title>
    <url>%2FAndroid%2FAndroidStudio%2FAndroid%20Studio%20%E5%8D%A1%20buliding%20gradle%20info%2F</url>
    <content type="text"><![CDATA[1. 问题有时候第一次使用 Android Studio 打开某个项目时，会出现项目一直卡在 buliding gradle info 的问题，如图所示：![Building project info](https://i4.buimg.com/563021/c4ee7577d3d0bcde.jpg)此问题的原因在于：用于下载 gradle 本体的网站被墙了，导致下载速度缓慢。2. 解决办法打开 gradle 的 gradle.properties，然后直接从里面的链接下载 gradle，放入 gradle 的文件夹中即可。当然，最靠谱的方法还是去翻墙啦。]]></content>
      <categories>
        <category>Android</category>
        <category>Android Studio</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Splash Screen]]></title>
    <url>%2FAndroid%2FSplash%20Screen%2F</url>
    <content type="text"><![CDATA[1. 在 Activity 中实现将此 Activity 设置为 LANCHER Activity记得加载完之后要跳转到其他 Activity 同时 finish() 这个 Activity使用 Handler.postDelayed() 方法去增强延迟，以免加载过快引起用户体验下降记得要在视图被加载之后使用12345678910/*** Use it after* setContentView() in onCreate() in Activity*/new Handler().postDelayed(new Runnable() &#123; public void run() &#123; goHome(); &#125; &#125;, SPLASH_DELAY_MILLIS);&#125;2. 在 Fragment 中使用当在 Fragment 中时，与 Activity 并无显著区别，记住要在视图被加载之后使用所以一般在 onCreateView() 之后调用 delay。根据 Fragment 生命周期来看，应该在 onStart() 方法中使用这个比较合适]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RecyclerView]]></title>
    <url>%2FAndroid%2FRecyclerView%2F</url>
    <content type="text"><![CDATA[1. 一般的使用1.1 添加编译依赖1compile &apos;com.android.support:recyclerview-v7:+&apos;1.2 界面的基本设置将 RecyclerView 加入到 layout.xmllayout.xml 指的是 Activity 或者 Fragment 的布局1234567&lt;android.support.v7.widget.RecyclerView android:layout_width="match_parent" android:layout_height="match_parent" android:id="@+id/recycler" android:scrollbars="vertical"/&gt; &lt;!-- Must define the scrollbars attr --&gt;新建一个 item_layout.xml 用于 item 的界面123456789101112&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="wrap_content"&gt;&lt;TextView android:layout_width="match_parent" android:layout_height="match_parent" android:id="@+id/quest_item" /&gt;&lt;/LinearLayout&gt;注意，在 support-library 23.2.0 之后，LayoutManager 提供了自动调整功能，所以对 item 的根布局应采用 wrap_content 的 layout_hight1.3 设置 LayoutManager 和 Adapter12345678910111213141516171819@Overridepublic View onCreateView(LayoutInflater inflater, ViewGroup parent, Bundle savedInstanceState) &#123; View v = inflater.inflate(R.layout.fragment_recyclerview, parent, false); //set the Recycler mRecyclerView = (RecyclerView) v.findViewById(R.id.recycler_view); //set LayoutManager mRecyclerView.setLayoutManager(new LinearLayoutManager(getActivity())); //DataSet mCrimes = CrimeLab.get(getActivity()).getCrimes(); //set the Adapter mRecyclerView.setAdapter(new CrimeAdapter()); return v;&#125;1.4 定义 Adapter 和重载方法你需要自定义一个自己的 MyAdapter 并继承 Adapter注意以下几点：Adapter 储存着数据的集合，还有一个作为内部类的 ViewHolder123456789101112131415161718public class MyAdapter extends RecyclerView.Adapter&lt;MyAdapter.ViewHolder&gt; &#123; //The DataSet private List&lt;Object&gt; mDatas; //...other stuff //The inner ViewHolder class MyViewHolder extends Recycler.ViewHolder &#123; //The views public TextView textView; //The Ctor is Auto-Generate public MyViewHolder (View itemView) &#123; super(itemView); //Just set the view as the @param is Ok &#125; &#125;&#125;重载方法的使用123456789101112131415161718192021222324@Overridepublic MyViewHolder onCreateViewHolder(ViewGroup parent, int ViewType) &#123; // Build a ViewHolder which is the inner class, and return it /** * Notice: The ViewType is use to build the diffirent ViewHolder * to display diffirent ViewHolder */ return new MyViewHolder(mLayoutInflater.inflate(R.layout.item_text, parent, false));&#125;@Overridepublic void onBindViewHolder(MyViewHolder holder, int position) &#123; // Bind the view with the DataSet // Just like the getView() method in ListView // But it's more easier holder.mTextView.setText(mData[position]);&#125;public int getItemCount() &#123; // Return the amount of item&#125;2. 多 Item 布局实现使用 getItemViewType(int position) 方法来获取每个 position 的 ViewTypeRecyclerView 中取消了 getItemViewTypeCount() 方法例如：12345@Overridepublic int getItemViewType(int position) &#123; return position % 2 == 0 ? ITEM_TYPE.ITEM_TYPE_IMAGE.ordinal() : ITEM_TYPE.ITEM_TYPE_TEXT.ordinal();&#125;然后使用 onCreateViewHolder() 中的 int ViewType 属性来判别构建的 View 类型。3. 设置 OnItemClickListener官方并没有为 RecyclerView 实现一个 OnItemClickListener，所以只能由开发者自行实现一般来说，我们使用回调来实现这个监听器需要注意的是，官方并没有为 Item 实现一个点击的 feedback 动画（至少在 5.1.1(API 22)中），所以我们需要添加一个 &lt;ripple&gt; 的 drawable 然后将其设置为背景来实现一个点击回馈的效果。3.1 定义一个 Listener 接口通常作为 Adapter 的一个内部类123456789public interface OnItemClickListener &#123; /** * This is the callback method. * Aimed to notify the context the Click Event. * To modify UI, also need to pass the position for UI updating or do othertings */ void onItemClick (View view, int position);&#125;3.2 为 Adapter 添加接口成员1234567class MyAdapter ... &#123; private OnItemClickListener mOnItemClickListener; public void setOnItemClickListener(OnItemClickListener mOnItemClickListener) &#123; this.mOnItemClickListener = mOnItemClickListener; &#125;&#125;3.3 设置点击响应并将其回调这里在 onBindViewHolder() 中设置 ViewHolder 中 View 的 onClick() 事件，并将这个事件回调到上面的接口成员中。123456789101112131415161718public void onBindViewHolder (final MyViewHolder holder, final int position) &#123; // Bind the View with Data holder.textView.setText(mDatas.get(position)); // Set the Listener // Notice: if the callback was set, // then set the Click Event for the ViewHolder if(mOnItemClickLitener != null) &#123; holder.textView.setOnClickListener (new OnClickListener() &#123; @Override public void onClick (View v) &#123; int pos = holder.getLayoutPosition(); // Call the callback method mOnItemClickListener.onItemClick(hodler.textView, pos); &#125; &#125;); &#125;&#125;3.4 在 Acitivity 或者 Fragment 中响应回调注意，这个方法是在 Fragment 中进行的。123456789@Overridepublic void onCreateView(...) &#123; mAdapter.setOnClickListener (new OnItemClickListener() &#123; @Override public void onItemClick(View v, int position) &#123; //Update: 2016-10-14 &#125; &#125;)&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Material Design 概述]]></title>
    <url>%2FMaterialDesign%2FMaterial%20Design%20%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[1. 介绍Material Design 是 Google 官方在 2014 I/O 上发布的设计语言。事实上随着更多的 Android 设备进入到 5.0 以上系列，Material Design 的应用也愈加广泛。2. 设计原则2.1 Material is the metaphor实体(Material) 是此设计语言的基本组成，与众不同的触感是实体的基础。实体的表面和边缘提供了基于真实效果的体验，熟悉的触感能让用户快速的理解和感知，实体的多样性能更好反映真实世界的设计效果，而又不会脱离客观规律。光效、表面质感、运动感这三点是解释物体运动规律、交互方式、空间关系的关键。真实的光效可以解释物体之间的交合关系、空间关系，以及单个物体的运动。2.2 鲜明、形象、深思熟虑新的视觉语言，在基本元素的处理上，借鉴了传统的印刷设计——排版、网格、空间、比例、配色、图像使用——这些基础的平面设计规范。在这些设计基础上下功夫，不但可以愉悦用户，而且能够构建出视觉层级、视觉意义以及视觉聚焦。精心选择色彩、图像、选择合乎比例的字体、留白，力求构建出鲜明、形象的用户界面，让用户沉浸其中。Material Design 设计语言强调根据用户行为凸显核心功能，进而为用户提供操作指引。2.3 有意义的动画效果动画效果(简称动效)可以有效地暗示、指引用户。动效的设计要根据用户行为而定，能够改变整体设计的触感。动效应当在独立的场景呈现。通过动效，让物体的变化以更连续、更平滑的方式呈现给用户，让用户能够充分知晓所发生的变化。动效应该是有意义的、合理的，动效的目的是为了吸引用户的注意力，以及维持整个系统的连续性体验。动效反馈需细腻、清爽。转场动效需高效、明晰。]]></content>
      <categories>
        <category>MaterialDesign</category>
      </categories>
      <tags>
        <tag>MaterialDesign</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Genymotion Problems and Solutions]]></title>
    <url>%2FAndroid%2FGenymotion%20Problems%20and%20Solutions%2F</url>
    <content type="text"><![CDATA[1. 简介这里是一些 Genymotion 安卓模拟器的问题解答集虽然这个工具很出名，但是由于它使用 VirtualBox 来实现一个 x86 的虚拟机，它在 Windows 上就显得有些烦人（和反人类）2. Unable connect to virtual_device当这个错误发生的时候，Genymotion 会让你在 VirtualBox 里面启动你的安卓虚拟机。请遵循这个执行，然后你就会获取到一个出错信息这里有一些已知的情况：2.1 Virtual Host Error如果你收到了一个关于 Virtual Host 的出错信息，那它将会像这样子：12Failed to open/create the internal network 'HostInterfaceNetworking-VirtualBox Host-Only Ethernet Adapter' (VERR_INTNET_FLT_IF_NOT_FOUND).Failed to attach the network LUN (VERR_INTNET_FLT_IF_NOT_FOUND).解决办法：解决办法很简单，根据这个 stackoverflow :打开 Windows 网络与共享中心点击更改适配器设置右键 VirtualBox 建立的 VirtualBox Host only adapter这个通常可以在 VirtualBox 的你的虚拟机选项中的网络选项查看。也可以从 VirtualBox 的设置 -&gt; 网络中查看点击属性勾选 “VirtualBox NDIS6 Bridged Networking driver”禁用并重新启用这个适配器When this error occurs, genymotion will ask you to start the virtual device on VirtualBox, plase follow the instruction, and then you will get a ERROR message.3. 虚拟机链接不上网络这个有时会让人挺困惑——“为什么我的虚拟机连不上网络呢？”解决办法：其实并不是什么大事，在虚拟机中打开 wifi 选项，然后直接连接里面的 wifi 即可它不会连接到真实的 wifi，而仅仅是虚拟网络]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[插线板重构计划]]></title>
    <url>%2FPlan%2F%E6%8F%92%E7%BA%BF%E6%9D%BF%E9%87%8D%E6%9E%84%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[1. 设备清单1.1 目前拥有的设备[x] Mac[x] 笔记本[x] 3ds[x] kindle[x] hub[x] 路由器[x] 交换机[x] 显示器[x] 手机[x] 平板[x] 灯[x] 移动电源[x] 散热器[x] 剃须刀[x] 耳机1.2 将要购置的设备[x] ps4[x] 硬盘[x] 风扇[x] 显示器显示器只会有一个得到供电。1.3 可以使用 USB 的设备3dskindlehub平板移动电源风扇散热器2. 供电接口计划原则：尽量使用 USB 口进行供电，避免占用插线口2.1 可提供的供电接口目前计划购入 QIC 8 口 + 5 USB 插座，共有 8 个插口 + 5 个 USB 口，其中 2A 口为 2 个。墙上固有插座： 2 三孔 + 2 二孔。另外 Hub 也可提供 4 个 USB 充电接口。共 8 + 2 + 2（两孔） = 12 个电插口 + 9 个 USB 口2.2 计划接入 USB 口的设备若 Hub 接入 USB 口，则有 4 + 4 = 8 个 USB 充电接口，其中 2A 口为 2 个。3dskindlehub移动电源(2A)平板(2A)风扇散热器目前占用两个 2A 口，4 个普通口，共 6 个接口。若风扇不用 USB 口，则用 5 个接口。通过2.3 计划接入插口的设备Mac显示器笔记本路由器交换机灯剃须刀耳机手机PS4硬盘共需要 11 个供电插口，若风扇使用电插口，则需要 12 个。紧张解决办法：[ ] 1. 寻找更大的插座[ ] 2. 与目前插座串联，增加可用量[x] 3. 购置多个插座（18 + 5）]]></content>
      <categories>
        <category>Plan</category>
      </categories>
      <tags>
        <tag>Plan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Butter Knife]]></title>
    <url>%2FAndroid%2FButter%20Knife%2F</url>
    <content type="text"><![CDATA[1. 安装与配置1.1 添加 Gradle 依赖在 app/build.gradle 中加入如下语句1compile 'com.jakewharton:butterknife:7.0.1'1.2 压制 Lint Warnning在使用 Butter Knife 时，由于它是动态生成代码，Lint 由于没有检测到代码，所以会提示一些错误的警告，所以需要压制 Lint Warning。在 app/build.gradle 中添加如下代码123lintOptions &#123; disable 'InvalidPackage'&#125;1.3 配置 ProGuard由于 Android 在 Release apk 时，会使用 ProGuard 来进行代码优化和混淆，但是它很可能无法正确区分所需要的代码，从而将 Butter Knife 的代码删除，所以要配置一些 Keep 选项。在 proguard.cfg 文件中配置1234567891011-keep class butterknife.** &#123; *; &#125;-dontwarn butterknife.internal.**-keep class **$$ViewBinder &#123; *; &#125;-keepclasseswithmembernames class * &#123; @butterknife.* &lt;fields&gt;;&#125;-keepclasseswithmembernames class * &#123; @butterknife.* &lt;methods&gt;;&#125;2. 使用Butter Knife 最大的好处就是使用注解式开发，从而减少大量重复冗余的代码。2.1 绑定视图这里需要注意的是，重点是要调用 ButterKnife.bind() 方法，否则是无法起作用的。2.1.1 在 Activity 中进行绑定使用 @Bind 注释，并传入相应的视图 id，就可以将一个组件和它的视图快速绑定例如：1234567891011121314class ExampleActivity extends Activity &#123; @Bind(R.id.title) TextView title; @Bind(R.id.subtitle) TextView subtitle; @Bind(R.id.footer) TextView footer; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.simple_activity); // 注意，这个必须在 setContentView之后执行 ButterKnife.bind(this); // TODO Use fields... &#125;&#125;注意， Butter Knife 的原理是通过生成代码来实现的，上面的使用相当于（生成了）以下代码12345public void bind(ExampleActivity activity) &#123; activity.subtitle = (android.widget.TextView) activity.findViewById(2130968578); activity.footer = (android.widget.TextView) activity.findViewById(2130968579); activity.title = (android.widget.TextView) activity.findViewById(2130968577);&#125;2.1.2 在 Fragment 中进行绑定Butter Knife 提供了其 bind() 方法的几个重载，也可以通过接受一个根布局来进行绑定，所以在 Fragment 中应如下使用：123456789101112public class FancyFragment extends Fragment &#123; @Bind(R.id.button1) Button button1; @Bind(R.id.button2) Button button2; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View view = inflater.inflate(R.layout.fancy_fragment, container, false); // 通过提供一个根布局实现 Fragment 的绑定 ButterKnife.bind(this, view); // TODO Use fields... return view; &#125;&#125;2.1.3 在 ViewHolder 中实现绑定Android APP 中， ListView 或 RecyclerView 是最为常见的视图组件，对此，Butter Knife 也实现了 ViewHolder 的绑定方法。如下：这里使用的是 ListView, 但是由于绑定的实现都在 ViewHolder 内部类中，因而 RecyclerView 的使用同理。1234567891011121314151617181920212223242526public class MyAdapter extends BaseAdapter &#123; @Override public View getView(int position, View view, ViewGroup parent) &#123; ViewHolder holder; if (view != null) &#123; holder = (ViewHolder) view.getTag(); &#125; else &#123; view = inflater.inflate(R.layout.whatever, parent, false); holder = new ViewHolder(view); view.setTag(holder); &#125; holder.name.setText("John Doe"); // etc... return view; &#125; static class ViewHolder &#123; @Bind(R.id.title) TextView name; @Bind(R.id.job_title) TextView jobTitle; public ViewHolder(View view) &#123; ButterKnife.bind(this, view); &#125; &#125;&#125;2.1.4 其他情形实际上，@Bind 注解只是起到了一个引入视图的作用，真正起到作用的是 ButterKnife.bind 方法，这一方法可以被放在任何你想使用 findViewById 的地方2.1.5 其他绑定 APIButterKnife.bind(this, activity)这个方法可以在将导入的视图 xml 在任何地方进行绑定，如果采用了类似 MVC 的编程模式，那么就可以使用这个方法在 Controller 中进行绑定2.1.6 绑定 View 列表你可以一次性将多个 View 绑定到一个 List 或者数组上12@Bind(&#123; R.id.first_name, R.id.middle_name, R.id.last_name &#125;)List&lt;EditText&gt; nameViews;可以使用统一的 apply() 方法来对 View 进行统一的操作12ButterKnife.apply(nameViews, DISABLE);ButterKnife.apply(nameViews, ENABLED, false);上面的代码实际上就相当于对列表中的每一个元素都采用这样的操作。注意，上面的 DISABLE 和 ENABLE 需要定义 Action 和 Setter 的接口方法之后才能有效12345678910static final ButterKnife.Action&lt;View&gt; DISABLE = new ButterKnife.Action&lt;View&gt;() &#123; @Override public void apply(View view, int index) &#123; view.setEnabled(false); &#125;&#125;;static final ButterKnife.Setter&lt;View, Boolean&gt; ENABLED = new ButterKnife.Setter&lt;View, Boolean&gt;() &#123; @Override public void set(View view, Boolean value, int index) &#123; view.setEnabled(value); &#125;&#125;;同时，也可以将 Android 的 Property 应用到 apply() 方法中1ButterKnife.apply(nameViews, View.ALPHA, 0.0f);2.2 绑定监听器Butter Knife 也同时提供了绑定监听器的方法；通过使用 @OnClick 注解，在随后的方法中实现监听处理即可。1234@OnClick(R.id.submit)public void submit(View view) &#123; // TODO submit data to server...&#125;监听器的所有参数都是可选的1234@OnClick(R.id.submit)public void submit() &#123; // TODO submit data to server...&#125;定义一个其他的类型，Butter Knife 也能够识别，并进行自动 Cast为了尽量避免 Cast，所以应该尽量少使用这一种模式1234@OnClick(R.id.submit)public void sayHi(Button button) &#123; button.setText("Hello!");&#125;自定义的组件可以通过不传入 id 来实现监听器绑定123456public class FancyButton extends Button &#123; @OnClick public void onClick() &#123; // TODO do something! &#125;&#125;还可以绑定多个控件到同一个事件监听器上12345678@OnClick(&#123; R.id.door1, R.id.door2, R.id.door3 &#125;)public void pickDoor(DoorView door) &#123; if (door.hasPrizeBehind()) &#123; Toast.makeText(this, "You win!", LENGTH_SHORT).show(); &#125; else &#123; Toast.makeText(this, "Try again", LENGTH_SHORT).show(); &#125;&#125;2.3 取消绑定这个步骤通常在 Fragment 的使用中出现，由于 Fragment 的生命周期和 Activity 不同，我们可能需要在 onCreateView() 中构建视图，然后在 onDestroyView() 中将视图进行销毁。这时候，我们就需要在 onDestroyView() 中将视图取消绑定12345678910111213141516public class FancyFragment extends Fragment &#123; @Bind(R.id.button1) Button button1; @Bind(R.id.button2) Button button2; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View view = inflater.inflate(R.layout.fancy_fragment, container, false); ButterKnife.bind(this, view); // TODO Use fields... return view; &#125; @Override public void onDestroyView() &#123; super.onDestroyView(); ButterKnife.unbind(this); // 在这里取消绑定 &#125;&#125;2.4 可选的绑定在默认情况下， @Bind 和监听器的绑定都是需要的，如果目标 View 没有找到的话，Butter Knife 将会抛出一个异常。可以通过设置 @Nullable 注解来取消这个绑定注意，@Nullable 注解来源于 Android 的 support-annotations 库12345@Nullable @Bind(R.id.might_not_be_there) TextView mightNotBeThere;@Nullable @OnClick(R.id.maybe_missing) void onMaybeMissingClicked() &#123; // TODO ...&#125;2.5 对于多个方法的监听器绑定当一个监听器拥有多个回调方法时，使用 callback 参数来指定所需要绑定的回调方法123456789@OnItemSelected(R.id.list_view)void onItemSelected(int position) &#123; // TODO ...&#125;@OnItemSelected(value = R.id.maybe_missing, callback = NOTHING_SELECTED)void onNothingSelected() &#123; // TODO ...&#125;2.6 简化的 findViewById()Butter Knife 同时还提供了一个简化版本的 findViewById() —— findById()；用这个方法可以在 View, Acitivity, Dialog 中找到想要的 View；同时，该方法通过泛型来对返回值进行转换，所以可以省去 findViewById() 的强制转换了。1234View view = LayoutInflater.from(context).inflate(R.layout.thing, null);TextView firstName = ButterKnife.findById(view, R.id.first_name);TextView lastName = ButterKnife.findById(view, R.id.last_name);ImageView photo = ButterKnife.findById(view, R.id.photo);]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Volley 库的基本使用]]></title>
    <url>%2FAndroid%2FVolley%2FAndroid%20Volley%20%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1. Volley 介绍与基本使用场景Volley 是 Google 在 2013 年 I/O 大会上发布的一个 Android 的网络框架库，用于简化 Android 构建网络连接的步骤，同时提供 缓存、网络优先级等功能。Volley 适用于高频，小流量的网络访问，例如传输 Json 信息，前后端的小流量交互等。对于上传和下载文件的需求，Volley 不适用。这主要是由于 Volley 对请求队列采用的是在内存中的缓存，决定了 Volley 不适应大文件（二进制流）的传输。2. Volley 的基本使用2.1 添加编译依赖Volley 在不久前加入了 jCenter，直接使用 gradle 的 compile 语句即可。1compile &apos;com.android.volley:volley:1.0.0&apos;如果不使用 compile 语句，则需要从 Git repository 中克隆，添加编译 module1git clone https://android.googlesource.com/platform/frameworks/volley2.2 添加网络访问权限为了使用 Volley 这一网络库，需要在 Manifest 中添加网络访问权限 android.permission.INTERNET2.3 发起网络请求Volley 是通过优先队列来管理多个网络请求的，所以使用 Volley 即构建请求队列和相应的网络请求对象即可。2.3.1 例子Volley 提供了默认的静态方法用于构建一个请求队列的实例。所以构建一个请求对象，设置好监听，并将其加入请求队列即可。12345678910111213141516171819202122232425final TextView mTextView = (TextView) findViewById(R.id.text);...// Instantiate the RequestQueue.RequestQueue queue = Volley.newRequestQueue(this);String url =&quot;http://www.google.com&quot;;// Request a string response from the provided URL.StringRequest stringRequest = new StringRequest(Request.Method.GET,url,new Response.Listener&lt;String&gt;() &#123; @Override public void onResponse(String response) &#123; // Display the first 500 characters of the response string. mTextView.setText(&quot;Response is: &quot;+ response.substring(0,500)); &#125;&#125;, new Response.ErrorListener() &#123; @Override public void onErrorResponse(VolleyError error) &#123; mTextView.setText(&quot;That didn&apos;t work!&quot;); &#125;&#125;);// Add the request to the RequestQueue.queue.add(stringRequest);StringRequest 的最后两个参数是 Response.Listener&lt;T&gt; 和 Response.ErrorListener。通过使用匿名的监听类来分别获得正常的服务器响应和网络错误时的响应2.3.2 基本原理当请求被加入到队列后，Volley 会自动运行缓存处理线程和一个网络通信线程池。缓存处理进程将请求出列，并判断缓存是否命中，如果缓存命中，就直接返回主线程进行结果处理。如果缓存没有命中，则将请求加入内置的网络通信队列，网络通信线程池中的第一个可用线程会对请求进行处理，建立 HTTP 连接，解析返回结果并将其写入缓存，随后将结果返回到主线程。下图是具体的工作流程图解2.4 取消请求如果要取消一个网络请求，只需要调用 Request 的 cancel() 方法即可。一经取消，Volley 会保证不会调用返回结果的处理器，这也就是说你可以在 Activity 的 onStop() 方法中取消所有正在处理的网络请求。同时，还可以给请求打上 TAG，使用 RequestQueue 中的 cancelAll() 方法来取消对应的被打上 TAG 的请求。TAG 的类型不限，甚至可以是 Activty，可以通过在 onStop() 中调用 cancelAll(this) 来取消所有跟这个 Activty 有关的 Request下面是一个使用 String 作为 TAG 的应用例子：1234567891011121314151617public static final String TAG = &quot;MyTag&quot;;StringRequest stringRequest; // Assume this exists.RequestQueue mRequestQueue; // Assume this exists.// Set the tag on the request.stringRequest.setTag(TAG);// Add the request to the RequestQueue.mRequestQueue.add(stringRequest);@Overrideprotected void onStop () &#123; super.onStop(); if (mRequestQueue != null) &#123; mRequestQueue.cancelAll(TAG); &#125;&#125;3. 构建队列单例对于 APP 来说，使用多个网络队列是浪费性能的，最好是整个 APP 使用一个队列。所以，我们使用单例模式来进行 Volley RequestQueue 的操作。3.1 自定义队列RequestQueue 除了使用 Volley 的静态方法构建以外，还可以自己构建 RequestQueue。这时，就可以对队列的缓存大小进行设定。初始化 Cache 实例123// The first is the Context method// The second is the SIZE of the queue, described by BYTESCache cache = new DiskBasedCache(getCacheDir(), 1024 * 1024);初始化 Network 实例12// Using the HttpUrlConnectionNetwork network = new NetWork(new HurlStack());使用以上两个实例来构建请求队列1mRequestQueue = new RequestQueue(cache, network);启动队列1mRequestQueue.start();3.2 构建单例模型为了节省系统资源，我们构建一个单例模型，整个 App 只使用这一个请求队列。12345678910111213141516171819202122232425262728293031323334353637public class NetworkSingleton &#123; private static NetworkSingleton mInstance; private static mContext; private RequestQueue mRequestQueue; // Use private constructor private NetworkSingleton(Context context) &#123; mContext = context; mRequestQueue = getRequestQueue(); &#125; public static synchronized NetworkSingleton getInstance( Context context) &#123; if (mInstance == null) &#123; mInstance = new NetworkSingleton(context); &#125; return mInstance; &#125; public RequestQueue getRequestQueue() &#123; if (mRequestQueue == null) &#123; // The request queue needs the Application context // if someone pass a Activity context // using the getApplicationContext() could prevent // the wrong paramaters mRequestQueue = Volley.newRequestQueue( mContext.getApplicationContext()); &#125; return mRequestQueue; &#125; public &lt;T&gt; void addToRequestQueue(Request&lt;T&gt; request) &#123; getRequestQueue().add(request); &#125;&#125;使用类似 Java Bean 的单例模型，我们在整个应用程序的生命周期中就只需要维护一个队列实例。同时，还可以利用单例模型来进行请求的添加和删除]]></content>
      <categories>
        <category>Android</category>
        <category>Volley</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Volley</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Material Design 主体环境]]></title>
    <url>%2FMaterialDesign%2FMaterial%20Design%20%E4%B8%BB%E4%BD%93%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[1. 概述Material Design 是一个三维环境，包括了灯光，实体，和投射阴影。所有的实体对象都具有 x, y, z 三个坐标。一个对象只能拥有一个 z 轴位置。（即不允许两个实体重叠）主光源用于制造方向投影，散射光源用于制造柔和阴影。实体厚度： 1dp阴影由重叠实体之间的高低差产生即阴影实际上就是高低差的代表2. 3D 世界Material Design 是一个 3D 世界。这意味着所有的实体都具有 3 个维度的坐标；z 轴垂直对齐于屏幕，正轴指向屏幕外侧。一个实体厚度为 1dp，并独享一个 z 轴坐标。dp = (像素宽度 * 160) / 像素密度在网页端，z 轴是用来分层而不是用来展示视角，z 轴的坐标通过操作 y 轴来模拟实现。3. 灯光和阴影在环境中，虚拟光源营造出了场景。主光源用于投射方向投影，而散射光源用于在各个角度投射柔和的光影。在环境中的阴影由以上这两种光源来实现。在 Android 开发中，阴影的产生是因为光源被不同 z 轴坐标上的实体遮挡。在网页开发中，通过调整 y 轴来进行仿真实现。下面是一个标高为 6 dp 的实体的例子。直射光源投射的阴影散射光源的阴影两种光源的混合投影]]></content>
      <categories>
        <category>MaterialDesign</category>
      </categories>
      <tags>
        <tag>MaterialDesign</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Randomized Queue Implemetation Idea]]></title>
    <url>%2FCoursera%2FAlgorithm%2FRandomized%20Queue%20Implemetation%20Idea%2F</url>
    <content type="text"><![CDATA[How to check full &amp; empty?[x] Maintain a item size[ ] Calculate from pointerHow to resize?Create a new arrayIterate the item in the origin arrayAssign the new array to the old oneHow to iterate?Initialization: begin at headNext: iterator = (iterator + 1) % array.lengthHasNext: iterator != last + 1How to add?Check if is full, if so, double its sizelast = (last + 1) % array.lengthPlace the item into the new last index positionHow to remove?Generate a random integer within the range [0, Size)Turn it to the index randomInt + headSwap the item of that index with the headDequeue]]></content>
      <categories>
        <category>Coursera</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Coursera</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AsyncTask with Callback]]></title>
    <url>%2FAndroid%2FAsyncTask%20with%20Callback%2F</url>
    <content type="text"><![CDATA[1. 定义一个用于回调的接口123public interface TaskListener &#123; void onResult(Object result);&#125;2. 添加 Listener 作为 Task 的类成员12345678class Task extends AsyncTask&lt;Void,Void,Object&gt; &#123; private TaskListener taskListener; public void setListener(TaskListener taskListener) &#123; this.taskListener = taskListener; &#125;&#125;3.通过接口成员调用其方法为保证线程安全，应该在 Task 的 onPostExecute() 方法中完成该操作123protected Object onPostExecute(Object result) &#123; taskListener.onResult(result);&#125;4. Activity 实现该接口处理回调数据12345678910public class MainTread extends Activity implement TaskListener&#123; //your stuff Task task = new Task(this); task.execute(); @Override public void onResult(Object result)&#123; //UPDATE YOUR UI HERE &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[地库 API]]></title>
    <url>%2FProjects%2FBigInovation%2F%E5%9C%B0%E5%BA%93%20API%2F</url>
    <content type="text"><![CDATA[Global rulesRequestRequests are MOSTLY without body, just METHOD /exampleSome request may need sending a JSON. The JSON MUST be put in HTTP bodyResponseAll responses MUST be transported using JSON object as bodyAll responses MUST contain status as below&quot;success&quot; MUST exists, type: boolif &quot;success&quot; == false, you CAN get error message via &quot;error_msg&quot;: &quot;str&quot; and &quot;error_id&quot;: intThe response content MUST be stored in the result element of object typeExample:123456&#123; &quot;success&quot;: true, &quot;result&quot; : &#123; .... &#125;&#125;12345&#123; &quot;success&quot;: false, &quot;error_msg&quot;: &quot;error description&quot;, &quot;errro_id&quot;: 23333&#125;Map APIsCreate a new map IDRequest:POST /mapResponse:123&#123; "id": 1212&#125;Update: 2016-10-14Request:PATCH /map/&lt;id&gt;12345&#123; "desc": "str of description", "lon": 2.333333, "lat": -23.33333&#125;Response: (empty JSON object)12&#123;&#125;Upload map GeoJSONRequest:PUT /map/&lt;id&gt;/geojson1&lt;GeoJSON content&gt;Response: (empty JSON object)Get map GeoJSONRequest:GET /map/&lt;id&gt;/geojsonResponse:1&lt;GeoJSON content&gt;Get nearest map IDRequest:GET /map/near/&lt;lat&gt;/&lt;lon&gt;Response:1234&#123; "id": 233, "distance": 1212.2&#125;distance is the distance of your position and map by metersDelete mapRequest:DELETE /map/&lt;id&gt;Response: (empty JSON object)]]></content>
      <categories>
        <category>工程</category>
        <category>大创</category>
      </categories>
      <tags>
        <tag>工程</tag>
        <tag>大创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 14.04 LTS Installation Checklist]]></title>
    <url>%2FLinux%2FUbuntu%2014.04%20LTS%20Installation%20Checklist%2F</url>
    <content type="text"><![CDATA[1. IntroThis is the installation checklist of the lastest Ubuntu LTS version: Ubuntu 14.04 LTSThe reason of choosing Ubuntu is that the Ubuntu has the least problems with my hardware.Actually, it’s only the Wireless Issue exist.2. Before InstallBackup all the proxy settings and the other software settings which cannot be synchronized.Design the harddrive parttitionThe /boot, /, /swap and the /home3. System ConfigurationChange software source to mainland ChinaIn my home, the aliyun’s software source seems better.In my school, the bjtu’s software source seems better.Upgrade softwareThe Ubuntu Software Center will automatically upgrade the softwares.Or, you can usesudo apt-get update: 2016-10-14 sudo apt-get upgradeto upgrade the softwares.Install fcitx input method frameDue to the account of my baidu is Chinese.So I need to install the fcitx first to get the shadowsocks server infoCheck this post for detailsTelegram seems not support super + space as the switch shortcut.Remenber use a secondary switch shortcut as ctrl + super + spaceFix the Wireless Issue of RTL8723BENeed to install vim at firstThis is the model of my Wireless Network Adapter.It has a issue of network connection in Ubuntu.The way how to fix is open the/etc/modprobe.d/rtl8723be.confif it doesn’t exsit, create it.And add such line in it:options rtl8723be fwlps=N ips=NAnd then reboot, it will fix this problemCheck this post for details.4. The necessary softwaresInstall shadowsocksThe GUI client of linux is the shadowsocks-qt5Install Google ChromeI don’t know somehow the original firefox bulit in the system cannot play song of the neteasy cloud music.So, install the Chrome is necessary.Install LastPassI store most of my passwords in the LastPass, including the Google account.Install git and the bulid-essntial packageFor the development needsInstall zsh and oh-my-zshThe best shell I have ever seenInstall spf13-vimThe spf13 vim has problem of neocomplete plugin, but it’s still the best _vimrc.Maybe the k-vim will be better.5. EntertainmentThe entertainment is almost the Kancolle game.Install the ShimakazeGoPrerequisites:mono, openssl, libssl-dev, libssl0.9.8, p7zip-fullThe openssl is built in the system.The p7zip-full is the command line version of 7zInstall the poiPrerequisites:electron, nodejs, npmThe npm is the bulit-in module of nodejsInstall nodejs:Download the archive and add it to the PATH in ~/.zshrcNotes for npm:The origin registry is extremely slow.Recommand to change it to the http://registry.cnpm.org6. Java &amp; Jetbrains’ IDEsUsing the oracle’s Java is recommended.use`sudo update: 2016-10-14This step should fix the Android SDK Manager not responding in Android StudioEnviroment Variable:For command line program, define it at ~/.zshrcFor desktop entry: Define at /etc/enviromentJava Enviroment Settings Procedure: (in /etc/enviroment)Set JAVA_HOME (not include the bin/)Set CLASSPATH (normally the lib/ folder in $JAVA_HOME)Add $JAVA_HOME to $PATHAndroid StudioPrerequisites:See this answer in StackOverflow.Android SDK Manager:It seems a issue that I cannot lanuch the standalone SDK Manager in Android Studio.It wired, by far I have no idea how to solve it.But the bulit-in manager works fine, so it’s not so important at this moment.7. Desktop EntryThe desktop entry of per user store in~/.local/share/applicationsThe format of desktop entry is :1234567[Desktop Entry]Name= # The name of the app, use camercal caseIcon= # The iconExec= # The execute path, must be absolute pathType=ApplicationTerminal=falseCategories= # The categories8. FontsBy far, the font settings seems acceptable.As follow:My Unity Fonts SettingsDefault FontDroid Sans RegularDocument fontDroid Sans RegularMonospace fontMeslo LG S for Powerline RegularWindows fontUbuntu monoTerminal fontMeslo LG S for Powerline RegularMy Chrome Fonts SettingsStandard fontWenQuanYi Micro Hei 15pxSerif fontDroid SerifSans-serif fontDejaVu SansFixed width fontMeslo LG S for PowerlineSpecial: Jetbrains’ IDEs using Robono Mono for powerline]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大创项目——地下停车场导航]]></title>
    <url>%2FProjects%2FBigInovation%2F%E5%A4%A7%E5%88%9B%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94%E5%9C%B0%E4%B8%8B%E5%81%9C%E8%BD%A6%E5%9C%BA%E5%AF%BC%E8%88%AA%2F</url>
    <content type="text"><![CDATA[1. 平面图构建人群识别技术照片分析技术SMF 和消失点检测图片平滑处理2. 室内定位三角定位Benchmark Image 是否有来源？3. 载具追踪与导航手机姿态检测机器学习方面（蒙特卡洛框架）3D 模型 -&gt; 1D 模型4. 项目架构4.1 模块关系]]></content>
      <categories>
        <category>工程</category>
        <category>大创</category>
      </categories>
      <tags>
        <tag>工程</tag>
        <tag>大创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[室内定位部分]]></title>
    <url>%2FProjects%2FBigInovation%2F%E5%AE%A4%E5%86%85%E5%AE%9A%E4%BD%8D%E9%83%A8%E5%88%86%2F</url>
    <content type="text"><![CDATA[1. 目的随着我国汽车拥有量的上升，地库的数量、车位也在不断地增多。虽然这仍然不能满足人们的需求，但是立体化，大型化，复杂化的发展趋势，使得地库的环境越来越复杂和多样化，成为了限制地库应用效率提高的主要瓶颈。现代大型地库的停车位数超过400个。以上海浦东96广场为例，地下车库建筑面积超过20000㎡。一份网络上针对车迷（都市固定居民）的调查显示，约40% 的人无法准确在地库中找到自己的车辆。而这个比例在普通人群中将会更高。而随着寻车难和泊车难的不断出现和我国的城市化进程不断发展，更为复杂的地下停车系统将会越来越多的出现于城市之中。所以我们需要让人们在最短的时间内寻找到自己的车辆。同时，快速而准确地地下（室内）车辆定位技术也是地库车辆导航的技术支撑点，如果不能准确定位当前车辆的所在位置，地库的导航规划就无法开展，在停车场的逆向寻车更是无从谈起。2. 国内外现状目前的室内定位技术由于室内缺乏 GPS 信号的引导，主要分为两类：（一）无线技术无线技术包括许多不同种类的技术类型，但其主要的原理都为利用现有的广播通信设备来进行室内定位。基于 WiFi 的定位系统基于 WiFi 的定位系统主要是通过测量用户设备到几个不同的接入点的信号强度，通过信号的衰减程度，并结合设备的广播模式来进行定位&lt;span class=”hint—top-right hint—error hint—large” aria-label=”“Indoor Localization Using Improved RSS-Based Lateration Methods” Yang, Jie; Chen, Yingying (2009-11-01)”&gt;[1]&lt;/span&gt;&lt;/a&gt;。同时也有通过测量信号强度，生成一个相关数据（称为 WiFi 指纹），当位置移动时，比对数据，找出相似度最高的数据解析后进行定位[2]但是，由于 WiFi 信号的衰减模型不确定，特别是在大型，立体化等复杂的地下车库和停车场中，由于存在行驶的汽车，使得信号的衰减呈现出动态随机的，使得定位的精度和可靠性较差。基于蓝牙、手机信号等大部分无线信号的定位系统基于蓝牙和其他无线信号（如 GSM/CDMA 等手机电信信号），由于信号穿透力不强，或地库系统过于复杂导致的信号覆盖率差，设备部署难等问题，其普遍的定位精度和可靠性都不是很高&lt;span class=”hint—top-right hint—error hint—large” aria-label=”Survey of Wireless Based Indoor Localization Technologies Junjie Liu (2014-05-05)”&gt;[3]&lt;/span&gt;&lt;/a&gt;基于被动式射频识别的定位系统被动式的射频识别系统通过在室内设置一些被动式射频识别设备，在接收到足够强的信号后，通过向读取器发送数据来向车辆反馈当前位置。被动式射频设别较为便宜，但由于射频信号的特点，需要较为狭窄的通道才能达到良好的定位效果，这在一些较为广阔的地下停车场适用性不强。同时，由于地下车库的立体化发展，当车辆在向下运动的过程中，射频定位就起不到相应的效果。（二）非广播技术非广播技术是指不依靠现有的广播通信设备来进行室内定位的技术。磁场定位技术磁场定位技术是利用手机等移动设备的磁场感应器来获取磁场数据（包括建筑本身的磁场数据和地磁数据），从而进行室内定位的技术。由于其摆脱了对广播信号的依赖，较为适用于一些没有或者广播信号较为衰弱的场所。但是，在 2012 年的室内定位和室内导航（IPIN）的国际峰会上，Binghao Li， Thomas Gallagher， Andrew G Dempster，Chris Rizos 共同发表的一篇文章&lt;span class=”hint—top-right hint—error hint—large” aria-label=” How feasible is the use of magnetic field alone for indoor positioning? Binghao Li， Thomas Gallagher， Andrew G Dempster，Chris Rizos (13-15 Nov. 2012)“&gt;[4]&lt;/span&gt;&lt;/a&gt;指出，室内的磁场会受到移动的金属物体的干扰。在大型地下停车场中，存在着较多的行驶的汽车和移动的升降梯，此时，仅仅依靠磁场定位的效果不良好。惯性定位技术惯性定位技术即使用移动设备的加速度感应器，获取物体的加速度信息，并通过速度和位置推算，从而进行室内定位的技术。这种技术只能在物体移动时才能起到效果，在车辆停止时，由于缺乏加速度信息，因而无法进行位置推算。3. 问题求解基于我国目前城市中地下车库不断大型化，立体化，复杂化，同时，我国的电信建设仍有不足，地下深层停车场的手机信号差等特点。地下车库的车辆定位应摒弃蓝牙和手机信号等定位技术的使用。基于上述特征，和目前现有技术的优缺点，我们决定通过智能手机中丰富的传感器资料，采用多种技术来进行地下车辆定位和相互验证。当车辆在地库某一层时，通过获取气压和磁场数据，并结合贝叶斯算法从而确定车辆所在的地库层数，通过射频识别技术来获取大概位置，并通过结合磁场技术和加速度检测等惯性技术来对位置进行校正。当车辆在行驶时，通过使用手机的加速度等传感器，在经过手机的姿态检测处理，消除手机姿态误差后，使用位置推算、路标和减速带碰撞处理等技术，并结合线性蒙特卡洛生成树算法来对车辆进行实时追踪演算，对原有定位数据进行校正。当车辆进行转弯、上下层等运动时，通过采集手机的陀螺仪和气压变化和磁场变化数据判断车辆当前所进行的动作和位置。1.&quot;Indoor Localization Using Improved RSS-Based Lateration Methods&quot; Yang, Jie; Chen, Yingying (2009-11-01) ↩2.P. Bahl and V. N. Padmanabhan, “RADAR: an in-building RF-based user location and tracking system,” in Proceedings of 19th Annual Joint Conference of the IEEE Computer and Communications Societies (INFOCOM ’00), vol. 2, pp. 775–784, Tel Aviv.Israel, March 2000. ↩3.Survey of Wireless Based Indoor Localization Technologies Junjie Liu (2014-05-05) ↩4.How feasible is the use of magnetic field alone for indoor positioning? Binghao Li， Thomas Gallagher， Andrew G Dempster，Chris Rizos (13-15 Nov. 2012) ↩]]></content>
      <categories>
        <category>工程</category>
        <category>大创</category>
      </categories>
      <tags>
        <tag>工程</tag>
        <tag>大创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My Linux Experiences]]></title>
    <url>%2FLinux%2FMy%20Linux%20Experiences%2F</url>
    <content type="text"><![CDATA[Linux Mint Installation Notes1. Using the USB bootDo not use the hard disk boot option, it will cause a lot of problems.As I am known, if you do that, the battery will be some weird problems.2. PartitionYou could do the patition base on your needs, or follow the advice in the Internet.Normally, I just use /, /boot, /home and /swap parts.Maybe the /usr needs to mount into another space, for what the software is almost install bythe package manager.(such as apt-get)3. Dual BootThis is extremely important,(for me ,because I still can not leave the big game which is only can be run in Windows)If you want to have the bennifits from each of these OS3.1 Single Hard DiskThat’s nothing to say about, if only have one hard disk,you must be care of the order of the installation,because the first installed boot loader will be covered by the secound.3.2 Dual or Multiple Hard Disksyou need to be awared of the boot loader’s position,because if you install them into the same disk, the latter will cover the formerI recomend to use the Win to load the Linux, because the linux is actually a bit annoying,you need to reinstall the system for many times at the very first time. If you use the grup toboot the Win, when you need to reinstall the linux, it will be difficult to do it.Improtant: Use the USB driver to install the Linux, do not just use the hard driver to install. Keep the USB driver, it will be more convient to REINSTALL the systemThe install position of the boot loaderThe position must contain the name of the hard disk.That is, you need to install it into /dev/sda or the /dev/sdbnot the hard driver which has number with it.If you want to let the Win to boot the linux, just place the boot loader intowhere the Windows C driver is not in it.I have two hard disks, and my Windows C driver place in the SSD, if I want touse win to load the linux, I just place it into the HDDIf you want to do the oppsite, just let the Linux to boot the Windows, you need to installthe boot loader into the same disk which the Windows c driver has been installed.Supplement for Linux boot WindowsDO NOT FORMAT THE LINUX PARTITION IN WINDOWS!!!if so, the two systems will not be able to start neither.4. ProxyNormally, I only use the socks proxy, but also the http proxy,so, what I am using is the Shadowsocks + Privoxy to build up thesocks proxy and the http proxyDown Shadowsocks-qt5 or install it by ppaUsing the apt-get to install PrivoxyEdit the /etc/privoxy/config for the configuration.To enable the socks config, just edit the1forward-socks5 / host:port .Usually, it will be1forward-socks5 / 127.0.0.1:1080 .Do remenber the &lt;space&gt; of the port and the . is necessaryUse the IP instead of the localhostDefaultly, the HTTP listen port is 8118Using the following command to start an service of the privoxy1sudo service privoxy restartRemember it’s restart not the start,sometime, the start won’t work.And the socks proxy is 127.0.0.1:1080, the http proxy is 127.0.0.1:81185. Enviroment VariablesNormally, the enviroment variables could be define and edit in the~/.*shrc, now I am using Zsh,so the file is .zshrc,normally, it will be .bashrcDifferent from Ubuntu, when you need to run a program from the desktop enviroment,such as IntillJ IDEA, you need to edit the ~/.profile to define the enviroment variables,such as JAVA_HOME6. About the unable to run &quot;mate-settings deamon&quot;It might be cause by the incorrect NVIDIA driver,use the default is just fine.Do not change the NV driver from the driver manager.7. About my battery problemsIt might due to some weird problems,if the battery cannot be reconized, try to installacpi, it might be some help.Actually, I not quite sure.8. ZshFollowing the instruction of robbyrussell/oh-my-zshto install the zsh is ok, and don’t forget to install oh-my-zsh to customze the zshTo enable the agnoster bulit-in theme of theoh-my-zsh, need to install the Powerline-patched font, justuse the install.sh is okay.And after that, change the terminal font to which has the powerline suffix.9. VimThe vim is almost the biggest problem for me.After hours of hours test, I found a config that is suit with me.What I use it the spf13/spf13-vim + suan/vim-instant-markdownfor supporting my vim usage and do the notes.Just follow the instruction in each repo, that is okay.Supplements:Change the theme of the status line in spf13-vimThe status line is using the ariline, the instruction is place athttps://github.com/bling/vim-airline/wiki/FAQ,click the Screenshot, it will list its themes and the theme name.What I like is the badwolf.Add MathJax support for the vim-instant-markdownSee this issueKnown Issue:The vim-instant-markdown will remain the chrome tab when the vim is leave.]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络模块使用方法]]></title>
    <url>%2FProjects%2FBigInovation%2F%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[调用步骤1. 获取 ApiServices通过 ApiManager.getServices() 获取 Apiservice 实例。1ApiServices services = ApiManager.getServices();2. 通过 ApiServices 获取对应 API 的 Call 对象第一步中获取到的 ApiServices 是 ApiServices 接口的实例化对象。通过调用其接口所定义的方法，获取对应网络 API 的 Call 对象1Call&lt;Response&gt; call = services.uploadMapGeoJsonCall(id, geoJsonObject);对应的网络 API 及其说明请查看相应的后端文档。3. 通过 Call 对象的方法来执行任务。获取到 Call 对象并不意味着开始执行任务，需要调用 Call 对象的对应方法来开启这一个网络请求任务。执行 Call 任务的方法有两个异步方法 推荐！！1call.enqueue(new CallBack());同步方法1call.execute();最好通过异步方法来开启任务。4. 在 CallBack 中对结果进行响应。4.1 onResponse() 方法onResponse() 方法用来处理连通网络后的返回结果，包括 200 结果和其他 5xx，4xx 结果。本项目对任何可 handle 的结果均返回 200 ，请务必通过 body 中的 isSuccess(), getErrorMsg() 来获取真正的网络响应状态。4.2. onFailure() 方法这个方法会回调任何的网络无法连通，body 解析错误的返回结果。]]></content>
      <categories>
        <category>工程</category>
        <category>大创</category>
      </categories>
      <tags>
        <tag>工程</tag>
        <tag>大创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Gradle 介绍]]></title>
    <url>%2FAndroid%2FAndroid%20Gradle%20%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[1. 简介Android Studio 使用 gradle 自动化编译工具用于替代老旧的 Ant Build。目前已经成为 Android App 构建的主流工具。本篇文章简单介绍了 Android Gradle 的有关配置段和相关的简介。Gradle 工具通过读取 build.gradle 文件的配置来对工程进行构建，同时，工程中的每一个分模块都有相应的 build.gralde 文件。2. 顶层文件（Top-Level）顶层的 build.gradle 存储在工程根目录，定义一些用于所有模块的属性和设置。其中包括12345678910111213141516171819202122232425262728293031323334353637/*** buildscript&#123;&#125; 是用于 gradle 自身的配置，在构建工程时，gradle 会首先读取构建必要的依赖用于构建工程。* 不要将 APP 用的依赖项加到这里来！* 通常包含 respositories&#123;&#125; 和 dependencies&#123;&#125; 块。*/buildscript &#123; /** * 这个区块是定义 gradle 寻找所有依赖项的 Java 包库。 * 默认为 jcenter。 * 也可以添加一些自己的库进去。 * * 由于 jcenter 是 MavenCentral 的超集，所以直接使用 jcenter 即可 */ respositories &#123; jcenter() &#125; /** * 这个区块是 gradle 构建用的依赖项，android 工程中， * 一般是与 AS 版本号对应的 gradle 版本。 */ dependencies &#123; classpath 'com.android.tools.build:gradle:2.2.0' &#125;&#125;/*** allprojects&#123;&#125; 区块用于定义所有模块构建共用的代码库和依赖项。* 原则上应在各模块对应的 build.gradle 设定相应的代码库和依赖项。* Android Studio 默认配置了 jcenter() 作为默认的代码库。*/allprojects &#123; repositories &#123; jcenter() &#125;&#125;3. 模块级别文件在各个模块的根目录中，也有对应的 build.gradle 文件，它是用来配置各个模块各自的编译构建项的，也是我们最常修改的文件。1apply plugin: 'com.android.application']]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树]]></title>
    <url>%2FAlgorithm%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[1. 二叉树的定义二叉树是一种每个节点最多只能有两个子节点的树树是一种没有环的连通图在最顶层的节点叫做根节点没有子节点的节点叫叶节点，有子节点的节点叫做内部节点2. 二叉树的类型2.1 满二叉树国内定义：除了最后一层没有子节点以外，其他每一层的节点都有两个子节点节点数和深度满足如下关系：N_{leaf} = 2^{h} - 1国外定义 : 只有叶节点和度为 2 的节点的树就叫满二叉树（在国内一般用国内定义（笑））2.2 完全二叉树至多只有最下面的两层上的节点的度数可以小于 2，并且最下层的节点都在最左边的若干位置上。满二叉树：完全二叉树:3. 实现3.1 数组实现这种实现方法就是按照完全二叉树的形式将节点置于相应的数组单元之中。所以，如果一个节点的索引是 $k$，那么，它的父亲的索引是 $\lfloor k \rfloor$；它的左子结点的索引是 $2k$，右子结点的索引是 $2k + 1$这种实现方式最适合于完全二叉树，如果一个不完全的二叉树使用这种方法实现，会浪费许多的空间。3.2 链表实现相对于数组来说，使用链表实现能节省更多的空间。它的节点由三部分组成：数据域，左子结点指针，和右子结点指针Node:leftChilddatarightChild4. 遍历算法一般来说，有三种方法可以遍历一个二叉树，它们是：先序遍历（$DLR$）中序遍历（$LDR$）后序遍历（$LRD$）它们都属于深度优先遍历方法注意，只有三种方法的前提是左子结点比右子结点大，如果抛弃这个前提，则有至多六种方法4.1 深度优先遍历所谓的深度优先，指的是，优先搜索子孙节点，而不是优先搜索兄弟节点4.1.1 先序遍历访问根节点递归访问左子节点递归访问右子结点4.1.2 中序遍历递归访问左子结点访问根节点递归访问右子结点4.1.3 后序遍历递归访问左子结点递归访问右子结点访问根节点4.2 广度优先所谓的广度优先，就是优先访问兄弟节点，而不是子孙节点直到当前层访问完成前，都不进入下一层进行遍历一般使用队列来实现这种访问策略1234567891011121314151617181920212223interface Visitable&lt;Item&gt; &#123; void onVisit(Item item);&#125;class BreadthFirst &#123; Visitable&lt;Node&gt; visiter; .... void breadFirstTraversal(Node root) &#123; Queue q = new Queue(); q.enQueue(root); while (!q.isEmpty()) &#123; Node node = q.deQueue(); visiter.onVisit(node); if(node.lChild != null) &#123; q.enQueue(node.lChild); &#125; if(node.rChild != null) &#123; q.enQueue(node.rChild); &#125; &#125; &#125;&#125;5. 线索二叉树线索二叉树指的是，当我们使用链表来实现一个二叉树时，使用一些节点的空的指针域来储存相应遍历策略的前一个或者后一个节点。从而起到方便遍历和提高空间利用率的作用。需要注意的是，一个线索二叉树是和它采用的访问策略相关的，同一个二叉树采用不同的访问策略，其对应的线索二叉树也会不同。5.0 调整数据结构为了建立一个线索二叉树，我们需要对节点的数据域进行一些调整。增加了两个指示是否是子节点的 flagThe Threaded Binary Tree Node:boolean leftFlagleftChildDatarightChildboolean rightFlag6. 二叉树和森林6.1 森林的定义森林是由多个独立的二叉树组成的数据结构我们可以通过连接他们的根节点来构造一棵大型的树6.2 森林的表示法为了能在物理上表示一个森林，我们首先会将其变成一棵大型的树，仅仅将它们的根节点连接起来即可。6.2.1 孩子兄弟表示法首先这个适用于链表实现的树。森林的节点由三部分组成：数据域左子结点指针右边的兄弟节点指针Node:leftChildDatabrother既然，这个节点含有的域和一个二叉树的节点含有的域的数目和类型都是相同的。那么我们就可以在物理结构上将其认为是一个二叉树；这为我们提供了很大的便利性，由于森林可以转换为树，而任何的树都可以通过孩子兄弟表示法来转换为二叉树。所以我们可以使用二叉树的遍历方法来对任何的树形结构进行遍历。7. 哈夫曼树哈夫曼树，也被叫做最优二叉树，是一种最小边权的加权二叉树7.1 特点相同权重的哈夫曼树不是唯一的哈夫曼树的子树可以随意调换，这个调换并不会影响到它的长度具有权重的节点都是叶节点，其余节点的权重都是通过叶节点的权重相加得到的拥有最大权重的节点，最靠近根节点哈夫曼树没有度为 1 的节点一个拥有 $N$ 个叶节点的哈夫曼树，拥有 $2N - 1$ 个节点7.2 构造将给出的加权节点置于一个集合中从中选出 2 个最小权重的节点，将他们的权重相加，得到一个新的节点作为它们的根节点。将这两个节点从集合中去除，同时将那个根节点加入到集合中重复步骤 2 和 3，直到这个集合为空例如，假如我们有 5 个加权的节点根据上面的步骤，我们可以得到如下的树：或者如下的树：注意，具有相同权重的哈夫曼树不是唯一的。7.3 应用：哈弗曼编码哈夫曼编码是基于字词的使用频率对其赋予权重，使用哈弗曼树来减少编码大小的一种技术。由于哈夫曼树的权重最大（频率最为频繁）的节点最靠近根节点，所以它能显著减少编码所需要的体积综上所述，我们定义左斜的边为 $0$，右斜的边为 $1$，那么，上面的哈夫曼树对应的编码为：5 = ‘11’4 = ‘10’3 = ‘00’2 = ‘011’1 = ‘010’注意，这样的定义是为了不出现识别冲突]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高等数学 下]]></title>
    <url>%2FReviews%2FAdvancedMathmatics%2F%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[1. 级数1.1 收敛半径和收敛域的计算1.1.1 收敛半径的计算对于级数 $\sum_{n = 0}^\infty a_nx^n$，如果\lim_{n \to \infty}|\frac{a_{n + 1}}{a_n}| = \rho当 $\rho \gt 0$ 时，收敛半径 $R = \frac{1}{\rho}$当 $\rho = 0$ 时，收敛半径 $R = + \infty$当 $\rho = + \infty$ 时，收敛半径 $R = 0$注意，收敛半径只与只带有 $n$ 的式子有关，即 $a_n$，与 $x$ 无关。1.1.2 收敛域的计算]]></content>
      <categories>
        <category>复习</category>
        <category>高数</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>高数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Automata Theory and Formal Language]]></title>
    <url>%2FReviews%2FAutomata%2FAutomata%20Theory%20and%20Formal%20Language%2F</url>
    <content type="text"><![CDATA[1. Automata1.5 The Central Concept of Automata Theory1.5.1 AlphabetAlphabet is the finite, non-empty Set of the symbolUsing the $\sum$ symbol stand for the Alphabet1.5.2 StringString, sometime called word is a finite sequence of symbols, which choose from the Alphabet.Empty StringIf the string has no symbol, it is empty String, use the $\epsilon$ stand for it.String’s lenthThe number of symbol in the the string called the lenth of the string, use the $|w|$ stand for the lenth of string $w$The power of AlphabetUse the exponent of the Alphabet like $\sum^k$ stand for the Set of string, which lenth is $k$, in $\sum$Notice that $\sum^0 = {\epsilon}$The set of all strings in an Alphabet, use $\sum^*$If remove the $\epsilon$ in the normal Alphabet, the rest is called $\sum^+$$\sum^+ = \sum^0\bigcup\sum^1\bigcup\sum^2\bigcup\dots$$\sum^*=\sum^+\bigcup{\epsilon}$1.5.3 Language]]></content>
      <categories>
        <category>复习</category>
        <category>自动机</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自动机考试]]></title>
    <url>%2FReviews%2FAutomata%2F%E8%87%AA%E5%8A%A8%E6%9C%BA%E8%80%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[填空选择问答1. 绪论1.1 语言和形式语言语言是字集齐组合规则的统一体1.2 字母表字母表是一个非空有穷集合，具有非空性、有穷性字符具有整体性和可辨认性正闭包：$\sum^+ = \sum \cup \sum^2 \cup \sum^3 \cup \sum^4 \cup \cdots$克林闭包：正闭包 $\cup \sum^0$$\sum^* = \sum^0 \cup \sum^+ = \sum^0 \cup\sum \cup \sum^2 \cup \sum^3 \cup \sum^4 \cup \cdots$1.3 句子字符的总个数成为句子的长度，记为$|x|$前缀、后缀，公共前缀、公共后缀与集合中的子集相同两个句子含有同一个串，这个串称为公共子串，如果这个串是最长的，那么称为最大公共子串2. 文法2.1 形式定义文法 $G$ 是一个四元组：G = (V, T, P, S)$V$——变量（variable），$\forall A \in V$，$A$ 叫做语法变量或者非终极符号或者语法范畴$T$——终极符号（terminal）是非空有穷集合。$\forall a \in T$ $a$ 称为终极符号，是组成一个串或者句子的元单位$P$——产生式（production），形式为 $\alpha \to \beta$$S$——$S \in V$，文法 G 的开始符号，表示语言被定义的地方2.2 句型如果可以从开始符号推导出一个串，那么这个串称为 $G$ 产生的一个句型2.3 乔姆斯基体系没有任何限制的文法称为 0 型文法，语言叫做 0 型语言对于 0 型文法，经过产生式后句子长度不减少，叫做上下文有关文法，语言叫做上下文有关语言，也被称为 1 型文法，语言叫做 1 型语言对于 $\forall \alpha \to \beta \in P$，均有 $|\beta| \ge |\alpha|$对于 1 型文法，如果左部都是变量，那么叫做上下文有关文法，语言叫做上下文有关语言，也被称为 2 型文法，语言叫做 2 型语言对于 $\forall \alpha \to \beta \in P$，均有 $|\beta| \ge |\alpha|$，并且有 $\alpha \in V$对于 2 型文法，如果产生式只产生终极符号和终极符号后接变量，那么叫做正则文法，语言叫做正则语言，也叫做 3 型文法对于$\forall \alpha \to \beta \in P$, $\alpha \to \beta$均具有形式：$A \to w$$A \to wB$注：正则文法又叫右线性文法；如果变量在左边就叫左线性文法；两个串中间夹一个变量就是线性文法可以看到，文法的乔姆斯基体系是逐步收紧限制的2.4 推导、归约和文法构造这些都比较简单，慢慢推就行了。构造看结构想想就行了。3. 有穷状态自动机3.1 物理模型有穷状态自动机由以下结构构成：右端无穷输入带有穷状态控制器读头3.2 形式定义有穷状态自动机是一个五元组$M = (Q, \sum, \delta, q_0, F)$$Q$——状态的非空有穷集合，$\forall q \in Q$, $q$ 称为 $M$ 的一个状态$\sum$——输入字母表$\delta$——状态转移函数，读入字符后经过转移函数处理进行状态转移$q_0$——开始状态$F$——终止状态，又称接受状态3.3 DFA对于状态集合中的任何一个状态，状态转移函数均有一个确定的值3.4 NFA形式定义$\delta$——状态转移函数，对于$\forall (q,a) \in Q \times \sum, \delta(q,a) = {p_1, p_2, \cdots, p_m}$其余与 DFA 相同与 DFA 的区别并不是所有在状态集合中的状态对应某个输入都有状态转移函数结果与之对应并不是对于所有的状态转移结果都只对应一个状态3.5 $\epsilon-NFA$形式定义对$\forall q \in Q, \delta (q, \epsilon) = { p_1, p_2, \cdots, p_m }$，表示 $M$ 在状态 $q$ 不读入任何字符的情况下也能选择进行状态转移3.6 补充FA 接受的语言是正则语言4. 正则表达式4.1 形式定义$\varnothing$ 是 $\sum$ 上的正则表达式，表示语言$\varnothing$$\epsilon$ 是 $\sum$ 上的正则表达式，表示语言 ${ \epsilon }$对于$\forall a \in \sum , a$ 是 $\sum$ 上的正则表达式，它表示语言 ${ a }$如果 $r$ 和 $s$ 分别是 $\sum$ 上的表达语言 $R$ 和 $S$ 的正则表达式，那么$(r + s)$ 表达的语言是 $R \cup S$；$(rs)$ 表达的语言是 $RS$；$(r^)$ 表达的语言是 $R^$只有满足以上四条，才是正则表达式5. 正则语言的性质5.1 封闭性RL 在交、并、补，乘积、闭包运算都是封闭的5.2 Myhill-Nerode 定理如下三个命题等价：$L \subseteq \sum^*$ 是 RLL 是 $\sum^*$ 上的某个具有有穷指数的又不变等价关系 R 的某些等价类的并$R_L$ 具有无穷指数6. 上下文无关语言6.1 二义性对于 CFG $G = (V, T, P, S)$，如果存在 $w \in L(G)$，$w$ 至少有两颗不同的派生树，则称 $G$ 为二义性的，否则则为非二义性的如果语言 $L$ 不存在非二义性文法，则称 $L$ 为固有二义性的，或者先天二义性的6.2 乔姆斯基范式（CNF）形式定义：如果 CFG $G = (V, T, P, S)$中的所有产生式都具有形式：A \to BC \\ A \to a则称为乔姆斯基文法或者乔姆斯基范式6.3 格雷巴赫范式形式定义：如果 CFG $G = (V, T, P, S)$ 具有形式A \to a\alpha则称 $G$ 为格雷巴赫范式文法，简称格雷巴赫范式7. 下推自动机7.1 物理模型下推自动机有三个基本结构：存放输入符号串的输入带存放文法符号的栈有穷状态控制器7.2 形式定义下推自动机是一个七元组：$M = (Q,\sum, \Gamma, \delta, q_0, Z_0, F)$$Q$——状态集合$\sum$——输入字母表$\Gamma$——栈符号表$\delta$——状态转移函数$q_0$——开始状态$Z_0$——开始符号$F$——终止状态8. 上下文无关语言性质8.1 封闭性交运算、补运算不封闭并、乘积、闭包运算封闭9. 图灵机9.1 物理模型基本模型包括：有穷状态控制器（FSC）含有无穷多个带方格的输入带读头9.2 形式定义图灵机是一个七元组：$M = (Q, \sum, \Gamma, \delta, q_0, B, F)$$Q$——状态集合$\sum$——字母表$\Gamma$——带符号表，如果$\forall X \in \Gamma$, $X$ 为 $M$ 上的一个带符号，表示在 $M$ 的运行过程中， $X$ 可以在某一时刻出现在输入带上$\delta$——转移函数$q_0$——开始状态$B$——空白符$F$——终止状态9.3 即时描述$TM\ M = (Q, \ \sum, \ \Gamma, \ \delta, \ q_0, \ B, \ F), a_1a_2 \in \Gamma^*, q \in Q, a_1a_2$称为 $M$ 的即时描述10. 上下文有关语言10.1 线性有界自动机的形式定义线性有界自动机是一种非确定的图灵机，满足如下两个条件：输入字母表($\sum$) 中包含两个人特殊的符号 (打不出来，C 画一条斜线) 和 $$$， 其中，（C 画一条斜线）作为输入符号串的左端标识，$$$，作为输入符号串的右端标识LBA 的读头只能在上面两个符号之间移动，而且 LBA 不能在上面两个断点符号上面打印另外一个符号LBA 可以被看做一个八元组，其接受的语言为：线性有界自动机和上下文有关文法等价大题大题考点[x] $\epsilon$-NFA 转 NFA[x] NFA 转 DFA[x] 正则语言转 FA[x] DFA 转正则语言[x] 泵引理证明一个语言不是 RL[x] DFA 极小化[x] 上下文无关语言的文法化简[x] 泵引理证明一个语言不是上下文无关语言1. $\epsilon$-NFA 转 NFA步骤：先找空闭包（包括它本身），得到一个集合寻找这个集合的对于某个特定输入的转移，得到另一个集合对于 2 的集合寻找其空闭包（包括它本身），得到第三个集合第三个集合即为某个状态对于上面的特定输入的状态转移找出所有非空输入的状态为止2. NFA 转 DFA步骤：由 NFA 的初始状态出发，找出初始状态对应输入的集合由对应的输入集合出发，继续根据输入写出对应的转移重复 2 直到找完所有集合为止含有终止状态的集合均为终止状态勾出可达状态。可达状态即为从初始状态能到达的所有状态集合3. 正则语言转 FA3.1 DFA 转正则文法由 $q_s$ 开始状态开始根据输入和相应的转移状态写文法每一个转移对应文法为：输入，状态（没有逗号）如果转移到终止状态，则写终止符号终止符号为转移到终止状态的输入如果终止状态有闭包，则除了终止符号外，还要加上相应的 【输入，状态】终止状态有转移则写终止状态，没有则不用写如果有不可达状态，写出之后要删去不可达状态即只能写出自身闭包的文法3.2 正则文法转 FA根据相应文法写出状态转移函数即可引入一个终止状态 $Z$根据文法写出状态转移函数形式如下：$\delta($变量，输入$)$ $=$ ${$转移后状态$}$例如：$E \to 0A$$\delta(E,0) = {A}$如果遇到终止符号，则在右方集合中写上终止状态$Z$例如：$A \to 1|1C$$\delta(A,1) = {Z,C}$3.3 正则表达式转 FA分析结构，有以下几种状况遇到加号就分叉乘号在后面加一段相应字符的转移克林闭包意味着循环和可跳过正闭包意味着循环和至少需要经过一次（即不可跳过）最后合并到终止状态3.4 DFA 转正则表达式根据 DFA 的图转换成正则表达式预处理用状态 $X$ 和 $Y$ 将图“括起来”$X$ 用空转移指向初始状态，所有的终止状态用空转移指向 $Y$去掉所有的不可达状态并弧将两个状态的平行弧（方向一致），或者有逗号的，将其输入用加号连起来去掉点对于到达 $Y$ 的路径，将输入拼起来即可关于消去这个点之后，将其他经过这个点到达的路径的输入拼起来如果有闭包，则在对应的输入上使用克林闭包如果除了 $X$ $Y$ 只有一种状态，而且没有经过这种状态从 $X$ 到达 $Y$ 的路径，则将这个点和对应的路径直接删去即可不断重复 2 和 3最后只剩下 $X$ 和 $Y$，则输入则为正则表达式4. 泵引理证明一个语言不是 RL利用泵引理反证法证明一个语言不是 RL利用正整数 $N$ 构造一个特殊的 $z$一般将语言中的未知数替换成 $N$ 即可，有时也需动点脑筋利用 $|v| \ge 1$ 和 $|uv| \le N$ 说明 $v$ 必定为某个式子。式子为符号的幂，下同由 $z = uvw$ 得出 $u$ $v$ $w$ 的对应的式子由 $uv^iw$ 得出化简后的相应式子注意不要消掉 2 中的设定的参数选择一个恰当的 $i$ 说明 4 中的关系和 1 中的关系矛盾证明完成5. DFA 的极小化对于一个 DFA 的图进行简化去掉不可达状态在可区分状态表标记所有终止状态的行和列对于交界的格子，不进行标记对于空的格子，根据相应转移函数算出对应结合相应转移函数：状态集合对应输入所得到的状态集合的函数对于$[q_0,q_4]$，进行 $\delta(q_0,$输入$)$ $\delta(q_4,$ 输入$)$ 来进行所得出的新的两个状态则为相应的转移后状态集合建议先算出所有的转移函数结果如果算出来的集合未被标记，增加到关联表中关联表：算出的新集合 $\to$ 原集合如果新的“原集合”算出一个已经算出过的“新集合”，继续接到后面去注意，以某个集合为起点的关联表才是它的关联表。如果算出来的集合已经被标记了，那么就把它标记，并根据标记的集合的关联表进行递归标记如果根据某个输入得出该组集合已经被标记，就没有必要去看另一组输入的结果了。如果算出的集合跟原集合相等，不进行任何操作如果转移函数得到相等结果，不进行任何操作此时算法结束，根据可区分状态表中没有标记的组，列出来，说明它们恒等如果没有未标记的组，说明当前图已经是最简了根据 $\equiv$ 的传递性进行状态分组恒等的分成一组如果还有落单的状态，另分组分组完毕，根据原图根据分组的状态来画出简化图6. 上下文无关文法的化简步骤：清除无用符号清除 $\epsilon$ 产生式清除单一产生式清除无用符号（如果有的话）6.1 去无用符号先清除非产生的非产生的：从这个符号开始，进行推导不能得出只有终结符号的，被称为非产生的注意含有非产生符号的式子要一并清除再清除不可达的不可达的，即由 $S$ 不能达到的6.2 清除 $\epsilon$ 产生式注意，如果清除之后出现无用符号，那么就应该为它加上某个它自身能推导出来的终结符并考虑到它的可能为空的特性，在上级符号中加入不含这个符号的产生式6.3 清除单一产生式形如 $A \to B$ 即为单一产生式，可以将 $B$ 的内容合并到 $A$ 中。不断重复，直到没有单一产生式为止7. 用泵引理证明一个语言不是上下文无关语言这里的泵引理是 CFL 的泵引理]]></content>
      <categories>
        <category>复习</category>
        <category>自动机</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Computer Organization and Architecture]]></title>
    <url>%2FReviews%2FCOA%2FComputer%20Organization%20and%20Architecture%2F</url>
    <content type="text"><![CDATA[Introduction1.Basic ConceptsArchitecture: such as Instruction set, I/O mechanisms (Visiable to programmer)Organization: such as the Control singals, interfaces, memory technology (NOT visiable to the programmer)Family of computer models(系列机): All with the same architecture but with differences in organization. Such as Intel 286 and Intel 386Organization is the high-level aspect of computer design, Hardware is the specific mechine.The computer system include:HardwareSoftwarePeripheral deviceKeyboard and mouse and so on.The computer consist of:CPU(or processor)Input &amp; OutputMain MemorySystem BusThe CPU consist of:Control Unit(CU)Arithmetic and Logic Unit(ALU)RegistersInternal BusComputer Performance design and assessment1. Designing for performanceThree things affect the performance:Microprocessor speedPerformance balanceImprovements in chip organization and architecture1.1 The Microprocessor SpeedBy adding these things to improve the performance:Branch predictionData flow analysisSpeculative execution1.2 The balance (Balance is the key)With the microprocessor speed increasing rapily refer to the Mooore’s Law, the Memory accessing sppeding is on the contrary, cannot catch the speed of the microporcessor increase.Solutions for memory access:Make DRAM “wider” rather than “deeper”Increase number of bits retrieved at one timeChange DRAM interface (by using cache)Reduce frequency of memory accessmore complex cache and cache on chipIncrease interconnection bandwithHigh speed bueseHierarchy of busesThe I/O devices are much more slow than the memory accessSolutions for I/O devices:CachingBufferingHigher-speed interconnection busesMore elaborate bus structuresMultiple-processor configurations1.3 Imporve the chip O&amp;AIncrease hardware speed of processorPowerRC delayMemory latencyIncrease size and speed of cachesMultiple levels of cachesIncrease the chip densityChange processor organization and architectureEnable parallel execution of instructionsPipeline works like assembly lineSuperscalar allows multiple pipelines within single processorInstructions that do not depend on the other can be executed in parallelSupplement: Using the multiple cores can be more efficiency2. Performance Assessment2.1 Clock SpeedThe clock speed is not every thing2.2 Instruction Execution RateThere are three index of the rate, CPI, MIPS and MFLOPSCPI: The time cycle with one instruction needed (Cycle Per Instruction)MIPS: The number(million) of the instructions within in one second being executed.MFLOPS: Like the MIPS, it is the floating point calculate instruction.CPI = {\frac{\sum_{i = 1}^n(CPI_i \times I_i)}{I_c}}$I_c$ is the number of the instructionThe processing time $T$ is:T = I_c \times CPI \times \gamma$\gamma$ is the constant cycle, which means $1/f$So, the MIPS is:\begin{align} MIPS &= {\frac{I_c}{T \times 10^6}} \\ &= {\frac{f}{CPI \times 10^6}} \end{align}MFLOPS = {\frac{Number \ of\ execute\ floating-point\ operations\ in\ a\ program}{Execution\ time \times 10^6 }}2.3 Amdahl’s LawThe speed up rate between the single core machine and the multiple cores machine.\begin{align} Speedup & = {\frac{time\ to\ execute\ program\ on\ a\ single\ processor}{time\ to\ execute\ program\ on N\ parallel\ processors}} \\ & = {\frac{T{(1 - f)} + Tf}{T{(1-f)} + {\frac{Tf}{N}}} } \\ & = {\frac{1}{(1-f) + {\frac{f}{N}}}} \end{align}$f$ refer to the code infinitely parallelizable with no scheduling overhead.$(1-f) of code inherently serial$$T$ is the total execution time for program on single processor$N$ is number of processors that fully exploite parallel portions of codeConclusion:$f$ small, parallel processor has little effect$N \sim \infty$, the speedup bound by $1/(1-f)$2.4 SupplementSome important terminology:Bit is the binary digit rather 0 or 1.A byte is defined as 8 bitsA word is a set of bits constituting the samllest unit of addressable memoryA kilobyte (KB) is $2^{10}$ bytes.A megabyte (MB) is $2^{20}$ bytes.A gigabyte (GB) is $2^{30}$ bytes.Computer System1. Computer ComponentsCPUPC: programming counter, store the next instruction’s address.IR: instruction register, store the instructionMAR: the memory address register, exchange data with the main memoryI/O AR: input and output address registerI/O BR: input and output buffer registerMian Memory]]></content>
      <categories>
        <category>复习</category>
        <category>计组</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>计组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计组复习]]></title>
    <url>%2FReviews%2FCOA%2F%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[大题考点[ ] CPI MIPS Speedup[x] Cache &amp; Memory Organization[x] Hard disk[ ] 浮点数运算[x] 寻址，指令设计[ ] 流水，时序图，加速比，优化[ ] 超标量，超流水，冲突，指令发射[ ] 微操作，微指令，微指令设计2. 存储组织2.1 Cache 存储映射Cache 以TagData形式存储数据，数据段很宽，可以存储主存（Memory）中几行的数据下面所讨论的都是不同映射方式下的地址构成2.1.1 直接映射直接映射主存地址为Tag行号字Tag 就是 Cache 的 Tag；行号是 Cache 的对应行号；字指代了这一行中要取用 Cache 的哪个分段的数据寻址时，首先查找对应行号，检查标记，如果命中，那么则根据字来取数据2.1.2 全相连映射全相连主存地址构成为Tag字由于存储数据和行号无关，使用 Tag 作为唯一的标记，字用于标记数据段需要并行电路不断比对 Tag 内容，如果命中了，那么根据字来取对应数据段2.1.3 组相连映射组相连映射地址构成如下：Tag组号字Tag 和字同上组号是指将 Cache的行分组后的对应组号结合直接映射和全相连映射，将 Cache 的行分为很多的组，先根据组号查找对应组，然后再在组内比对标记。减少了由于直接映射的抖动问题，又避免了全相连映射的不断寻找导致的性能浪费抖动问题：由于程序需要不断访问映射到同一行但来自不同块的字，那么就会导致内存块不断载入载出，造成性能浪费N 路总相连指的就是一个组内有 N 行2.1.4 相关计算问题由 Cache 和 Memory 的行数和块数等数据来指明地址构成这里需要注意，地址不只是用来算 Cache 映射，还要能通过地址在 Memory 中寻找到正确的内存块地址的寻址长度能覆盖主存的容量，确定地址总长度根据 Cache 数据算出 Cache 行数，组数。Cache 的一行就是 Memory 的一块，根据这个算出 Memory 有多少块除了“字”以外的地址位加起来就是这个数“字”的部分要能覆盖块的字节容量如果出现“字（Word）”的描述，那么字的位数就是地址的总长]]></content>
      <categories>
        <category>复习</category>
        <category>计组</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>计组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8 Puzzle]]></title>
    <url>%2FAlgorithm%2F8%20Puzzle%2F</url>
    <content type="text"><![CDATA[1. IntroGive a 3-by-3 grid with 8 square blocks and 1 blank.Rearrange the block to make it in order, using as few moves as possible.Return the result of sequence. Like this below:12345 1 3 1 3 1 2 3 1 2 3 1 2 34 2 5 =&gt; 4 2 5 =&gt; 4 5 =&gt; 4 5 =&gt; 4 5 67 8 6 7 8 6 7 8 6 7 8 6 7 8initial 1 left 2 up 5 left goal2. Best-first searchThe best-first search is that from initial broad to the goal, we do our each step at the best, or small cost move.2.1 Search nodeFirst, we need to define our start and goal. We use a terminology called]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性代数]]></title>
    <url>%2FReviews%2FLinearAlgebra%2F%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1. 行列式1.1 性质1.1.1 转置行列式 $D$ 与它的转置行列式 $D^T$ 的值相等将行列式的行转成列即可得到其转置行列式1.1.2 交换交换行列式的任意两行（或者两列），行列式的值改变符号！1.1.3 比例如果行列式的某行或者某列都乘以同一个数 $k$，那么其值等同于用数 $k$ 乘以同一个行列式其实就是可以把 $k$ 提到竖线外面！1.1.4 值为 0如果行列式中有两行相同，那么行列式的值为 0如果某一行或者某一列的元素均为 0，那么行列式的值为 0如果某两行的元素成比例，那么行列式的值为 01.1.5 拆分如果某行元素为一个和式或者差式，那么就可以把这个行列式拆分成两个行列式的和与差\begin{aligned} \begin{vmatrix} a_{11} & a_{12} & \cdots & a_{1n} \\ \vdots & \vdots & & \vdots \\ a_{i1} + b_{i1} & a_{i2} + b_{i2} & \cdots & a_{in} + b_{in} \\ \vdots & \vdots & & \vdots \\ a_{n1} & a_{n2} & \cdots & a_{nn}\\ \end{vmatrix} = \\ \\ \begin{vmatrix} a_{11} & a_{12} & \cdots & a_{1n} \\ \vdots & \vdots & & \vdots \\ a_{i1} & a_{i2} & \cdots & a_{in} \\ \vdots & \vdots & & \vdots \\ a_{n1} & a_{n2} & \cdots & a_{nn}\\ \end{vmatrix} + \begin{vmatrix} a_{11} & a_{12} & \cdots & a_{1n} \\ \vdots & \vdots & & \vdots \\ b_{i1} & b_{i2} & \cdots & b_{in} \\ \vdots & \vdots & & \vdots \\ a_{n1} & a_{n2} & \cdots & a_{nn}\\ \end{vmatrix} \end{aligned}1.1.6 变换将行列式的某一行的所有元素都乘以同一个数以后加到另一行的对应元素上去，所得行列式仍然为 $D$这里指的是行列式本身都不会变，包括其余子式注意，产生改变的是另一行，而不是乘上数的那一行1.1.7 余子式相关划去某个元素的所在行和所在列之后，留下的行列式称为元素的余子式例如\begin{vmatrix} 1 & x & x^2 \\ 1 & y & y^2 \\ 1 & z & z^2 \\ \end{vmatrix}划除第一个 $1$ 的所在行和所在列之后:\begin{vmatrix}y & y^2 \\ z & z^2 \end{vmatrix}即为第一个 $1$ 的余子式，记为 $M_{ij}$；带上正负号后叫做代数余子式，记为 $A_{ij}$则有A_{ij} = (-1)^{i + j} M_{ij}特别要注意题意，给出和要求的到底是余子式还是代数余子式定理行列式等于它的任一行（列）的个元素与其对应的代数余子式的乘积之和D_n = a_{i1} A_{i1} + a_{i2} A_{i2} + \cdots + a_{in} A_{in}据此可以将行列式进行降阶计算。行列式的某一行的元素与另一行的对应元素的代数余子式的乘积之和等于 0如第一行的元素和第三行的元素的代数余子式的乘积之和为 0这是一个很重要的等价关系，有关行列式的余子式相关计算都会用到1.1.8 范德蒙德行列式\begin{vmatrix} 1 & 1 & \cdots & 1 \\ a_1 & a_2 & \cdots & a_n \\ {a_1}^2 & {a_2}^2 & \cdots & {a_n}^2 \\ {a_1}^3 & {a_2}^3 & \cdots & {a_n}^3 \\ \vdots & \vdots & \vdots & \vdots \\ {a_1}^{n - 1} & {a_2}^{n - 1} & \cdots & {a_n}^{n - 1} \\ \end{vmatrix} = \prod_{1 \le j \lt i \le n} (a_i - a_j)注意，结果的展开等于(a_n - a_1) (a_{n - 1} - a_1) \cdots (a_2 - a_1) \prod_{2 \le j \lt i \le n} (a_i - a_j)$i$ 和 $j$ 并不是同时增长，而是嵌套式增长通常用于求根计算，找准 1 次项的行即可1.1.9 克拉默法则线性方程组的零解问题，找克拉默法则若 $n$ 个方程 n 个未知量的非齐次线性方程组\begin{cases} a_{11}x_1 + a{12}x_2 + \cdots + a_{1n}x_n = b_1 \\ a_{11}x_1 + a{12}x_2 + \cdots + a_{1n}x_n = b_1 \\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \vdots \\ a_{11}x_1 + a{12}x_2 + \cdots + a_{1n}x_n = b_1 \\ \end{cases}的系数行列式 $D=det(a_{ij}) \neq 0$则方程组必有唯一解x_j = \frac{D_j} {D}, j = 1, 2, \cdots, n.若齐次线性方程组有非零解，则其系数行列式 $D = 0$1.2 计算通常有两种计算方法，一是直接用定义地算（交叉相乘等），二是经过变换之后降阶计算通常是将式子变换成某一列的开头为 $1$，其余全为 $0$，然后按照行列式的展开原则。下面讲一些特殊题型的解法。1.2.1 “1 + 型”\begin{vmatrix} 1 + a_1 & 1 & \cdots & 1 \\ 1 & 1 + a_2 & \cdots & 1 \\ \vdots & \vdots & & \vdots \\ 1 & 1 & \cdots & 1 + a_n \\ \end{vmatrix}注意到每列元素之和为 $1 + \sum_{i = 1}^n \frac{1}{a_i}$，所以变化并提出公因式，得\begin{vmatrix} 1 & 1 & \cdots & 1 \\ {1\over{a_2}} & 1 + {1 \over {a_2}} & \cdots & 1 \\ \vdots & \vdots & & \vdots \\ {1\over{a_n}} & 1 & \cdots & 1 + {1 \over a_n} \\ \end{vmatrix}分别乘上 $-{1 \over a_i}$ 后加到第 $i$ 行得a_1 a_2 \cdots (1 + \sum_{i = 1}^n {1 \over a_i})1.2.2 类似范德蒙德类型构造范德蒙德行列式来解形如\begin{vmatrix} 1 & 1 & 1 & 1 \\ a & b & c & d \\ a^2 & b^2 & c^2 & d^2 \\ a^4 & b^4 & c^4 & d^4 \\ \end{vmatrix}构造范德蒙德行列式f(x) = \begin{vmatrix} 1 & 1 & 1 & 1 & 1\\ a & b & c & d & x\\ a^2 & b^2 & c^2 & d^2 & x^2 \\ a^3 & b^3 & c^3 & d^3 & x^3 \\ a^4 & b^4 & c^4 & d^4 & x^4\\ \end{vmatrix}则所求行列式为 $x^3$ 的代数余子式的 $-1$ 倍按照范德蒙德行列式展开并求出 $x^3$ 的系数即可2. 矩阵矩阵不一定是正方形的，行和列相同的矩阵被称为方阵2.1 矩阵的四则运算2.1.1 矩阵的加和减矩阵的加和减满足交换律，结合律，数乘分配律矩阵的数乘是所有元素都乘以 $k$，和行列式不同。行列式只需要一行或者一列乘就可以了。所以后面的方阵的行列式要特别注意指数。2.1.2 矩阵的乘法矩阵的乘法很特殊，其计算方法为：行元素乘以对应列元素得到新矩阵的某行某列的一个元素例如：若 $AB = C$矩阵 $C$ 的第一行第一列的元素 $c_{11}$ 等于 $A$ 的第一行乘以 $B$ 的第一列的乘积之和\begin{aligned} & \begin{bmatrix} a_{11} & a_{12} & a_{13} & \cdots & a_{1n} \\ \cdots & \cdots & \cdots & \cdots & \cdots \\ \cdots & \cdots & \cdots & \cdots & \cdots \\ \end{bmatrix} \times \begin{bmatrix} b_{11} & \cdots \\ b_{21} & \cdots \\ b_{31} & \cdots \\ \vdots & \\ b_{n1} & \cdots \\ \end{bmatrix} \\ \\ & = \begin{bmatrix} c_{11} & \cdots & \cdots & \cdots & \cdots \\ \cdots & \cdots & \cdots & \cdots & \cdots \\ \cdots & \cdots & \cdots & \cdots & \cdots \\ \end{bmatrix} \end{aligned}矩阵的乘法满足结合律(AB)C = A(BC)左分配律和右分配律\begin{aligned} A(B + C) = AB + AC \\ (B + C)A = BA + CA \end{aligned}注意保证顺序不能变，特别是在多个矩阵一起乘的时候。矩阵的乘法不满足交换律2.2 矩阵的转置矩阵的转置就是行变成列性质：$(A^T)^T = A$$(A + B)^T = A^T + B^T $$(kA)^T = k A^T$$(AB)^T = B^T A^T $注意，乘法这里的顺序是倒过来的。2.3 方阵的行列式方阵的行列式没有什么大的要点需要注意的就是数乘$ |kA| = k^n|A| $矩阵的积的行列式等于行列式的积2.4 逆矩阵2.4.1 逆矩阵的定义和判定如果存在矩阵 $B$ 使得矩阵 $A$ 满足AB = BA = E则 $A$ 为可逆矩阵在证明时抓住已知条件，往 $E$ 方向构造2.4.2 性质逆矩阵的逆为它本身转置矩阵的逆为逆矩阵的转$AA^{-1} = E$$(kA)^{-1} = \frac{1}{k} A^{-1}$$|A^{-1}| = {1 \over {|A|} } = |A|^{-1}$$(AB)^{-1} = B^{-1}A^{-1}$注意抓准性质来计算，特别是第四条2.4.3 计算伴随矩阵法由性质A^{-1} = {\frac{1}{|A|}} {A^*}求解出伴随矩阵即可。伴随矩阵等于对应的代数余子式所组成的矩阵A^* = \begin{bmatrix} A_{11} & A_{12} & \cdots & A_{1n} \\ A_{12} & A_{22} & \cdots & A_{n2} \\ \vdots & \vdots & & \vdots \\ A_{1n} & A_{2n} & \cdots & A_{nn} \\ \end{bmatrix}初等变换法在矩阵$A$后面接一个单位矩阵 $E$经过初等变换后，将 $A$ 变成 $E$此时，原来的 $E$ 就变成了 $A^{-1}$分块法利用分块矩阵将大矩阵分成小块，求解每个小矩阵的逆矩阵，再拼接起来，就求出了大矩阵的逆矩阵2.5 特殊矩阵零矩阵：每个元素均为 $0$，记为 $O$单位矩阵：从左往右对角线上的元素均为 $1$，其余为 $0$，记为 $E$数量矩阵： $k$ 乘以单位矩阵的积对角矩阵：非对角线上的值全为 0 的矩阵称为对角矩阵上（下）三角矩阵：对角线以上或者对角线以下的值全部为 0 的矩阵称为上（下）三角矩阵三角矩阵的行列式的值等于对角线上的值的乘积]]></content>
      <categories>
        <category>复习</category>
        <category>线代</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[毛泽东思想概论]]></title>
    <url>%2FReviews%2FMaoTheory%2F%E6%AF%9B%E6%B3%BD%E4%B8%9C%E6%80%9D%E6%83%B3%E6%A6%82%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[八七会议的意义土地革命和武装斗争枪杆子里出政权]]></content>
      <categories>
        <category>复习</category>
        <category>毛概</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>毛概</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统复习]]></title>
    <url>%2FReviews%2FOS%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[1. Operating SystemWhat does a Mordern OS do?Provide abstractionsProvide Standard InterfaceMediates Resource UsageConsumes Resources2. Processes and Threads2.1 What is process and threadsProcess is an execution stream in the context of a particular process state.Thread is an execution stream in the context of a thread state.The key difference: Multiple threads share parts of their state.Allowing read write the same memory, but each thread still have own registers.Reason:The threads must corrdinate their activities very closely.It is much easier to coordinate activities.2.2 Process state informationRegisterStackMemoryOpen file tablesSingal management information2.3 MultiprogrammingMultiple processes at a time.Allow system to separate out activites cleanly.2.4 Context switchBecause multiprogamming, there needs to share the resource, such as CPU.Therefore, OS needs the ability to switch from one process to another.That is Context Switch2.5 PCBThe way to implement the Context Switch is to save and restore the hardware state in PCB (Process Control Block).2.5.1 PCB depends on hardwardRegisterPorcessor Status WordMemorySome machine needs the Memory Management Unit(MMU)But the older PC switch all the process’s memory out to disk2.6 Event-drivenOS is fundamentally event-driven.That is to wait for an event to happen, response appropriately to the event, then wait for the next event2.7 Thread Control BlockIt is tipically register.Don’t need to do anything to the MMU when switch threads.2.8 Each user process is backed by kernel threadThat is the OS will have a separate thread for each process.And perform the OS activities on behalf of the process.Advantages:Allow the programmer to program the actions associate with that activity as a single serial stream of actions and eventsProgrammer does not have to deal with the complexity of interleaving multiple activities on the same thread2.9 Asyncorony]]></content>
      <categories>
        <category>复习</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1. 基本概念]]></title>
    <url>%2FReviews%2FProbability%2F1.%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[1.1 随机试验可重复结果不唯一结果不确定随机性：包括上述性质以外还有结果范围确定试验完成，必有一个确定结果1.2 样本空间样本空间是随机试验的所有可能结果集合1.3 随机事件样本空间的子集叫做随机事件，元素称为样本点基本事件：单点集合必然事件：样本空间本身，记为 $\Omega$不可能事件：空集 $\varnothing$1.4 事件关系与运算1.4.1 关系相等：$A \subset B, B \subset A $ 则 $A = B$和事件：$A \cup B = {x|x \in A\ or\ x \in B}$积事件：$A \cap B = {x|x \in A\ and\ x \in B}$互斥事件：$A \cap B = \varnothing$，即 $A$ $B$ 不能同时发生对立事件：$A \cup B = S, \ and \ A \cap B = \varnothing$，$A$ $B$ 必有一个发生对立事件一定是互斥事件差事件：$A - B = {x|x \in A \ and \ x \notin B}$$A-B = A\overline{B}\ \subset A$若 $A \subset B$ 则，$A - B = \varnothing$$A - B = A - AB$$A - B = A\overline B = A(1-B) = A - AB$总有 $A = AB \cup A \overline B$$A \cup B = A \cup (\overline A B) = B \cup (A \overline B)$1.4.2 运算1.4.2.1 运算律交换律：$A \cup B = B \cup A$; $A \cap B = B \cap A$结合律：$A \cup (B \cup C) = (A \cup B) \cup C$$A \cap (B \cap C) = (A \cap B) \cap C$分配律:$A \cup (B \cap C) = (A \cup B) \cap (A \cup C)$$A \cap (B \cup C) = (A \cap B) \cup (A \cap C)$德摩根律：$\overline{A \cup B} = \overline A \cap \overline B$$\overline{A \cap B} = \overline A \cup \overline B$1.4.2.2 术语“至少” —— 加法运算“同时” —— 乘法运算例： 设 $A, B, C$ 三个事件，$A, B,C$ 的运算：$A$ 发生，B,C 不发生A!B!CA与B都发生，而C 不发生ABC中至少有一个发生ABC都发生ABC都不发生ABC不多于一个发生ABC不多于两个发生ABC至少两个发生AB + AC + BCABC恰有一个发生A!B!C + !AB!C + !A!BCABC 恰有两个发生AB!C + !ABC + A!BC例2：在班上，任选一名学生：A: 男生B：二年级C: 登山队员AB!C =在什么条件下，ABC = C（C 包含于 AB）在什么条件下，C 包含于 B1.5 频率和概率1.5.1 频率频率 = 频数 $/$ 试验总数频数：在 n 次试验中，发生某事件的次数基本性质$0 \le f_n(A) \ge 1$$f_n(S) = 1$若 $A_1, A_2 \cdots A_n$ 是两两不相容事件，则有 $f_n(A_1 \cup A_2 \cup \cdots \cup A_n) = f_n(A_1) + f_n(A_2) + \cdots + f_n(A_n)$1.5.2 概率1.5.2.1 统计定义在一组相同条件下，重复地做 n 次试验，记, $n_A$为 n 次试验中，事件 A 发生的次数。当 $n \to \infty$，频率（$n_A \over n$）稳定在某一个常数 P 附近。且随着 n 的增大，摆动的幅度越来越小，此时称 A 为随机事件，称 p 为事件 A 发生的概率，记作：$P(A) = p$1.5.2.2 数学定义对于随即试验赋予一个实数$P(A)$, 称为概率，满足已下条件对于任何事件 $A$，有 $P(A) \ge 0$对于必然事件 $S$，有 $P(S) = 1$也可以表示为 $P(\Omega) = 1$可列可加性：对于两两不相容事件，则有 $P(A_1 \cup A_2 \cup \cdots \cup A_n) = P(A_1) + P(A_2) + \cdots + P(A_n)$也称为完全可加性$P(A)$ 表征事件 $A$ 在一次试验中发生的可能性大小。上述要点也是概率的性质。注意，概率是趋近得到的，概率为 1 的事件不一定是必然事件。同理，概率为 0 的事件不一定是必然事件。1.5.2.3 性质$P(\varnothing) = 0$有限可加：对于两两不相容事件$P(A_1 \cup A_2 \cup \cdots \cup A_n) = P(A_1) + P(A_2) + \cdots + P(A_n)$可以推广到 $n = \infty$ 的可列可加性$A \subset B \Rightarrow P(B) \ge P(A)$任何事件 $A$ 都有 $P(A) = 1$逆事件：$P(\overline A) = 1 - P(A)$加法：$P(A \cup B) = P(A) + P(B) - P(AB)$对于一般事件，有P(A_1 \cup A_2 \cup \cdots \cup A_n) = \sum_{i = 1}^nP(A_i) - \sum_{1 \le i \lt j \le n}P(A_iA_j) + \sum_{1 \le i \lt j \lt k \le n}P(A_i A_j A_k) + \cdots + (-1)^{n - 1}P(A_1 \cdots A_n)1.5.3 概率空间1.5.3.1 $\sigma$ 代数称 $\Omega$ 样本空间的一些子集所成的集合 $F$，若 $F$ 满足：$\Omega \in F$若 $A \in F$ ,则 $\overline A \in F$若 $An \in F, n = 1, 2, \ldots $，则称 $\bigcup{i = 1}^\infty A_n \in F$则称 ${\Omega, F}$ 为可测空间，称 $F$ 为 $\sigma - $代数1.5.3.2 样本空间称 ${\Omega, F, p}$ 为样本空间，其中：$\Omega$ 样本空间$F$ 事件域$p$ 概率1.5.3.3 性质$P(\varnothing) = 0$若$A_i \in F, i = 1,2, \ldots, n$ 且 $A_iA_j = \varnothing (i != j)$当 $AB = \varnothing$ 则 $P(A \cup B) = P(A) + P(B)$若 $A, B$ 为任意事件，那么， $P(A \cup B) = P(A) + P(B) - P(A B)$将上式推广到 n 个，则有P(\bigcup_{i = 1}^n A_i) = \sum_{i = 1}^nP(A_i) - \sum_{1\le i \lt j \le n} P(A_iA_j) + \sum// TODO单调不减性：若 $A \subset B$ 则 $P(B - A) = P(B) - P(A) \ge 0$，则 $P(B) \ge P(A)$$P(\overline A) = 1 - P(A)$设 $An \in F, n = 1,2, \ldots$，且 $A_1 \subset A_2 \subset \ldots A_n$，则 $P(\bigcup{n = 1}^\infty An) = \lim{n \to \infty} A_n$称为下连续$An \in F, n = 1,2,\ldots$，且 $A_i \supset A_2 \supset \ldots \supset A_n \supset \ldots$，则 $P(\bigcap{n = 1}^\infty An) = \lim{n \to \infty} P(A_n)$称为上连续6 和 7 也称作 $p$ 的连续性1.5.3.4 例题设 $A, B, C$ 为三事件，已知$P(A) = P(B) = P(C) = 1/4, P(AB) = 0 = P(AC), \ P(BC) = 1/8$ 求 $ABC$中至少有一个发生的概率。\begin{aligned} P(A \cup B \cup C) &= P(A) + P(B) + P(C) \\ & - P(AB) - P(AC) - P(BC) + P(ABC) \\ &= \frac{1}{4} + \frac{1}{4} + \frac{1}{4} - \frac{1}{8} + 0 \\ &= 0.625 \end{aligned}将编号为 $1, 2, 3$ 的三本书任意地排在了书架上，求至少有一本书从左到右的排列序号与之编号相同的概率。$A_k$: 第 $k$ 本书在第 $k$ 个位置上， $k = 1,2,3 \ldots$则 $A = A_1 \cup A_2 \cup A_3$$P(A_k) = \frac{1 (3 - 1)!}{3!} = 1/3$$P(A_iA_j) = \frac{1 \times 1 \times (3 - 2)!}{3!} = 1/6$$P(A_1A_2A_3) = 1 / {3!}$（匹配问题） 某人写了 n 封信，并将它们随机放入写着 n 封信收信人地址的信封内，求：至少有一封信正确的概率n 个信封上的地址均不正确的概率恰有 r 个信封上的地址正确的概率B:至少有一封信是对的。B_r：恰有 r 个是对的A_i: 第 i 封信对的1）\begin{aligned} P(B) &= S_1 - S_2 + S_3 + \cdots + (-1)^{n - 1}S_n \\ \\ P(A_i) &= \frac{1}{n}, \ S_1 = n \times \frac{1}{n} = 1 \\ \\ P(A_iA_j) &= \frac{(n - 2)!}{n!} = \frac{1}{n(n - 1)}, \ S_2 = 1/2! \\ \cdots \\ \\ S_n &= 1/n! \\ \end{aligned}则\begin{aligned} P(B) &= 1 - \frac{1}{2!} + \frac{1}{3!} - \ldots + \ldots + (-1)^{n + 1}\frac{1}{n!} \\ &= \sum_{k =1 }^n \frac{(-1)^{k + 1}}{k!} \end{aligned}所以 $\lim_{n \to \infty} P(B) = 1 - e^{-1}$2) $P(B_0) = 1 - P(B)$3) $P(A{i_1}A{i2}\cdots A{ir}) = \frac{1}{n(n -1) \ldots (n - r + 1)}$而其余 r 个不对，即 $\sum{k = 0}^{n -r} \frac{(-1)}{k!}$所以\begin{aligned} P(B_r) &= C_n^r \times \frac{1}{n(n - 1)\ldots (n - r + 1)} \times \sum_{k =0}^{n -r} \frac{(-1)}{k!} \\ &= \frac{1}{r!} \sum_{k= 0}^{n -r} \frac{-1}{k} \end{aligned}$P(Time) = \prod P$$P(\bigcup{i = 1}^{n}) = \prod{i = 1}^n (P(A_i))$1.6 等可能概型1.6.1 定义元素有限基本事件发生概率相同由上，基本事件概率 $P({e_i}) = 1 / n , i = 1, 2, 3 \cdots$P(A) = \sum_{j = 1}^k P(\{e_{i_j}\}) = k / n = \frac{Basic \ Events \ in \ A}{Basic\ event \ in \ S}实际推断原理：概率很小的事件在一次试验中几乎不发生1.6.2 例题例1： 一个袋里有 5 个球，3 个白，2 个黑，从中任取三个：求全是白球全是黑球一黑一白改变上例为放回操作，重做题目。例2： 产品检验模型，有 N 件，D 件次品，N - D 件正品问任取 n 件，恰有 k 件是次品的概率例3： 打牌（去除大小王），4 人，求某人拿到 4 张黑桃，且其他花色都是 3 张的概率P(A) = \frac{ C^4_{13} C^3_{13} C^3_{13} C^3_{13} } {C^{13}_{52}}例4： 把一副牌洗透了，求 4 张 A 连在一起的概率。捆绑 + 插空。P(A) = \frac{A_4^4 C_{49}^1 A_{50}^{50}}{A_{52}^{52}}例5：分房模型将 n 个小球随机地放到 N 个大盒子中，求下列事件概率：A：某指定的 n 个盒子中各有一个球；球选盒子P(A) = \frac{n!}{N^n}B：每个盒子中至多有一个球；先把 n 个 盒子选出来，然后球选盒子P(B) = \frac{C_N^n}{N^n}C：某指定的一个盒子中恰有 m（m 小于等于 n） 个球先将指定的 m 个球选出来，然后让剩下的小球到剩余的盒子中去P(C) = \frac{C_n^m (N - 1)^{n - m}}{N^n}例6：假设没人的生日在 365 天中任一天，等可能，则随机选取 n 个人：他们的生日各不相同的概率分房模型。至少有两人相同的概率间接法，通过求解对立事件的概率来求解。例7：摸球问题设盒中有 $\alpha$ 个白球，$\beta$ 个黑球，现采用放回和不放回两种抽样方式。从中任取 a + b 个球，问摸过的球中恰有 a 个白，b 个黑球的概率。1.6 补充：几何概型1.6sp.1 背景：约会问题甲，乙两人相约在 0 到 T 这短时间内在预订的地点会面。先到的人等另外一人 t 时间，之后离开。求甲、乙两人能会面的概率。设 x, y 为到达的时刻，$x \le 0, y \le T$“会面” $=$ $|x - y| \le t$，通过画平面直角坐标系解决。\begin{aligned} P(A) &= \frac{T^2 - (T - t)^2}{T^2} \\ &= 1 - (1 - \frac{t}{T})^2 \end{aligned}1.6sp.2 定义试验 E 具有:样本空间$\Omega$ 是一、二、三维中的度量($L(\Omega)$)样本点在 $\Omega$ 中均匀分布则称 E 为几何概型，则 $P(A) = \frac{L(A)}{L(\Omega)}$ 叫做几何概率1.6sp.3 例题平面上画有某距离为 a 的一些平行线，想平面上任意投一长为 l 的针，试求针与平行线相交的概率。取针的中点 M，中点到相交平行线的距离为 x ，与相交平行线的夹角为 $\phi$则 $\Omega = {(x, \phi)| 0 \le x \le \frac{a}{2}, 0 \le \phi \le \pi }$相交 $= {(x, \phi)|x \le \frac{l}{2}Sin\phi, (x, \phi) \in \Omega}$\begin{aligned} P(A) &= \frac{L(A)}{L(\Omega)} \\ \\ &= \frac{\int_0^\pi \frac{l}{2}Sin\phi d\phi}{\frac{a}{2} \pi} \\ &= \frac{2l}{\pi a} \\ \\ &= \frac{2}{\pi} \times \frac{l}{a} \end{aligned}1.7 条件概率1.7.1 定义$A$ $B$ 是两个事件，且 $P(A) \gt 0$，则称P(B|A) = \frac{P(AB)}{P(A)}称为事件 A 发生下，事件 B 发生的概率由于条件概率仍然是概率，则满足概率加法P(B_1 \cup B_2 | A) = P(B_1|A) + P(B_2 |A) - P(B_1B_2|A) \varnothing解题要点：从 $A$ 中寻找属于 $B$ 的元素，即 $A$ $B$ 的交集1.7.2 全概率公式和贝叶斯公式1.7.2.1 样本空间的划分满足以下条件的称为样本空间的划分$B_iB_j = \varnothing$$B_1 \cup B_2 \cup \cdots \cup B_n = S$则 $B_1, B_2 \cdots B_n$ 称为样本空间 $S$ 的 划分1.7.2.2 全概率公式\begin{aligned} P(A) &= P(A|B_1)P(B_1) + P(A|B_2)P(B_2) + \cdots + P(A|B_n)P(Bn) \\ &= \sum_{i =1}^nP(A_i)P(B|A_i) \end{aligned}1.7.2.3 贝叶斯公式假设 $A_1 \cdots A_n $为 $\Omega$ 的一个划分，$P(A_i) \gt 0,\ P(B) \gt 0$, 则有P(B_i|A) = \frac{P(A|B_i)P(B_i)}{\sum_{j = 1}^nP(A|B_j)P(B_j)}以上两个公式的关键，事件，$\Omega$的划分1.7.2.4 乘法公式设 $P(B) \gt 0$ 则有$P(AB) = P(B)P(A|B)$推广 $P(A1A_2\cdots A_n) = P(A_1)P(A_2|A_1)P(A_3|A_1A_2)\cdots P(A_n|A_1 \cdots A{n - 1})$ , 当 $P(A1A_2 \cdots A{n - 1}) \lt 0$1.7.2.5 例题盒子里有 16 个球，6 个玻璃球， 10 个木头球。玻璃球有 2 红 4 蓝，木头球有 3 红 7 蓝。问题：摸一个球，已知是玻璃球，问是蓝色的概率\玻璃木头红23蓝47\610观察可知 $P(A|B) = 4/6$$p(AB) = 4/16$某人忘了电话号码的最后一位，因而随意拨号，求拨号不超过 2 次就能接通的概率$A_1:$ 第一次通$A_2:$ 第二次通有 $A = A_1 \cup \overline A_1 A_2$\begin{aligned} \therefore P(A) &= P(A_1) + P(\overline A_1 A_2) \\ &= \frac{1}{10} + P(\overline A_1 )P(A_2|\overline A_1) \\ &= \frac{2}{10} \end{aligned}抓阄：有 5 张条，其中 3 张有，2 张无。现从中任取一张，不放回，问第一个人抽到有的概率P(A) = \frac{3}{5}\begin{aligned} P(B) &= P(B \Omega) = P(B(A\cup \overline A)) \\ \\ & = P(BA\cup B\overline A) = P(BA) + P(B \overline A) \\ \\ & = P(A)P(B|A) + P(\overline A)P(B | \overline A) \\ \\ & = \frac{3}{5} \times \frac{2}{4} + \frac{2}{5} \times \frac{3}{4} \\ \\ & = \frac{3}{5} \end{aligned}某实验室的晶体管由三个厂家提供，有下表：厂家次品率份额10.0215%20.0180%30.035%随机取一支，它是次品的概率随机取一支，已知是次品，是出自 1 厂的概率常识： $P(B) = 0.02 \times 15\% + 0.01 \times 80\% + 0.03 \times 5\%$1): $A_i$: 拿到的次品来自于第 $i$ 个厂家生产的P(B) = P(A_i)P(B|A_i)2):\begin{aligned} P(A_i|B) &= \frac{P(A_i)P(B|A_1)}{P(B)} \\ &= \frac{15\% \times 0.02}{0.0125} \end{aligned}1.8 独立性若 $A$ $B$ 两事件，满足 $P(A|B) = P(A)P(B)$, 即 $P(A|B) = P(B)$则 $A,B$ 相互独立，简称独立1.8.1 独立性定理若 $A,B$ 独立，则 $P(A|B) = P(B)$若 $A,B$ 独立，则 $A,\overline B;\ \overline A, B;\ \overline A, \overline B$推广：若积事件的概率都等于事件概率的积。那么事件相互独立1.8.2 推论若 $A_1, A_2, \cdots A_n$ 相互独立，那么其中的任意 k 个事件也相互独立若 $A_1, A_2, \cdots A_n$ 相互独立，将其中任意多个转换为对立事件，也相互独立1.8.3 例题质地均匀的正四面体，分别染上红色，黄色，蓝色，第四个面染上红、黄、蓝三种颜色。试验：扔一次，观察接触桌子的一面所对应的颜色。假设 $A$：有红色，$B$：有黄色，$C$：有蓝色有 $A_i$：第$i$ 个面接触桌子$P(A_i) = 1/4$，$A = A_1 \cup A_4$ $B = A_2 \cup A_4$ $C = A_3 \cup A_4$有\begin{aligned} P(A) &= P(B) = P(C) = P(A_1) + P(A_4) \\ &= \frac{1}{4} + \frac{1}{4} = \frac{1}{2} \end{aligned}且$P(AB) = P(A_4) = \frac{1}{4} = P(A) + P(B) = \frac{1}{2} + \frac{1}{2}$又$\because$ $P(ABC) = P(A_4) = 1/4$$\therefore$ 两两独立不代表三个以上的事件组独立n 个人同时射击某一个目标，假设每人击中目标的概率为 p， 且各人是否击中目标相互独立，求目标被击中的概率 $B$。假设 $B$：目标被击中$Ai$：第 $i$ 个击中，则 $B = \bigcup{i = i}^nA_i$\begin{aligned} \therefore P(B) &= P(\bigcup_{i = 1}^n A_i) \\ &= 1 - P(A_1 \cup A_2 \cup \cdots \cup A_n) \\ &= 1- P(\prod_{i = 1}^n \overline A_i) \\ &= 1- (1 - p)^n \end{aligned}1.9 第一章例题从 5 双不同的鞋子中任取 4 只，4 只鞋子中至少有 2 只配成一双的概率。间接法：没有任何两只配成一双排列法：\begin{aligned} P(A) &= 1 - P(\overline A) \\ &= 1 - \frac{10 \times 8 \times 6 \times 4}{10 \times 9 \times 8 \times 7} \\ &= 1 - \frac{8}{21} \end{aligned}组合法：\begin{aligned} n = C_{10}^4, \ m_{\overline A} = C_5^4 \times 2 \times 2 \times 2 \times 2 \\ \\ \begin{aligned} P(A) &= 1 - P(\overline A) \\ &= 1 - \frac{m}{n} \\ &= 1 - \frac{C_{10}^4}{C_5^4 \times 2 \times 2 \times 2 \times 2} \end{aligned} \end{aligned}直接法：\begin{aligned} m_A = C_5^1 C_8^2 - C_5^2 \\ n = C_{10}^4 \\ d \end{aligned}设 A B 两事件， 已知 $P(A) = 0.5, P(B) = 0.6, P(B|\overline A) = 0.4$求 (1) $P(\overline A B)$ (2) $P(AB)$ (3) $P(A \cup B)$$P(\overline A B) = P(\overline A) \times P(B|\overline A ) = 0.2$\begin{aligned} & \because AB = B - \overline A B, B \supset \overline A B \\ \\ & \therefore P(AB) = P(B) - P(\overline A B) \\ \\ & P(A \cup B) = P(A) + P(B) - P(AB) \end{aligned}设考生的报名表来自三个地区各有 10 份， 15 份， 25 份，其中女生分别为 3 份， 7 份， 5 份。随机从一地区，先后任取两份报名表。求(1) 先取出一份是女生的概率；(2) 已知后取出的一份为男生的，而先取出的一份为女生的概率。设 $B_k$：第 k 次取出的是女生 $k = 1, 2$$A_i$：考生第 i 个地区，$i = 1, 2, 3$$P(B_1) = P(B_2)$\begin{aligned} P(B_1) &= \sum_{i = 1}^3 P(A_i)P(B_1|A_i) \\ \\ &= \frac{1}{3} \times \frac{3}{10} + \frac{1}{3} \times \frac{7}{15} + \frac{1}{3} \times \frac{5}{25} \\ \\ &= \frac{29}{90} \end{aligned}条件概率\begin{aligned} & P(B_1|\overline {B_2}) = \frac{P(B_1 \overline {B_2})}{P(\overline {B_2})} \\ \\ & \because P(B_1) = P(B_2) \\ \\ & \therefore P(\overline {B_2}) = 1 - \frac{29}{90} = \frac{61}{90} \end{aligned}\begin{aligned} \therefore B_1\overline {B_2} &= \Omega(B_1 \overline {B_2}) \\ \\ &= (A_1 \cup A_2 \cup A_3)(B_1 \overline {B_2}) \\ \\ &= A_1B_1 \overline {B_2} \cup A_2 B_1 \overline {B_2} \cup A_3 B_1 \overline {B_2} \\ \end{aligned}\begin{aligned} \therefore P(B_1 \overline {B_2}) &= \sum_{i = 1}^3 P(A_i B_1 B_2) \\ \\ &= \sum_{i = 1}^3 P(A_i)P(B_1 | A_i)P(\overline {B_2}| A_i B_1) \\ \\ &= \frac{7}{9} \end{aligned}在 AB 电路中，元件的损坏是相互独立的。在 T 内，元件损坏的概率为元件k1k2A_1A_2A_3几率0.10.20.40.70.5设 B 为断路事件\begin{aligned} B = k_1 \cup (A_1A_2A_3) \cup k_2 \\ \end{aligned}]]></content>
      <categories>
        <category>复习</category>
        <category>概率论</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>概率论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2. 随机变量及其分布]]></title>
    <url>%2FReviews%2FProbability%2F2.%20%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83%2F</url>
    <content type="text"><![CDATA[2.1 随机变量样本空间是${e}$, $X = X(e)$ 是定义在 $S$ 上的实值单值函数，则称 $X$ 为随机变量。定义域是 $S$，值域是实数集合注意是单值函数，也就是说，随机变量就是一个数。可以使用随机变量来表示事件例如 1 表示 true , 0 表示 false2.1.1 例题盒子里有 5 个球， 2 白 ，3 黑，从中任取 3 个球设 $X$ 为抽取黑球的个数，则 $A:$ 全是黑球 $\Rightarrow X = 3$2.2 离散随机变量及其分布律设 $X$ 的所有可能取值为 $x_k(k = 1, 2 \ldots)$则 $P{X = x_k} = P_k \ , k = 1, 2 \ldots$由概率性质可知：$P_k \ge 0$$\sum_{k = 1}^\infty P_k = 1$上述性质称为分布律，也可用表格表示2.2.1 0 - 1 分布在一次试验中若 $X$ 只可能取 $0, 1$ 两个值（事件 A 出现或不出现），那么P\{x = k\} = p^k(1 - p)^{1 - k}, k = 0, 12.2.2 伯努利试验（二项分布）设有一个 $E$，只有两个结果，现将 $E$ 进行 n 次独立的重复试验，称为 n 重伯努利试验。伯努利试验满足二项分布：P\{X = k\} = C_n^k p^k (1 - p)^{n - k} \ , k = 0,1,2 \ldots n简化为：$B(n, p)$2.2.2.1 例题仪器中有 5 块同类固体组件相互独立工作，每一块经 $T$ 小时后损坏的概率为 p， 问： $T$ 小时后，其中有 3 块损坏的概率 $p$设 $r, v, X$——损坏块数，有 $X \sim B(s, p)$，则：$p {X = 3} = C_5^3 p^3 (1 - p)^2$2.2.3 泊松分布利用泊松定理，则有：设 $\lambda \lt 0$, $n$ 是任意正整数，设$np = \lambda$($p$ 很小)，则$\forall k \in Z^+$,则有：\lim_{n \rightarrow \infty} C_n^k p^k (1 - p)^{n - k}知：\begin{aligned} C_n^kp^k(1-p)^{n-k} &= \dfrac{n(n-1)\ldots(n-k+1)}{k!}(\dfrac{\lambda}{n})^k(1-\dfrac{\lambda}{n})^{n-k} \\ \\ &= \dfrac{\lambda^k}{k!}\dfrac{n(n-1)\ldots(n-k+1)}{n^k}(1-\dfrac{\lambda}{n})^{n}(1-\dfrac{\lambda}{n})^{-k} \end{aligned}定义：称 $r,v, X$，若P\{X = k\}= \frac{\lambda^k}{k!} e^{-\lambda}, k = 0, 1, 2, \ldots , n \ldots记为 $\Pi(\lambda)$2.2.3.1 例题例：在保险公司 2500 名同一年龄同社会阶层人参保，据统计在此类人中，每年每人死亡率为 0.002，每人参保在 1 月 1 日交 1200 元保费，而死亡时家属可以从保险公司领取 20 万保险金。求：(不计利息及管理费)保险公司亏本的概率保险公司获利不少于 100 万的概率死亡人数 $r, v, X \sim B(2500, 0.002)$亏本：$200000 X &gt; 3000000 \to X &gt; 15$\begin{aligned} \therefore p\{X > 15\} &= \sum_{k=16}^{2500} C_{2500}^k \cdot 0.002^k \cdot 0.998^{2500 - k} \\ \\ & \approx 1 - p\{X \le 15\} \\ \\ & \approx 1 - \sum_{k=0}^{15}\dfrac{5^k}{k!}e^{-5} \\ \\ & \approx 1 - 0.998\ldots \\ \\ & = 0.000069 \end{aligned}二进制传输信号，信道无记忆，误码率为 $0.2$，为了抗干扰，重复发送消息：$S = 01101$，假设信道对每个 $0, 1$的干扰相互独立，问：重复 5 次 $S$, 能成功发送一次的概率。为确保成功的概率为 $0.99$, 问至少应该重复发送多少次。无记忆：\begin{aligned} & p\{\beta_1 \ldots \beta_m(Receive)\mid \alpha_1 \alpha_2 \ldots \alpha_m(Send)\} \\ \\ & = p\{\beta_1 \mid \alpha_1\} \cdot p\{\beta_2 \mid \alpha_2\} \ldots p\{\beta_m \mid \alpha_m\} \end{aligned}引入一个合理的随机变量：$r, v, X$(次数)，则，正确接收的次数 $r, v, X \sim B(5, p)$ （$p$ 为每次发 $S$ 能正确收到的概率）\begin{aligned} p &= P\{Receive \ S | Send \ S\} \\ \\ &= P{0|0}P{1|1} \cdots \\ \\ &= (1- 0.2)^5 \\ \\ &= 0.8^5 \\ \\ &=0.328 \end{aligned}2.\begin{aligned} P\{Success\} &= P\{X \ge 1\} \\ \\ &= 1 - P\{X = 0\} \\ \\ &= 1 - C_5^0 0.328^0 (1 - 0.328)^5 \\ \\ &= 0.863 \\ \end{aligned}3.P\{X \ge 1\} = 0.99 = 1 - (0.672)^n, n = 12电话交换机，每分钟呼叫次数 $X$ 服从 $\Pi(4)$，求：每分钟恰有 8 次呼叫的概率每分钟不大于 10 次的概率$r, v, X \sim \Pi(4)$$P{X = k} = \frac{\lambda^k}{k!} e^{-\lambda}, k = 0,1,2 \ldots$2.2.4 超几何分布——产品检验模型\begin{aligned} & P\{X(Number \ of \ Defective) = k\} \\ \\ & = \frac{C_M^k C_{N - M}^{n - k}}{C_N^n}, k = 0,1,2, \ldots, l \\ \\ & l = \min(M, n) \end{aligned}当\lim{N \to \infty} \frac{C_M^k C_{N - M}^{n - k}}{C_N^n} = C_n^k p ^k (1 - p)^{n - k}其中\frac{M}{N} \to p2.3 随机变量的分布函数2.3.1 定义设随机变量 $X$，$X \in R$, 则称 $F(x) = P{X \le x}$ 为随机变量 $X$ 的分布函数。2.3.2 性质$F(x)$ 为不减函数即 $x_2 \gt x_1$，有 $F(x_2) \ge F(x_1)$$\because F(x_2) - F(x_1) = P{x_1 \lt X \lt x_2} \ge 0$$0 \le F(x) \le 1$ (非负有界性)且 $F(-\infty) = 0 = \lim{x \to -\infty} F(x) = 0$$F(\infty) = 1 = \lim{x \to \infty} F(x) = 1$$F(x)$ 是右连续的即 $F(x + 0) = F(x)$可导性2.3.3 利用 $F(x)$ 计算概率$P{x_1 \lt X \le x_2} = F(x_2) - F(x_1)$$P{X \lt x} = 1 - F(x)$$P{X = x} = F(x) - F(x - 0)$$P{x_1 \lt X \lt x_2} = F(x_2 - 0) - F(x_1)$2.3.4 例题设随机变量 $X$ 的分布律为X-123s$p_k$$\frac{1}{4}$$1/2$$1/4$$1$求：$X$ 的分布函数$F(x) = P{X \le x}$当 $x \lt -1$ 时，$F(x) = 0$$-1 \le x \lt 2, \ F(x) = P{X = -1} = \frac{1}{4}$$2 \le X \lt 3,\ F(x) = P{X \le x} = P{X = -1 } \cup P{X = 2}$\therefore F(x) = \begin{cases} 0 & x \lt -1 \\[2ex] \frac{1}{4} & -1 \le x \lt 2 \\[2ex] \frac{3}{4} & 2 \le x \lt 3 \\[2ex] 1 & x \le 3 \end{cases}即 $F(x) = \sum{x_k \le x}P{X = x_k} = \sum{x_k \le x}p_k$求 $P{X \le \frac{1}{2} }, P{\frac{3}{2} \lt X \le \frac{1}{2}}, P{2 \le X \le 3}, P{X \lt 2}$ 的概率。\begin{aligned} P\{X \le \frac{1}{2}\} = F(\frac{1}{2}) = \frac{1}{4} \\ \end{aligned}\begin{aligned} P\{\frac{3}{2} \lt X \le \frac{5}{2}\} &= F(\frac{5}{2}) - F(\frac{3}{2}) \\ &= \frac{3}{4} - \frac{1}{4} \end{aligned}\begin{aligned} P\{2 \le X \le 3\} &= P\{X = 2\} + P\{2 \lt X \le 3\} \\ &= \frac{1}{2} + F(3) - F(2) \\ &= \frac{1}{2} + 1 - \frac{3}{4} \\ &= \frac{3}{4} \end{aligned}P\{X \lt 2\} = \frac{1}{4} = P\{X \le 2\} - P\{X = 2\}]]></content>
      <categories>
        <category>复习</category>
        <category>概率论</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>概率论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[概率的历史]]></title>
    <url>%2FReviews%2FProbability%2F%E6%A6%82%E7%8E%87%E7%9A%84%E5%8E%86%E5%8F%B2%2F</url>
    <content type="text"><![CDATA[1. 起源1.1 远古时期概率和概率论起源于游戏之中。在远古时期，就有古人用猪或者羊的距骨来玩投掷距骨的游戏。由于距骨能投掷出四面，其很可能就是骰子的前身。古埃及发掘出的陶器甚至还显示古埃及人就已经在玩一个叫做 “Hounds and Jackals” 的游戏，这与现在的印度游戏“蛇梯棋”（一个用骰子来决定步数 的棋类游戏）十分相像。&lt;span class=”hint—top-right hint—error hint—large” aria-label=”F. N. David (1962), Games, Gods and Gambling“&gt;[1]&lt;/span&gt;&lt;/a&gt;但是直到中世纪甚至文化复兴时期，虽然当时有投注赔率和保险业保险费用的计算需要，但是仍然没有产生相应的方法论来计算赔率或者保险费用。[2]1.2 概率论的创立真正的数学意义上的概率论的创立是由卡当诺(Jerome Cardan)、帕斯卡(Blaise Pascal)、费马(Pierre de Fermat) 完成的。卡当诺的 Games of Chance 一书写于 1564 年（但直到 1663 年才发表），他在书中描述了他对于丢骰子等赌博游戏的研究，其中他证明了利用期望结果和非期望结果的比值来定义赔率的有效性，这意味着一个事件的概率是该事件的发生次数和总可能结果的比值这一命题得到证明&lt;span class=”hint—top-right hint—error hint—large” aria-label=”P. Chance magazine (2012) Some laws and problems in classical probability and how Cardano anticipated them Gorrochum“&gt;[3]&lt;/span&gt;&lt;/a&gt;。此书被认为是第一部概率论著作，对现代概率论的创立有着重要作用。真正的数学意义上的概率论的创立源于帕斯卡受某位热衷于赌博的朋友的影响，同费马通信讨论了这一问题。&lt;span class=”hint—top-right hint—error hint—large” aria-label=”O’Connor, J. J.; Robertson, E. F.. “The MacTutor History of Mathematics archive: Pierre de Fermat” http://www-groups.dcs.st-and.ac.uk/~history/Biographies/Fermat.html“&gt;[4]&lt;/span&gt;&lt;/a&gt; 其具体问题是：基于赢得赌局的概率，两个提前结束游戏的玩家如何在给定现在赌局的情形下公平的分赌注。这一讨论中提到了期望这一重要的概念。1.3 概率论的诞生此后，在帕斯卡的影响下，惠更斯于 1657 年发表了 De ratiociniis in ludo aleae （英文译作 “On Reasoning in Games of Chance”，中文一般译作《论赌博中的计算》），此书中结合了费马和帕斯卡的观点，在“点数分配”问题的研究中，提出了期望这一概念和其相关的理论。《论赌博中的计算》一书的发表，标志着现代概率论的正式诞生。此书也被认为是现代概率论的第一本书。2. 18 世纪时期在 18 世纪时期，人们开始使用数学工具进行概率的计算，概率和概率论开始渐渐成为数学的一个重要分支，概率开始拥有了良好的数学基础。通过数学工具的运用，一些较为复杂的概率模型得以得到计算。18 世纪时期的著作中，1713 年发表的雅各布·伯努利(Jakob I. Bernoulli)的《猜度术》(Ars Conjectandi) 是 18 世纪概率论发展的里程碑。书中不仅完善和拓展了惠更斯的期望值理论和公式，提出了伯努利实验和概率的古典概型，而且提出了伯努利数[5]和伯努利定理，这是大数定律[6]的最早形式。惠更斯所提出的期望值公式为[11]E = \frac{p_0a_0 + p_1a_1 + \cdots + p_na_n}{p_1 + p_2 + \cdots + p_n}伯努利通过假设 $p_i$ 是互不相容的事件的概率，因此这就意味上式的分母为 $1$，从而使得惠更斯的公式得到简化。3. 19 世纪时期时间来到 19 世纪，19 世纪的天文学发展使得统计学和概率学说的应用越发广泛，此时，概率论的研究方法也越来越多的应用到了统计学上。同时，19 世纪的几个天才数学家也促进了概率论的长足发展。3.1 高斯其中之一便是高斯(Gauss)，高斯在数学方面的天赋是独特的，被称为“数学界的狐狸”。他于 1801 年使用基于正态误差分布的最小二乘法成功计算出了谷神星小行星的轨道（该行星于 1801 年 12 月 31 日夜晚被再次发现），并于 1809 年经过完善了相关数学理论后，发表了这一计算方法。在这年发表的文章中，高斯通过论证误差分布导出的极大似然估计 $=$ 算术平均值并证明了唯一满足这一性质的概率密度函数为f(x) = \frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{x^2}{2\sigma^2}}这就是正态分布的概率密度函数。但是高斯的数学证明部分并不完善，有种循环论证的味道：因为算术平均是优良的，所以误差符合正态分布；反过来，又基于正态分布来推导出最小二乘法和算术平均来说明其优良性。&lt;span class=”hint—top-right hint—error hint—large” aria-label=”靳志辉(2012 年 11 月 8 日) 正态分布的前世今生“&gt;[7]&lt;/span&gt;&lt;/a&gt;3.2 拉普拉斯此时便轮到拉普拉斯出场了，拉普拉斯也是著名的数学家，他发现的拉普拉斯变换和拉普拉斯方程在现今的图像处理等领域得到了广泛的运用。拉普拉斯在看到高斯发表的文章后，通过结合中心极限定理，提出了元误差解释，证明了正态分布的正确性。并在《概率的分析理论》(Théorie analytique des probabilités) 一书中结合了类似矩母函数、最小二乘法、归纳概率、假设检验等许多基本的统计学和概率论的理论。同时，拉普拉斯也发现了形式为f(x) = \frac{m}{2}e^{-m|x|}的概率密度分布函数，并在之后被命名为拉普拉斯分布3.3 19 世纪末到 19 世纪末为止，概率论与统计学的结合愈发紧密，在统计力学领域，波尔茨曼(Ludwig Eduard Boltzmann)和吉布斯(Josiah Willard Gibbs)利用概率论的方法，成功地解释了气体的性质，例如气体是随机运动的粒子。有趣的是，概率学的历史作为一项独立的分支，在这个时期也建立了起来。其标志便是托尔亨特(Isaac Todhunter)于 1865 年发表了其著名的著作 History of the Mathematical Theory of Probability from the Time of Pascal to that of Lagrange4. 20 世纪时期20 世纪时期，概率论和概率学说开始迅猛发展，公理体系建立起来，应用更为广泛，同时与其他科学领域的交叉也更为深入。4.1 概率与统计到了 20 世纪之后，由于统计学对假设检验的重视，概率论和统计学变得越发不可分割。现今，假设检验的统计方法已经广泛地应用到生物学，物理学和药物的临床试验等科学研究中。假设检验需要检测样本概率的显著性水平，从而判断是否接受统计假设。4.2 概率与物理学随着 20 世纪物理学进入微观领域的研究，概率论的随机过程领域的研究也有所进展。例如为了描述布朗运动（液体中的悬浮颗粒的运动），马可罗夫过程被提出，随后应用范围不断拓宽，现今马可罗夫过程已经应用于统计、生物学和计算机互联网中。4.3 概率与金融同时，由于 20 世纪前期经济的发展和马可罗夫过程的提出，为描述股票的随机波动提供了复杂的概率模型，从而也促进了金融数学的发展，并由此产生了布莱克-舒尔模型(BS Model)、期权定价等一系列金融工具[8]4.4 概率的解释20 世纪同时也见证了关于“概率的解释”的争端，在 20 世纪中期，概率被倾向于解释为 大量重复试验的频率的趋近值。而在 20 世纪末期，贝叶斯概率的观点得到复兴，贝叶斯概率学派的观点倾向于将概率定义为概率是某人对一个命题的信任程度两者的主要区别在于，频率学派主要以事件作为建模主体，而贝叶斯学派以观察者的知识作为概率的建模主体。观察者首先为事件赋予一个概率，并通过观察结果来校正概率。例如扔 100 次硬币，20 次正面，80 次反面。频率学派认为扔第 101 次的概率为 0.5，而贝叶斯学派认为概率应为 0.84.5 概率公理1933 年，安德雷·柯尔莫哥洛夫(Andrey Nikolaevich Kolmogorov) 提出了著名的概率公理，这解决了在具有无限的可能结果时的概率的数学处理问题。4.6 概率与计算机科学在 20 年代中后期，由于电子计算机的发明和核武器研制的需要，冯·诺伊曼，斯塔尼斯拉夫·乌拉姆和尼古拉斯·梅特罗波利斯提出了基于概率统计的蒙特卡洛方法。&lt;span class=”hint—top-right hint—error hint—large” aria-label=”Metropolis, Nicholas; Stanislaw Ulam (1949) The Monte Carlo method“&gt;[9]&lt;/span&gt;&lt;/a&gt;其中心观点是利用随机数通过计算机模拟计算得到随机过程。在解决实际问题的时候应用蒙特卡洛方法主要有两部分工作：&lt;span class=”hint—top-right hint—error hint—large” aria-label=”蒙特卡洛方法“&gt;[10]&lt;/span&gt;&lt;/a&gt;用蒙特卡洛方法模拟某一过程时，需要产生各种概率分布的随机变量。用统计方法把模型的数字特征估计出来，从而得到实际问题的数值解。5. 21 世纪后在 21 世纪后，概率和概率论随着机器学习和神经网络等计算机技术的发展，应用范围越加宽广。2006 年之后，雷米·库洛姆（Remi Coulom）提出了基于蒙特卡洛方法的蒙特卡洛搜索树算法。随后，这一算法被广泛应用到计算机围棋领域。2008 年，MoGo 在九路围棋中达到段位水平，2012 年 1 月，Zen 程序在19路围棋上以 3:1 击败二段棋手约翰·特朗普(John Tromp)，2016 年 3 月 使用蒙特卡洛算法和深度学习的 AlphaGo 程序在五番棋比赛中以 4:1 击败韩国九段棋手李世乭，Goranking 跃居世界第二。1.F. N. David (1962), Games, Gods and Gambling ↩2.Franklin, Science of Conjecture, ch. 11. ↩3.P. Chance magazine (2012) Some laws and problems in classical probability and how Cardano anticipated them Gorrochum ↩4.O'Connor, J. J.; Robertson, E. F.. &quot;The MacTutor History of Mathematics archive: Pierre de Fermat&quot; http://www-groups.dcs.st-and.ac.uk/~history/Biographies/Fermat.html ↩5.伯努利数最先由伯努利研究，棣莫弗以他的名字来命名，其计算公式为: $\sum_{j = 0}^{m}{m + 1 \choose j}B_j = 0$ ↩6.大数定律描述相当多次的重复实验的结果，其结果趋向于期望值 ↩7.靳志辉(2012 年 11 月 8 日) 正态分布的前世今生 ↩8.Bernstein, Against the Gods, ch. 18. ↩9.Metropolis, Nicholas; Stanislaw Ulam (1949) The Monte Carlo method ↩10.蒙特卡洛方法 ↩11.https://en.wikipedia.org/wiki/Ars_Conjectandi ↩]]></content>
      <categories>
        <category>复习</category>
        <category>概率论</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>概率论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[14. 无向图]]></title>
    <url>%2FAlgorithm%2F14.%20%E6%97%A0%E5%90%91%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[14.1 术语图是由一组顶点和将点连接起来的边组成的。相邻：如果两个顶点被至少一条边连接，那么就称顶点相邻，并称边依附于顶点。顶点的度：依附于它的边的条数子图：一幅图的子集（包括边和顶点）组成的图路径：由边顺序连接的一组顶点其中又分为简单路径和环：简单路径：没有重复顶点的路径简单环：起点和终点必须相同的没有重复顶点和边的环连通图：如果从任何一个顶点都存在一条路径到达另一个任意节点，那么称这幅图为连通图如果一副非联通图由若干个连通部分组成，那么这些部分都叫做极大连通子图无环图：就是没有环的图树是一幅无环连通图密度：已经连接的顶点对占所有可能被连接的顶点对的比例。这派生出了两个概念，稀疏图和稠密图。一般来说，如果一幅图中不同的边的数量在顶点总数$V$的一个小常数倍内，那么这幅图就是稀疏的二分图：一种能够将所有顶点分成两部分的图，其中每条边都连着两个不同的顶点14.2 表示法14.2.0 API为了解决有关图的问题，下面定义一个图的基本 API1234567891011121314151617public class Graph &#123; public Graph(int V) // Create graph using the Vertex number public Graph(In in) // Create graph from input stream public int V(); // The number of Vertex public int E(); // The number of Edge // Add edge v-w into graph public void addEdge(int v, int w); // The vertexes adjacent to v public Iterable&lt;Integer&gt; adj(int v); public String toString(); // The string explanation of graph&#125;14.2.1 邻接矩阵使用一个 $V \times V$ 的布尔矩阵来表示图，当 $v$ 和 $w$ 相邻时，将 v 行 w 列的元素标记为 true，否则为 false这种方法需要 $V^2$ 个布尔值的空间，实际上十分耗费存储空间，不实用。而且当图具有平行边时，邻接矩阵无法准确表示这一结构。14.2.2 边的数组我们可以定义一个 Edge 类，其中使用两个 int 变量来表示所连接的两个顶点。但是这一结构无法实现 adj()，实现它需要检查图中所有的边。14.2.3 邻接表数组我们可以使用一个以顶点为索引的列表数组，其中每个元素都是和该顶点相邻的顶点列表。即，每个数组元素既是一个顶点也是一个链表头，链表储存着与该顶点（链表头）相邻的所有顶点。它可以实现：使用的空间和 $V + E$ 成正比添加一条边所需的时间为常数遍历顶点 v 的所有相邻顶点所需要的时间和 v 的度数成正比对于这些操作来说，这样的特性已经是最优的了，所以我们选择邻接表来作为图的数据结构下面是图的代码实现：123456789101112131415161718192021222324252627282930313233343536373839404142public class Graph &#123; private final int V; // Vertex number private int E; // Edge number private Bar&lt;Integer&gt;[] adj; // adjacent array public Graph(int V) &#123; this.V = V; this.E = 0; adj = (Bag&lt;Integer&gt;[]) new Bag[V]; for (int v = 0; v &lt; V; v++) &#123; adj[v] = new Bag&lt;Integer&gt;(); &#125; &#125; public Graph(In in) &#123; this(in.readInt()); int E = in.readInt(); for (int i = 0; i &lt; E; i++) &#123; // Add Edge int v = in.readInt(); int w = in.readInt(); addEdge(v, w); &#125; &#125; public int V() &#123; return V; &#125; public int E() &#123; return E; &#125; public void addEdge(int v, int w) &#123; adj[v].add(w); adj[w].add(v); &#125; public Iterable&lt;Integer&gt; adj(int v) &#123; return adj[v]; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows 自动更新走代理]]></title>
    <url>%2Fwindows%20%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E8%B5%B0%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[本部校园网 v4 收费，windows 更新又是刚需，那么如何让 windows 自动更新走代理呢？其实只需要一条命令1netsh winhttp set proxy proxy-server="proxyserver:8080"即可让 windows 的“设置”走代理。注意，设置中的代理选项对其本身是不起作用的。这点还是 *nix 好啊。当然，也有想要直连的时候，使用如下命令即可恢复直连1netsh winhttp reset proxy]]></content>
      <tags>
        <tag>Proxy</tag>
      </tags>
  </entry>
</search>
